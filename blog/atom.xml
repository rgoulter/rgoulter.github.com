<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Richard Goulter's Blog</title>
    <link href="http://www.rgoulter.com/blog//atom.xml" rel="self" />
    <link href="http://www.rgoulter.com/blog/" />
    <id>http://www.rgoulter.com/blog//atom.xml</id>
    <author>
        <name>Richard Goulter</name>
        <email>richard.goulter+blog@gmail.com</email>
    </author>
    <updated>2020-07-26T00:00:00Z</updated>
    <entry>
    <title>Repairing my Razer Keyboard</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-07-26-repairing-my-razer-keyboard.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-07-26-repairing-my-razer-keyboard.html</id>
    <published>2020-07-26T00:00:00Z</published>
    <updated>2020-07-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July 26, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>I recently repaired my mechanical keyboard. It’s a Razer BlackWidow Ultimate, 2016 Edition that I’d bought on sale a couple of years ago.<br />
The result was an imperfect success.</p>
<p>The successful part: my keyboard now works and can be reliably used for typing and gaming. (Before, many of the keys didn’t activate when pressed; or only activated some of the time. Or seemed to work most of the time, but then sometimes would fail to activate).</p>
<p>The imperfect part: currently, three keys don’t work: numpad 5, numpad 4, and the right Windows key. And I didn’t bother to resolder the per-key LEDs. (And some blemishes on the PCB from some subpar desoldering work).</p>
<p>The repair involved replacing all the key switches on the keyboard.<br />
This came after I’d tried to see if compressed air would help with the keys.<br />
And after seeing if just desoldering and resoldering some of the ‘faulty’ keys would help. (This sortof seemed to improve some of the keys, at least from ‘not working at all’ to ‘working reliably’; but, it didn’t fix all of the keys).<br />
And after removing some of the switches, taking them apart to see if there was any ‘smoking gun’ that indicated any problems.</p>
<p>Most of the difficulties I had with desoldering would probably have been avoided if I had bought nicer soldering equipment. (I was just using the stuff on AliExpress which had the most orders). And if I had ordered soldering flux.</p>
<p>Searching the web, and Reddit, for advice would have helped with some of this, too. These were invaluable resources for finding out how to even do this stuff.</p>
<p>As an example of how I found desoldering difficult, my desoldering attempts would sometimes end up looking like this, despite my best efforts:</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/desoldering_difficulties_example.jpg" /></p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/desoldering_difficulties_example2.jpg" /></p>
<p>I didn’t have any significant success with desoldering braid. I don’t know why. Maybe the braid I bought was subpar quality, or the soldering iron. – But it didn’t seem to work like it did in the YouTube videos I watched.</p>
<p>The LEDs themselves were difficult to deal with.<br />
The LEDs make the keyboard fancy, in that they light up when the key is pressed; but the LEDs make changing key switches more difficult as they must be desoldered and removed before the key switch can be desoldered and removed.<br />
Desoldering and removing the LEDs was not easy.<br />
So my process was: I used a desoldering pump to remove some of the solder. Then I heated the LED legs so that I was able to remove the LED using tweezers. (I didn’t bother to do anything after this. But if I had to re-insert the LEDs, I would remove the rest of the solder).</p>
<p>Here’s another example of a difficulty I had. The F6 key here still had enough solder that the switch couldn’t be removed easily. (To fix this, you ought to add more solder back.. but I found this risked getting into the bad situation like above).</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/desoldering_difficulties_example_f6.jpg" /></p>
<p>Unfortunately, with my inexperience (and cheap tools?), I did end up damaging the board quite a bit.<br />
Most notably, Numpad 5:</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/desoldering_damaged_num5.jpg" /></p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/desoldering_damaged_numpad_back.jpg" /></p>
<p>(Some hand-wiring could be used to get this working again; but I don’t have the motivation or the resources to do that just yet).</p>
<p>The desoldering work on the rest of the PCB wasn’t great either. But, these keys seem to work fine anyway.</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/desoldering_result_not_pretty.jpg" /></p>
<p>After desoldering and removing the switches, the rest of the process was relatively straightforward: replace the switches, solder these, and reassemble the keyboard.</p>
<p>Even putting the switches in isn’t foolproof. e.g. Here some of the switches had their legs bent by not being careful when putting the switch in. (To be honest, I was impatient enough that I soldered some of these switches before realising this was a problem).</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/reswitching_difficulties.jpg" /></p>
<p>Here’s a view of the PCB and case with Gateron Blue switches in them.</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/reswitching_result.jpg" /></p>
<p>And here’s the final result.<br />
I used a keycap set with cute Totoro keycaps. (I don’t think these keycaps would show off the LEDs anyway).</p>
<p><img src="https://rgoulter.com/images/keyboards/razer-blackwidow-ultimate-2016/final_result.jpg" /></p>
<p>I’m pleased enough with the result.<br />
I probably wouldn’t be so pleased if the keys I broke were keys I use more often than the numpad.</p>
]]></summary>
</entry>
<entry>
    <title>Replaying Halo CE</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2020-07-25-replaying-halo-ce.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2020-07-25-replaying-halo-ce.html</id>
    <published>2020-07-25T00:00:00Z</published>
    <updated>2020-07-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July 25, 2020
    
        by richardgoulter
    <br/>
    
    Tags: 
    
</div>

<p>Halo recently re-released to Steam as part of the Halo Master Chief Collection. And I finally got around to re-playing it.</p>
<p>I’d played the game on PC some time after it was released.<br />
But I couldn’t remember the game as a whole. I did remember bits and pieces. I remember the first time I got to drive the Warthog vehicle. I remember parts of the game which introduce the zombie-like Flood monsters. – I didn’t remember the ending parts of the game.</p>
<p>More recently, I wasn’t super impressed with my first playthrough of “Halo: Reach”.<br />
I didn’t like the story.<br />
I wasn’t good enough at the gameplay to get into a good flow of it.</p>
<p>Halo CE is simpler than Halo Reach.<br />
It has fewer kinds of enemies.<br />
It doesn’t really have spaceship combat like Halo Reach had.<br />
Its story is essentially much simpler.<br />
– I think it sticks closer to the parts of the game I liked more.</p>
<p>The shooty-shooty parts are satisfying.<br />
The shotgun feels solid as it destroys the zombie-like Flood units in one hit.<br />
The enemies are threatening enough to demand attention.<br />
It’s nice when the game offers good tactics to hard-counter enemies. e.g. the human bullet-fed weapons are good against unshielded enemies and against the Flood, the alien laser weapons are good against shielded enemiesand against the robotic enemies.</p>
<p>Some parts weren’t so satisfying.<br />
The game’s default assault rifle is a pea-shooter. It’s generally just a bad gun to use.<br />
When the game did try and deliver story, it was often overlapping with action parts of the game.<br />
Some parts of the game, especially near the end, had infinitely-spawning enemies but it’s not really clear when you’re supposed to run, or supposed to just fight.</p>
<p>I also think that the auto-regenerating shield, and the limit of carrying only two weapons, limits the gameplay.<br />
Compared to Doom Eternal:<br />
When you run out of shields, you have to duck out of combat. When you run out of shields/health in Doom Eternal, you have to aggressively attack weaker enemies.<br />
When you need to use different weapons to fight different enemies: Halo you have to strategically choose two weapons. In Doom Eternal, your only limit is the ammunition for the weapons you have. And if you run out, you get more ammunition by chainsawing your enemies.</p>
<p>Halo does at least have vehicles which was quite fun.</p>
]]></summary>
</entry>
<entry>
    <title>My Experience with the Dvorak Keyboard Layout</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-07-08-my-experience-with-dvorak-keyboard-layout.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-07-08-my-experience-with-dvorak-keyboard-layout.html</id>
    <published>2020-07-08T00:00:00Z</published>
    <updated>2020-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July  8, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>One customization that some computer power users make is to use a different keyboard layout.</p>
<p>Back when I was a student at University I took the time to learn to use Dvorak layout.<br />
I can’t remember why I stopped using it, but I had reverted to using QWERTY layout since then.</p>
<p>Recently I started doing my main development work on a new computer. I decided to pick up the Dvorak layout again. (I think this was because I was looking at fancy ergonomic custom keyboards, and was reminded that I could be doing better than what I was using).</p>
<p>I’ve heard people say that the Dvorak layout is ‘faster’ than QWERTY. This is at least suggested because the layout used by the world record for fastest typing was using a Dvorak layout.<br />
For myself, my typing speed on the somewhat contrived typing tests is still slower with Dvorak than with QWERTY.<br />
However, the significant difference is comfort. – I never seriously took the time to do touch-typing drills and use the proper fingers for each key with QWERTY. (e.g. I’ve noticed that I’ll sometimes push the ‘y’ with my left hand index finger; e.g. in “anyone”, “my”, or “really”, but not for “you”). I don’t think this is uncommon. On the one hand, I find typing with QWERTY effortless. On the other hand, whenever I use QWERTY after using Dvorak, my hands feel cramped or choked. My hands must dance their way around the keyboard, not for exotic letters, but just for ordinary flow. With Dvorak, it feels more ‘right’.</p>
<p>In terms of switching between the two:</p>
<p>I think during the training period while I was learinig the Dvorak layout, my typing speed was <strong>significantly</strong> slower than normal, especially when I tried Dvorak. Typos were also extremely common. I’d guess this is due to the ‘motor memory’ of the hands being confused as to which finger is supposed to be where to type which letters.<br />
When I was recently picking up Dvorak as my main layout for work again: I use the Dvorak layout on my work computer, and QWERTY on my home computer. Using different keyboards for different layouts makes this much easier. (Again, my guess is the ‘motor memory’ has an easier time distinguishing the different layouts on different keyboards). Picking up Dvorak again is <em>mostly</em> like riding a bike again. My fingers didn’t quite forget everything. But, while I was still getting back up to speed, I tried using a colleague’s QWERTY keyboard and was very slow.</p>
<p>Unfortunately, this makes it significantly harder to recommend changing layouts to anyone who needs to type a lot.<br />
Maybe using a different keyboard to learn the layout would mitigate the effect, since your fingers can always use QWERTY on whatever other keyboard you use.</p>
<p>It’s also not a very big issue that the letters on the keycaps don’t match the letters you type into the keyboard. (The number keys and function keys will be the same anyway).</p>
<p>In terms of using software like Vim or Emacs which heavily rely on keybindings: In general, I think my mindset has the added indirection of ‘thinking’ about the letter to invoke the command, rather than the physical motion. - On Dvorak, the common shortcuts Ctrl-C, Ctrl-V, etc.: suck. This is made worse by that usually you’ll want to use these commands in tandem with using a mouse. So you won’t have both hands on the keyboard. - With using Dvorak with Vim: ‘h’ is still to the left of ‘l’; ‘j’ and ‘k’ are right beside each other. I was using Vim for a long time before I noticed that I use pretty much every key on the keyboard. The other keys in Dvorak are still there, just in different places, and I don’t give it much thought. - With using Dvorak with Emacs: C-x sucks. (For me this is somewhat mitigated: I use Evil, and can use the spacebar for things that I use frequently). But similarly, ‘p’ is still above ‘n’.</p>
<p>I’m not especially keen to try out other keyboard layouts after having gone through the effort to train with the Dvorak layout. If I were to pick up another layout today, though, I’d love to look at the Workman layout.</p>
]]></summary>
</entry>
<entry>
    <title>Re-reading High Fidelity</title>
    <link href="http://www.rgoulter.com/blog//posts/narrative/2020-05-29-rereading-high-fidelity.html" />
    <id>http://www.rgoulter.com/blog//posts/narrative/2020-05-29-rereading-high-fidelity.html</id>
    <published>2020-05-29T00:00:00Z</published>
    <updated>2020-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on May 29, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>I recently re-read Nick Hornby’s “High Fidelity”.</p>
<p>I love this story.<br />
It’s about a guy who’s a total music geek, and bit of a loser; and it’s a coming-of-age story as he ruminates over his romantic life.</p>
<p>One of the reasons I find the story fascinating is it’s narrated with the narrator’s stream-of-conscious.<br />
I love stream-of-conscious narratives. (Or I haven’t read many bad ones, anyway).<br />
Sometimes the narrator comes up with what sounds like insightful claims (like asking whether people listen to sad pop music because they’re sad, or whether they’re sad because they listen to sad pop music. Or … Or …). I can’t say I caught it the first time, but this is in-line with the main character’s personality.. the narrator’s mind comes up with all sorts of bullshit. – But (since it’s a coming-of-age story) the main character is immature, and never quite carries any of these thoughts through enough to improve himself.</p>
<p>I don’t often come across stories where the character is realistically miserable, but also charmingly redeemed.<br />
(And, I guess, it’s also nice to see a character who is not very considerate, but not malicious either).</p>
<p>Another reason I love this story is the rumination over the previous rejections.<br />
The narrator thinks <em>way</em> too much about the past, and (as he discovers) the way he thought about these times he got rejected didn’t really represent the reality of what occurred.</p>
<p>The movie “Definitely, Maybe” has (if you squint) similarities to this.<br />
In “Definitely, Maybe”, the main character is getting divorced. The main character narrates his history of romantic relationships (to his daughter) to show how things went wrong.<br />
And in “High Fidelity”, his girlfriend has just broken up with him, etc.<br />
Albeit, it’s more apparent that “Definitely, Maybe” is a sweet story.</p>
<p>I didn’t catch it (or didn’t remember it) from the times I’d read the book years ago what his most-recent girlfriend saw in him. Said woman has a high-paying job (where our narrator does not), has many friends (where our narrator does not), etc. But she does explain it to him.</p>
<p>I’d say what I disliked the most, upon re-reading it, was that the coming-of-age aspect doesn’t come from an internal realisation of the character, but from a huge amount of external aid. (And not even just from reading a book telling him to make his bed).</p>
]]></summary>
</entry>
<entry>
    <title>Long Tail of Org-Mode Features are Compelling</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-05-02-long-tail-of-org-mode-features-are-compelling.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-05-02-long-tail-of-org-mode-features-are-compelling.html</id>
    <published>2020-05-02T00:00:00Z</published>
    <updated>2020-05-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on May  2, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>One of the things I don’t like so much about proselytising of Emacs’ org-mode is mentioning the vast swarth of features org-mode has.<br />
Partly I think it’s ‘intimidating’ to see a bit list of features and be told “you have to learn this, it’s great”. (See <a href="https://orgmode.org/manual/">the org mode manual</a> table of contents for an overview).<br />
Partly because the use of those features strikes me as a “long tail”. I’ve tried most of the org-mode features, but most of the time I’m not using most of them.</p>
<p>Org mode is good. Other tools are good.<br />
– If there are things to consider about “what note-taking tool to use”, I’d rather think about limitations.</p>
<p>But.<br />
Org Mode has a wonderful synergy with plaintext.<br />
A lot of the stuff developers work with is good with plaintext.</p>
<p>That makes org-mode’s babel feature killer.</p>
<p>org-mode’s babel works with chunks of code snippets.<br />
Markdown etc. can put prose and code snippets together, but meta-info on code snippets (and keeping the output alongside the code) doesn’t seem to be as common. (I bet 80% of the power of org-babel could be had for 20% of the effort).<br />
<a href="http://www.howardism.org/Technical/Emacs/literate-devops.html">Literate Devops</a> demonstrates a couple of use cases of: “prose, code and output in a plaintext file”.</p>
<p>It really ought to have been obvious from the “Literal DevOps” post, but this usage of org-babel has other uses which are very useful.<br />
e.g. for learning and exploring a codebase, I’ve found it useful as a way for keeping the output of <code>grep</code>s, <code>cloc</code>s and other commands used to explore a repo. Similarly, “keeping the output of CLI programs” naturally makes sense for tools like AWS-CLI.</p>
]]></summary>
</entry>
<entry>
    <title>Doom Eternal</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2020-03-22-doom-eternal.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2020-03-22-doom-eternal.html</id>
    <published>2020-03-22T00:00:00Z</published>
    <updated>2020-03-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 22, 2020
    
        by richardgoulter
    <br/>
    
    Tags: 
    
</div>

<h2 id="hype">Hype</h2>
<p>I watched several interviews the Doom Eternal’s game director Hugo Martin on YouTube.</p>
<p>That he played with a controller on Nightmare difficulty is impressive. That’s legit. (<a href="https://www.youtube.com/watch?v=TzqR04OoTg4">Pax East 2020</a>, from 5:20 onwards).</p>
<p>The <a href="https://www.youtube.com/watch?v=TzqR04OoTg4">Noclip podcast</a> with him is also excellent.<br />
I was surprised to see Hugo Martin say things like: - After Doom 2016, they added features to the player’s abilities. This made the gameplay <em>so boring</em> since it was too easy to never die. They fixed this by making the enemies much harder. - People mocked a video of bad gameplay from Polygon. But, this was an example of Doom 2016’s failure. - Doom 2016 is the most fun when you character is moving around the battle arena, and switching between weapons. - He cites <a href="https://www.youtube.com/watch?v=72S2aAxtZOs">clockner’s speedrun of Kadingr Sanctum</a> as a demonstration of the peak of this. - While Doom 2016’s design did allow many gamers to enter this state-of-flow “fun zone”, it was also possible to play the game i) being very good and just using one weapon the whole time ii) being very bad and killing enemies without dynamic gameplay. - Doom Eternal remediates this in its game design. It punishes players who play outside the intended playstyle. (Hugo Martin compares this to sports like basketball, where everyone is restricted to a playstyle, but it’s still fun to play/watch). - Doom Eternal aims to keep its players engaged by having challenging enemies and encounters. Frustrating the player is <em>fine</em>, so long as the player does not blame the game.</p>
<p>The multiplayer also looked interesting.<br />
Doom 2016 did have some kind of multiplayer, but it wasn’t popular.<br />
Doom Eternal’s multiplayer is much closer in spirit to its single player. It’s 1v2. One player is the ‘doom slayer’. The other two play as weaker ‘demon’ units and are supported by weak AI demon units.<br />
– Asymmetric multiplayer isn’t a new idea. But I’m not aware of popular games which are single player oriented and have multiplayer which tries to feel like single player</p>
<p>I was hyped for this game, and pre-ordered it.</p>
<h2 id="what-i-thought-of-the-game">What I Thought of the Game</h2>
<p>I enjoyed it.</p>
<p>It’s intense.<br />
I’m not so good, but I still enjoyed it.</p>
<p>The gameplay itself is, uh, complicated.<br />
It builds off of Doom 2016’s gameplay.</p>
<h4 id="recall-doom-2016s-gameplay">Recall Doom 2016’s Gameplay</h4>
<p>Doom 2016’s gameplay seemed quite innovative. It certainly rewarded fast-paced gameplay.<br />
The traditional way of treating a player character’s health in first person shooters was to use health packs. But this can slow down gameplay as a player with low health searches for health pickups if they are low on health. – The ‘modern’ solution to this was to allow regenerating health. This chokes gameplay all over, though. (The game needs to damage the player enough so as to avoid an invincible character. So, the player is constantly waiting to regenerate health).<br />
Doom 2016’s solution was to: allow the player to ‘glory kill’ an enemy with low health in order to get health pickups. – A good way to get more health is to keep on attacking.</p>
<p>Doom 2016 also had: - A chainsaw. You’d find units of fuel on the map. Chainsawing a big enemy would need 3 units of fuel, whereas chainsawing a small enemy would take only 1. Chainsawing an enemy instantly kills it, and drops plenty of ammunition for your weapons. - Grenades. Different types of grenades. You could only have one or two. While there would be grenade ammunition on the map, the game also ‘regenerated’ grenades on a timer, so you wouldn’t run out. - Secrets/unlocks, which gave points for things you could upgrade. You could upgrade a lot: - You could add an attachment to your weapon (e.g. adding mini-missiles to your machine-gun). This attachment could then itself have upgrades (e.g. can fire mini-missiles more quickly). A fully-upgraded attachment could then be ‘mastered’ (e.g. kill enough enemies with it) so then it gets better. - Passive player upgrades. e.g. An upgrade point might give more health. - Passive ability upgrades. e.g. pick up items from further away. - ‘Runes’, which provide a passive ability (e.g. player gets a speed boost after glory killing an enemy). The runes can also be ‘mastered’ so that they get better.</p>
<h4 id="doom-eternals-additions">Doom Eternal’s Additions</h4>
<p>Doom Eternal is mostly more complicated than <em>that</em>.<br />
The one simpler thing is: they combine the passive abilities and upgrades for the player.</p>
<p>It makes sense that the player begins relatively weak, and ends the game with more upgrades. Without that scale, the game would be either too overwhelming or too easy at the start.</p>
<p>Gameplay-wise, the thing that gets more complicated than Doom 2016 is: - The game puts a strong emphasis on enemy weaknesses. You ‘can’ just shoot the enemies without considering this, but it’s <em>much</em> harder to do so. e.g. the giant fat monster with rockets for arms is much easier kill if you shoot off the rockets-launchers on its arms first. - This makes the game much more strategic/tactical to play. - You need to consider what weapons to use at each time; what you have available and what threats you’re facing. - The game really restricts the ammunition the player can carry. - This ‘encourages’ switching between weapons. - This also encourages using the chainsaw on enemies. (The player regenerates a unit of fuel if they have no fuel for the chainsaw). - The player has an ice grenade which they can use to freeze enemies, - The player has a flamethrower attachment. This also regenerates usages like the grenade does. It burns enemies. The burning enemies drop armour pickups for the player as they burn / are damaged. - …And a ‘blood punch’. Which does a large amount of damage in a small area. (It’s also used to take the armour off the armoured giant fat monster). - The game also added a ‘lives system’, allowing the player to respawn with full health if they’re killed. (Otherwise the player respawns from the latest checkpoint). This eases the fights against the most difficult enemies. (This feature can be disabled).</p>
<p>There are more enemies of different types. Probably one or two too many. The different strengths/weaknesses really lend to the need to <strong>think</strong> in order to fight well.</p>
<p>There are also unlocks for ‘cheat codes’ which can be used to replay a mission. (e.g. infinite ammo, semi-‘god mode’, etc.).</p>
<h4 id="controversial-design-decisions">Controversial Design Decisions</h4>
<p>The most controversial enemy (judging by the discussion forums) is the ‘marauder’ enemy.<br />
It’s <em>very</em> tough, even on the easiest difficulty.<br />
The marauder has a shield which blocks all damage. The marauder instantly raises the shield, except during a small timeframe when the marauder is attacking the player at a ‘good’ distance. (If the player is too close to the marauder, the marauder’s attack doesn’t lower its shield. Ditto if the player is too far away).</p>
<p>I think the marauder isn’t inherently tough. It’s easier once you learn the right distance to be, and a good rhythm to attack the marauder with.<br />
But it’s also a significantly harder encounter than other enemies. (It’s the only enemy which presents a threat when you’re using cheats, lol. It’s the only enemy that can’t otherwise just be brute forced even with the super weapons). And it’s a punishing enemy to have to learn how to play.<br />
– I think the game didn’t do enough to ease its way up to this enemy. But it’s also in the spirit of the game’s “play it our way”.</p>
<p>Also controversial: Doom Eternal’s addition of platforming.<br />
I don’t think this was so bad most of the time, but there are a couple of spots where I got stuck not knowing where to go next; even when I’d played the level a few times before.<br />
– I think it’s ‘fine’, though, since: i) if the game were 100% intense the whole time, the intensity would be less dramatic ii) it encourages the player to get a better feel for their platforming ability, which encourages the player to move around the arenas more.</p>
<p>I saw some people also disliked: the game added more cutscenes, and more in-your-face tutorial popups. But it’s easy to disable these, so I don’t see the issue.</p>
]]></summary>
</entry>
<entry>
    <title>Developer Training and Knowledge</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-03-10-developer-training-and-knowledge.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-03-10-developer-training-and-knowledge.html</id>
    <published>2020-03-10T00:00:00Z</published>
    <updated>2020-03-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 10, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>“What are the costs?” ought to be a natural question provided alongside “what are the benefits?”. This doesn’t get asked often enough in the discussions of new tools/technologies.<br />
The costs/benefits implicitly impact discussions since the trade-offs will be different in different situations.<br />
As a developer, I ought to have this in mind when consuming discussions.</p>
<p>To get better as a developer, I ought to increase my experience and skills:<br />
Experience is what I gain from recovering from mistakes.<br />
Skills I have are what I get from learning.<br />
So, online discussions about new tools/technolgies are relevant because they ask: “what skills should programmers have?”, and this is implicitly subject to “how much time/effort should be spent learning?”.</p>
<h3 id="costs-and-benefits">Costs and Benefits</h3>
<p>The universal answer to questions in computing is “it depends”.</p>
<p>Different groups/contexts consider costs and benefits differently.</p>
<p>There are innumerably many factors which can be better or worse between different tools. e.g. speed of development, ease of maintenance, ease of writing, ease of reading, ease of learning, similarity to other tools, compilation/runtime speeds, verbosity, implicit vs explicit, etc.<br />
– These will have different levels if importance to different people.</p>
<p>e.g. Steve Yegge’s <a href="https://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html">Portrait of a n00b</a> discusses that “experts” prefer code to be terse, whereas “n00bs” prefer lots of supporting information around the code itself.<br />
For the n00bs, code has a high cost to read, and so this cost is lowered with comments, metadata, and having less code on the screen. For experts, dense code has a higher signal-to-noise ratio.<br />
In its takeaways, the article suggests that paying the cost of metadata doesn’t necessarily give any benefit; but that e.g. surely the benefit of documentation for public-facing APIs is always worth paying for.<br />
– In <a href="http://archive.is/RalDb">this archive.is snapshot of a Google+ post</a>, Yegge further builds on this idea, with different preferences for ‘liberal’ vs ‘conservative’ programmers. The split is seen as different levels of comfort with the risk of breaking code in production. (“just fix it” vs “high level of confidence in correctness”).</p>
<h5 id="why-learn-and-what-to-learn">Why Learn and What to Learn</h5>
<p>This would be irrelavent if you just stuck with the tools/skills you’ve got and never bother to learn anything new.</p>
<p>The main external reasons to need to learn things are because you need to for school, or because the tools are used where you work.<br />
<em>Maybe</em> you’ll want to study more in the hopes of being more efficient in those roles.</p>
<p>As far as I can tell, though, the main reason to learn outside of that is ‘for fun’.<br />
Geeks argue about all this shit because it’s interesting to.</p>
<p>If you’re not learning some skill because you explicitly have to, or not just because you’re naturally interested in it, then at-best you’re making a bet on getting a higher reward (at some point in the future) than the cost you’re paying to learn.</p>
<p>Though, maybe even then there can be some benefit to that.<br />
e.g. <a href="http://www.paulgraham.com/pypar.html">Python Paradox</a> suggests that it’s lower-risk to try and hire developers who use “comparatively esoteric” programming languages like Python. (This was written in 2004), since the only people who would bother to learn Python are people who find it interesting. (Since you’re not going to get a job writing in Python).</p>
<p>This is also another way of describing <a href="https://mcfunley.com/choose-boring-technology">‘Choose Boring Technology’</a>. (It’s less risky to choose technology with known costs; as a rule of thumb, only use a few ‘new technologies’). The perjoratives “Hype-Driven Development” and “Resume Driven Development” also try and push back against choosing technologies for the benefit without understanding the cost.</p>
<h3 id="forever-learning-and-forever-forgetting">Forever Learning and Forever Forgetting</h3>
<p>Developers tend to take a ‘just in time’ approach to learning for work; taking advantage of ‘monkey-see monkey-do’.<br />
This somewhat changes the interpretation of “forever learning” from “there’s always more to learn, so I’ll be forever learning” to “I’m always working with different software development tools, so I’ll be forever learning”.</p>
<p>Either interpretation of “forever learning” would be fine,<br />
but I’m not sure there’s much adjustment for “forever forgetting”:<br />
In The Atlantic’s <a href="https://www.theatlantic.com/science/archive/2018/01/what-was-this-article-about-again/551603/">Why We Forget Most of the Books We Read</a>, the author mentions a <a href="https://en.wikipedia.org/wiki/Forgetting_curve">“forgetting curve”</a>. The article discusses that tools like the internet provide an ‘external memory’, allow us to get information without having to remember it ourselves. The result is that ‘recall memory’ (“ability to spontaneously call information up in your mind”) is less important than ‘recognition memory’ (remembering where the information is, and how to access it).</p>
<p>This feels like a pretty good model to me.</p>
<p>Maybe this means incremental reading isn’t such a bad idea. (Though it’s certainly not a <em>common</em> idea).</p>
<h5 id="boost-recall-with-spaced-repetition">Boost Recall with Spaced Repetition</h5>
<p>Programmers are familiar the idea of external memory. Search engines lead us to StackOverflow, or GitHub issues.<br />
Often documentation is pretty good, and editors with LSP support can even show this as you type out the code.<br />
Things like compiler errors, editor discoverability, and auto-complete help too.</p>
<p>Recall memory seems a bit more dull.<br />
For the tools/languages which I’m familiar with, there’ll be a lot which I don’t need to lookup. e.g. I can remember how to output text to STDOUT, how to import a package, how to define a function.</p>
<p>I think recall-misses where I need to stop to look things up don’t necessarily interrupt a state of flow.<br />
I think “having to look up documentation for stuff unrelated to the problem domain” is less of a problem than not being able to type. I think effective use of a text editor (like with vi or emacs or kakoune keybindings) is more important than either.<br />
– But, still: Surely it’d be great if I could recall things without spending time time to use a search engine to look for an answer.</p>
<p>To improve recall retention, what you want to recall would either need to be something you frequently use, or something you study.</p>
<p>Anki is ‘Spaced Repetition Software’ (SRS).<br />
It’s a flashcard program, but the intervals between when it tests you on a flashcard increase for each correct recall of that card.<br />
– Most of its users (as far as I can tell) use it for vocabulary studies, or for medical studies. As <a href="https://en.wikipedia.org/wiki/Spaced_repetition">Wikipedia’s page on Spaced Repetition</a> puts it: “spaced repetition is commonly applied in contexts in which a learner must acquire many items and retain them indefinitely in memory”.</p>
<p>This post <a href="http://augmentingcognition.com/ltm.html">“Augmenting Long Term Memory”</a> discusses use of Anki. e.g. to assist in digesting technical papers. (e.g. start with being able to recall surface level facts, then incrementally aim to recall facts which build upon those).<br />
The article also points out some drawbacks. It’s difficult to use Anki to improve recall for things you don’t actually care about. Adding flashcards isn’t (and probably shouldn’t be) low-effort. The article’s rule of thumb is it takes about 7 minutes of study per card per 20 years for a good flashcard (if each review of the card is 8 seconds).<br />
– The article also generally suggests against using Anki to remember APIs in the hope that this would one day be useful. It’s better to first know an API before trying to Ankify things about it. But it’s also a bad idea to keep Anki flashcards that you don’t care about around, e.g. if you aren’t likely to use the API again.</p>
<p>For myself, I’ve used Anki for a year and a half. Studied ~80% of those days. Added around 3900 cards. The vast majority of these cards are for vocabulary.<br />
– I do feel Anki does have a great benefit for the cost put into it. But it’s a bit more effort than “recall for free”.</p>
<h5 id="personal-knowledge-base">Personal Knowledge Base</h5>
<p>I’m beginning to like the idea of using a zettelkasten approach to storing reference.<br />
This seems a more suitable approach between “ankify everything” and “go to the effort of recalling exactly what you came across”.</p>
<p>The important part of zettelkasten notes, as I understand it, is that each note in the system is small, the note hyperlinks to other notes, and the use of tagging helps with random lookup/search of the notes.</p>
<p>In particular, there’s not necessarily a hierarchical structure to the notes. The benefit of this is you don’t have to try to remember where a note was put.</p>
<h3 id="examples">Examples</h3>
<p>Some examples in my mind make a bit more sense with “cost vs benefit”.</p>
<ul>
<li><p>I’m hopeful for elm-lang. It strikes me as (relatively) low-cost to learn to use, and I think this cost is far outweighed by the benefits gained.</p></li>
<li><p>I’m pessimistic about the value of Rust for general purpose software development. In constrast to elm-lang (where elm-lang’s syntax was weird, but the logic was easy to follow): Rust’s syntax is kinda sorta weird, writing something you’ve not done before in Rust can be hard even with some familiarity with the language, and Rust’s USP isn’t a big win in common cases.<br />
Using Rust is surely high-reward in some use cases; but I’m not sure it ever becomes low-cost in most cases.</p></li>
<li>I was fascinated by <a href="https://twitter.com/Jonathan_Blow/status/781597528047230976">the argument in favour of the array-processing programming language K</a> and <a href="https://news.ycombinator.com/item?id=22504106">the HN discussion</a>.
<ul>
<li>What strikes me the most as “using a concise sequence of operators” is to using “FP-ish methods like sum” as those are to “explicit for loop”.
<ul>
<li>The best I can make of it is: you’d have to go and learn what each of the symbols does. There aren’t <em>that</em> many and there’s a big benefit to learning them. And without experience(?) you should’t have the expectation to be able to quickly read K programs.</li>
<li>Which is enough to convince me that the idea of a language like that isn’t completely crazy.</li>
<li>But also that: I don’t think using “FP-ish methods” isn’t too far from developers are used to, or able to read. Whereas seeing <code>q::n 9'a</code> doesn’t really bring <a href="https://kparc.com/edit.k">“syntax coloring”</a> to mind.<br />
(So I could believe taking the time to learn K would be worthwhile, I don’t think anyone should be surprised that not everyone sees the benefits when the costs are so apparent).</li>
</ul></li>
<li>I also found the post’s response to the idea of readability interesting. A symbol operator isn’t necessarily harder to read than a full word. With the word you might think you can guess what it means, but you might be wrong. An operator is going to be precise.
<ul>
<li>There are languages which I’m more familiar with which somewhat take this approach.<br />
e.g. Scala’s <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">List</a> keeps <code>+:</code> (for ‘prepend’) and <code>:+</code> (guess what for?), but deprecates <code>/:</code> and <code>:\</code>.<br />
e.g. Haskell has a few (e.g. see <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/doc-index-All.html">the start and end of base’s index</a>).</li>
<li>Overall, I don’t think it’s absolute that terms are ambiguous or that using only operators would give a more accurate understanding of the program ‘for free’.</li>
</ul></li>
</ul></li>
<li>Category Theory. As I understand it, Category Theory is simple, but not easy. So the cost to studying it isn’t so low. But it’s also kinda hard to see the benefits beyond it being inherently interesting.<br />
It’s neat to see <a href="https://blog.ploeh.dk/2019/12/30/semigroup-resonance-fizzbuzz/">unusual solutions to fizzbuzz like ploeh.dk’s</a>; but the code itself can be understood without category theory. (Well, readable if you can recall what <code>&lt;$&gt;</code> and <code>&lt;&gt;</code> do).
<ul>
<li>FWIW, “simple but not easy” seems like a reasonably fine fit for Anki flashcards.</li>
</ul></li>
<li>Haskell.
<ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a> is really cute. And straightforward.
<ul>
<li>With that I can make simple-ish toy projects and then wish other languages had ADTs and pattern matching and type safety like that.</li>
</ul></li>
<li>e.g. <a href="http://degoes.net/articles/modern-fp">This post using free monads</a> is very cool to read. But I’d also want to go and read about what/how a lens <code>Prism</code> is.</li>
<li>I get the impression that ‘real’ Haskell relies on several more complicated concepts like that. Maybe they’re “simple but not easy” too.
<ul>
<li>e.g. the posts linked from https://www.simplehaskell.org/ are very in-line with what I’m trying to get at.
<ul>
<li>It’s not that using ‘fancy types’ or the academic bleeding edge of what’s possible in Haskell is bad, or impractical. But for many non-Haskell developers, the costs to that kind of style look heavy and it’s not apparent that it’d be better than just writing working code in JavaScript.</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>I think the reason we end up with <a href="https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html">“Command Line Tools can be Faster than your Hadoop Cluster”</a> or <a href="https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim">“Your problem with vim is that you don’t grok vi”</a> is because of a lack of consideration of cost/benefit, which led to mistakenly not taking the time to learn things which would have been better.</p></li>
<li><p><a href="https://pythonspeed.com/articles/dont-need-kubernetes/">pythonspeed’s discussion of kubernetes drawbacks</a> makes it clear that the costs of running kubernetes for a small team outweigh the benefits. I think if the complexity had been communicated alongside the hype, it’s not a technical decision anyone would make.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Early Impression of Elm</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-02-28-early-impression-of-elm-lang.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-02-28-early-impression-of-elm-lang.html</id>
    <published>2020-02-28T00:00:00Z</published>
    <updated>2020-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February 28, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>Recently I wrote some Elm-lang code as part of a casual side-project.</p>
<p>The Elm program was simple, though non-trivial.<br />
The program was a UI for making notes from emails. The Elm program presented a list of emails for the user to select, and let the user CRUD a note for the selected email.</p>
<p>Some changesets: - https://github.com/rgoulter/simple-email-data-tool/pull/1/files Initially adding the Elm program with Travis-CI config, RSpec spec with Capybara, and the Elm program. - https://github.com/rgoulter/simple-email-data-tool/pull/5 Changing from a <code>&lt;select/&gt;</code> to a <code>&lt;table&gt;</code> for one of the widgets. (I was surprised by how easy this change was). - https://github.com/rgoulter/simple-email-data-tool/pull/6/files Adding keybindings to the input. - https://github.com/rgoulter/simple-email-data-tool/pull/8/files Adding date filtering, using a third-party pure-Elm library.</p>
<h3 id="where-im-coming-from">Where I’m Coming From</h3>
<ul>
<li><p>I’d be lying if I said I was very experienced with front-end code. e.g. I can’t think of any big mistakes I’ve made and things I’ve learned from said mistakes. The basics are straightforward; and a deep understanding of front-end web development requires an appreciation for all aspects of how a web browser works, which isn’t easy.</p></li>
<li>On the continuum of ‘liberal programmer’ (“if it breaks, just fix it”; likes Python, Ruby) to ‘conservative programmer’ (wants to know if it works at compile time; likes Haskell) I’m towards the ‘conservative’ end.
<ul>
<li>I’m inclined to like Elm.</li>
</ul></li>
</ul>
<h3 id="what-i-didnt-like-about-elm">What I Didn’t Like About Elm</h3>
<ul>
<li>I was surprised that some things in Elm were (much) harder than they would be in JavaScript.
<ul>
<li>I wasn’t able to figure out how to nicely access the query parameters of the URI. (I ended up getting something which could access the query parameters at a specific path; but I couldn’t figure it out for any arbitrary path). This is an example of “easy in JavaScript, hard in Elm”.
<ul>
<li>While I found this frustrating, I think the Elm-lang documentation makes it clear <em>why</em> it makes this kind of thing ‘hard’.
<ul>
<li>Elm is all about removing footguns. In this case, easy access to the window’s URI query params would introduce impurity; so, to access window’s URI your Elm program also need to ‘manage’ the URI.</li>
</ul></li>
<li>But I would anticipate further “of <em>course</em> that wouldn’t be straightforward in Elm” when considering Elm as a language.</li>
</ul></li>
</ul></li>
<li><p>e.g. I wouldn’t wanna write this blog website’s page with Elm, since the Elm runtime is JavaScript; so if I used Elm then it wouldn’t be accessible to users with JavaScript disabled.</p></li>
<li><p>I still have to look into idioms or idiosyncracies about combining modules together. I’m not sure I ‘get’ it, or if the approach I took was stupid or fine.</p></li>
</ul>
<h3 id="what-i-found-interesting-about-elm">What I Found Interesting About Elm</h3>
<ul>
<li>The Elm Architecture. The restricted nature of Elm’s code means that, while code still doesn’t magically end up well designed, it still ends up being somewhat (or close to) idiomatic.
<ul>
<li>My experience with GUIs other than Elm has been with languages that allow you to more/less update the code’s state from anywhere.</li>
<li>With Elm, you have a ‘model’ Algebraic type, a ‘message’ Algebraic type.
<ul>
<li>Anything the Elm program needs to care about goes in its model.</li>
<li>Any ‘action’ that might happen in the Elm program is represented by a message.</li>
<li>The only place the model gets changes is in its update function.</li>
<li>The only way effects happen is through messages.</li>
</ul></li>
<li>The question becomes “what nouns, what verbs do I want in this system? What is each noun? What does each verb do?”.</li>
</ul></li>
<li>Because of that explicitness and lack of mutation, edge cases (and race conditions) are surfaced.</li>
</ul>
<h3 id="what-i-liked-about-elm">What I Liked About Elm</h3>
<ul>
<li><p>It’s not JavaScript. Programming in JavaScript is .. fine. But I don’t particularly like JavaScript. It feels very blobbish.</p></li>
<li><p>95% of the time it’s a joy to write in Elm. (Most of the time it’s not a joy to write in are the times when you’re trying to do something which would be easy to do in JavaScript. Or with impurity like time/randomness).</p></li>
<li><p>Elm mostly has the “if it compiles it works” aspect to it.</p></li>
<li>Elm programs/modules are self contained and small.
<ul>
<li>Everything you need in a module must be explicitly imported.</li>
<li>The lack of mutation means things are much more explicit.</li>
</ul></li>
<li><p>Elm’s record syntax is nicer than Haskell’s.</p></li>
</ul>
<h3 id="my-development-experience">My Development Experience</h3>
<ul>
<li><p>I mocked the API that my Elm program would call with simple Ruby’s Sinatra servers.</p></li>
<li><p>I wrote RSpec specs which would compile the Elm program before running Selenium tests against the Elm program.</p></li>
<li><p>My program wasn’t sophisticated enough to need much development work on components individually. But I did find it easy enough to use “elm reactor” (compiles + serves the Elm source) to focus on one component at a time.</p></li>
<li>I developed my Elm program using Emacs. The most popular elm-mode gave me syntax highlighting. I didn’t feel the need to make use of elm-mode’s other IDE features.
<ul>
<li>For code completion: I developed my Elm program on Windows. There’s an Elm language server. Unfortunately, I think because Windows is slow at launching processes, I found it was too slow for me to use with Emacs on Windows.</li>
</ul></li>
<li><p>I didn’t make good use of it, but there is support in universal-ctags.</p></li>
</ul>
<h3 id="would-i-use-it">Would I Use It?</h3>
<p>After having used it for a side-project, without the burden of needing to ship something reliable by some deadline:</p>
<p>Yes, I’m quite happy with the experience.</p>
<p>Obivously I’m interested in liking it, though; and this wasn’t a high-risk project, so:<br />
What situations/cases would I not recommend using it for?<br />
- Projects which benefit from a rapid prototyping/delivery (e.g. code maintainability/quality can be traded off) by an experienced team which lacks any experience Elm. - Projects which already show evidence of some kind of a “lava flow” antipattern, or projects where using Elm is likely to lead (or contribute) to an anti-pattern like this. - Projects where Elm is chosen without consideration for <a href="https://mcfunley.com/choose-boring-technology">‘Choose Boring Technology’</a>. - If I were given responsibility to maintain some front-end application code which was poorly written in JavaScript using ReactJS: - While it’s possible to interop Elm and JavaScript, I think the complexity of the same maintainers mixing the code would outweigh benefits of using Elm. - etc.</p>
<p>I think websites would be better maintained if they were developed with the discipline that Elm does a lot to help.</p>
]]></summary>
</entry>
<entry>
    <title>On Agile</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-01-25-on-agile.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-01-25-on-agile.html</id>
    <published>2020-01-25T00:00:00Z</published>
    <updated>2020-01-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 25, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>“Agile”, “Scrum” and “Kanban” all get a rather bad reputation among developers on the internet. They seem to work well for <em>some</em> teams, but for others these are <a href="https://media.defense.gov/2018/Oct/09/2002049591/-1/-1/0/DIB_DETECTING_AGILE_BS_2018.10.05.PDF">“waterfall or spiral development in agile clothing”</a>.</p>
<p>At worst, teams take tasks off a todo list however they would anyway and call it ‘agile’.</p>
<p>At best, maybe the differences can be explained as “‘agile’ works well for some kinds of development work; but not well for others” (I’m not convinced by this as-such) or “‘agile’ works well for good teams. For good teams, anything would work well”. (Which wouldn’t mean ‘agile’ is useless; so much as, it’s not a silver bullet).</p>
<p>But <em>part</em> of the disagreement, I think, comes from the ol’ “people using the same words to refer to different things”. Especially people with different understandings, let alone experiences.</p>
<p>I’d come across the terms ‘kanban’ and ‘kanban board’ for years before I picked up a book which discussed kanban. I was surprised to see the idea of a kanban board was related to principles: visualize the workflow, limit work in progress.<br />
“Either a worker is idle or a task is idle”. The idea is to maximise ‘flow’ of tasks. Limiting work in progress and visualizing it on a board ought to help identify bottlenecks, which can be addressed.</p>
<p>Beyond that, there are all sorts of details as to tactics and techniques for implementing this. But the basic idea sounds ‘obvious’ and intuitive and, for some workflows, a good idea.</p>
<p>I, uh, don’t know if a ‘kanban board’ can properly be called a ‘kanban board’ if these principles aren’t followed. I suspect places which just use the column-of-tasks aren’t likely to follow “limit WIP”. But I suspect most places which don’t follow “limit WIP” are still happy to say they “do kanban” and are agile.</p>
<p>In any case, it seems unprofessional that so many development teams would be using ‘kanban’ or ‘scrum’ but without following (or knowing) the key ideas. I think this is because agile <em>sounds</em> hip.</p>
<hr />
<p>Being surprised about ‘kanban’, I’ve decided to read up on ‘scrum’. (The one with ‘sprints’ and stuff).</p>
<p>At a glance, it seems to have the same “oh <em>that</em> makes sense” as kanban, as <em>well</em> as “…because of these underlying values”.</p>
<p>But the book I was reading pointed out: <em>of course</em> if the team doesn’t have psychological safety / trust / respect for each other, then ‘scrum’ isn’t going to work.</p>
<p>I’d guess there’s still value in following a process in order to try and surface problems. But surely a political and unsafe team isn’t going to identify or address problems easily.</p>
<p>I think, then, the hype over ‘agile’ is a bit misplaced.<br />
Not because the ideas around it are worthless so much as the heavy-lifting of effective teams seems to be the psychological safety aspect.<br />
From there, I think the ‘agile’ ideas make sense for a reasonably wide variety of work. (I imagine obstacles like: e.g. a focus on small improvements may obscure long-term strategic mistakes).</p>
]]></summary>
</entry>
<entry>
    <title>On the 2019 UK Election Results</title>
    <link href="http://www.rgoulter.com/blog//posts/politics/2019-12-14-on-2019-election-results.html" />
    <id>http://www.rgoulter.com/blog//posts/politics/2019-12-14-on-2019-election-results.html</id>
    <published>2019-12-14T00:00:00Z</published>
    <updated>2019-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December 14, 2019
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>I found these two comments interesting: 1. Twitter Thread https://twitter.com/LukePagarani/status/1205487970897342464?s=20 What I get from this is: The perspective is a leftist voter discussing that people he met didn’t value the same things that Labour/Corbyn did. Such voters valued their national identity, and so really didn’t like Corbyn. 2. Quillette post https://quillette.com/2019/12/13/britains-labour-party-got-woke-and-now-its-broke/</p>
<p>I find it interesting that these two comments more/less agree on many things. – I think they look at “people don’t like Corbyn because they love their country” differently, but that makes how much narrative they share that much more interesting to me.<br />
(Bonus: compare the above Tweeter’s RT of this with the quotes from the article: https://twitter.com/SoysalOzlu/status/1205526147288707074?s=20)</p>
<p>I think the two comments also highlight the way the different moral foundations (of Moral Foundation Theory) are emphasised. “Britain should take care of British people first/foremost” vs “all people are equal” rings true for loyalty and fairness moral foundations respectively.</p>
<p>I remember seeing a comment I saw discussing that the Brexit vote is best justified in terms of a question of identity. (If it were about immigration or economics or whatever, then there would be other more effective measures to reach these ends).</p>
<p>It reminds me of <a href="https://www.youtube.com/watch?v=LJKXJNM3W-c">Stephen Fry at the Munk Debates</a> (at around 4:30) saying that he’s concerned “the greatest human failings is to prefer to be right, than to be effective”. – I don’t interpret this to mean that he’d prefer to be effective at what’s not-right. I interpret this as saying that it’s wrong to focus on symbolic value over more effective results.</p>
<p><a href="https://meaningness.com/metablog/virtue-court">Meaningness’ Court of Values and Bureau of Boringness</a> is a fun play on the problem this can present. The problem is, much of politics today is performance towards showing the right virtues; this distracts or counteracts ‘boring’ solutions to problems. – One (dumb, but fun) suggestion is to allow people one vote towards either a ‘boring’ serious court, or towards a mostly-powerless court which decides what values people should be rewarded/punished for showing.</p>
<p>I see concerns on Twitter about how awful the implications of this result are. (My impression is that these come from the same group as “it’s racist to vote for the options I don’t like”, which isn’t persuasive). I’m also under the impression that these worries still wouldn’t be enough to sway voters! As in, the symbolic value of “our national identity” apparently matters a lot!<br />
– I think the flipside is the same point, though. My understanding is Labour’s absymal result in these elections is the best they could do in the situation. But: if it is the case that the winners won the vote because of a symbolic policy: surely it would be reasonable to appeal to the voters’ symbolic values to support your cause?</p>
<p>It’s probably a bit too much of a simplification, but it’s still tempting to match “voted for Brexit, despite probable material harm” and “won’t say ‘my country is great’, despite likely losing for that” as matching “would rather be right than effective”.</p>
]]></summary>
</entry>

</feed>
