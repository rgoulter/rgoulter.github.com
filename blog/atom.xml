<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Richard Goulter's Blog</title>
    <link href="http://www.rgoulter.com/blog//atom.xml" rel="self" />
    <link href="http://www.rgoulter.com/blog/" />
    <id>http://www.rgoulter.com/blog//atom.xml</id>
    <author>
        <name>Richard Goulter</name>
        <email>richard.goulter+blog@gmail.com</email>
    </author>
    <updated>2020-07-08T00:00:00Z</updated>
    <entry>
    <title>My Experience with the Dvorak Keyboard Layout</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-07-08-my-experience-with-dvorak-keyboard-layout.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-07-08-my-experience-with-dvorak-keyboard-layout.html</id>
    <published>2020-07-08T00:00:00Z</published>
    <updated>2020-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July  8, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>One customization that some computer power users make is to use a different keyboard layout.</p>
<p>Back when I was a student at University I took the time to learn to use Dvorak layout.<br />
I can’t remember why I stopped using it, but I had reverted to using QWERTY layout since then.</p>
<p>Recently I started doing my main development work on a new computer. I decided to pick up the Dvorak layout again. (I think this was because I was looking at fancy ergonomic custom keyboards, and was reminded that I could be doing better than what I was using).</p>
<p>I’ve heard people say that the Dvorak layout is ‘faster’ than QWERTY. This is at least suggested because the layout used by the world record for fastest typing was using a Dvorak layout.<br />
For myself, my typing speed on the somewhat contrived typing tests is still slower with Dvorak than with QWERTY.<br />
However, the significant difference is comfort. – I never seriously took the time to do touch-typing drills and use the proper fingers for each key with QWERTY. (e.g. I’ve noticed that I’ll sometimes push the ‘y’ with my left hand index finger; e.g. in “anyone”, “my”, or “really”, but not for “you”). I don’t think this is uncommon. On the one hand, I find typing with QWERTY effortless. On the other hand, whenever I use QWERTY after using Dvorak, my hands feel cramped or choked. My hands must dance their way around the keyboard, not for exotic letters, but just for ordinary flow. With Dvorak, it feels more ‘right’.</p>
<p>In terms of switching between the two:</p>
<p>I think during the training period while I was learinig the Dvorak layout, my typing speed was <strong>significantly</strong> slower than normal, especially when I tried Dvorak. Typos were also extremely common. I’d guess this is due to the ‘motor memory’ of the hands being confused as to which finger is supposed to be where to type which letters.<br />
When I was recently picking up Dvorak as my main layout for work again: I use the Dvorak layout on my work computer, and QWERTY on my home computer. Using different keyboards for different layouts makes this much easier. (Again, my guess is the ‘motor memory’ has an easier time distinguishing the different layouts on different keyboards). Picking up Dvorak again is <em>mostly</em> like riding a bike again. My fingers didn’t quite forget everything. But, while I was still getting back up to speed, I tried using a colleague’s QWERTY keyboard and was very slow.</p>
<p>Unfortunately, this makes it significantly harder to recommend changing layouts to anyone who needs to type a lot.<br />
Maybe using a different keyboard to learn the layout would mitigate the effect, since your fingers can always use QWERTY on whatever other keyboard you use.</p>
<p>It’s also not a very big issue that the letters on the keycaps don’t match the letters you type into the keyboard. (The number keys and function keys will be the same anyway).</p>
<p>In terms of using software like Vim or Emacs which heavily rely on keybindings: In general, I think my mindset has the added indirection of ‘thinking’ about the letter to invoke the command, rather than the physical motion. - On Dvorak, the common shortcuts Ctrl-C, Ctrl-V, etc.: suck. This is made worse by that usually you’ll want to use these commands in tandem with using a mouse. So you won’t have both hands on the keyboard. - With using Dvorak with Vim: ‘h’ is still to the left of ‘l’; ‘j’ and ‘k’ are right beside each other. I was using Vim for a long time before I noticed that I use pretty much every key on the keyboard. The other keys in Dvorak are still there, just in different places, and I don’t give it much thought. - With using Dvorak with Emacs: C-x sucks. (For me this is somewhat mitigated: I use Evil, and can use the spacebar for things that I use frequently). But similarly, ‘p’ is still above ‘n’.</p>
<p>I’m not especially keen to try out other keyboard layouts after having gone through the effort to train with the Dvorak layout. If I were to pick up another layout today, though, I’d love to look at the Workman layout.</p>
]]></summary>
</entry>
<entry>
    <title>Re-reading High Fidelity</title>
    <link href="http://www.rgoulter.com/blog//posts/narrative/2020-05-29-rereading-high-fidelity.html" />
    <id>http://www.rgoulter.com/blog//posts/narrative/2020-05-29-rereading-high-fidelity.html</id>
    <published>2020-05-29T00:00:00Z</published>
    <updated>2020-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on May 29, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>I recently re-read Nick Hornby’s “High Fidelity”.</p>
<p>I love this story.<br />
It’s about a guy who’s a total music geek, and bit of a loser; and it’s a coming-of-age story as he ruminates over his romantic life.</p>
<p>One of the reasons I find the story fascinating is it’s narrated with the narrator’s stream-of-conscious.<br />
I love stream-of-conscious narratives. (Or I haven’t read many bad ones, anyway).<br />
Sometimes the narrator comes up with what sounds like insightful claims (like asking whether people listen to sad pop music because they’re sad, or whether they’re sad because they listen to sad pop music. Or … Or …). I can’t say I caught it the first time, but this is in-line with the main character’s personality.. the narrator’s mind comes up with all sorts of bullshit. – But (since it’s a coming-of-age story) the main character is immature, and never quite carries any of these thoughts through enough to improve himself.</p>
<p>I don’t often come across stories where the character is realistically miserable, but also charmingly redeemed.<br />
(And, I guess, it’s also nice to see a character who is not very considerate, but not malicious either).</p>
<p>Another reason I love this story is the rumination over the previous rejections.<br />
The narrator thinks <em>way</em> too much about the past, and (as he discovers) the way he thought about these times he got rejected didn’t really represent the reality of what occurred.</p>
<p>The movie “Definitely, Maybe” has (if you squint) similarities to this.<br />
In “Definitely, Maybe”, the main character is getting divorced. The main character narrates his history of romantic relationships (to his daughter) to show how things went wrong.<br />
And in “High Fidelity”, his girlfriend has just broken up with him, etc.<br />
Albeit, it’s more apparent that “Definitely, Maybe” is a sweet story.</p>
<p>I didn’t catch it (or didn’t remember it) from the times I’d read the book years ago what his most-recent girlfriend saw in him. Said woman has a high-paying job (where our narrator does not), has many friends (where our narrator does not), etc. But she does explain it to him.</p>
<p>I’d say what I disliked the most, upon re-reading it, was that the coming-of-age aspect doesn’t come from an internal realisation of the character, but from a huge amount of external aid. (And not even just from reading a book telling him to make his bed).</p>
]]></summary>
</entry>
<entry>
    <title>Long Tail of Org-Mode Features are Compelling</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-05-02-long-tail-of-org-mode-features-are-compelling.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-05-02-long-tail-of-org-mode-features-are-compelling.html</id>
    <published>2020-05-02T00:00:00Z</published>
    <updated>2020-05-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on May  2, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>One of the things I don’t like so much about proselytising of Emacs’ org-mode is mentioning the vast swarth of features org-mode has.<br />
Partly I think it’s ‘intimidating’ to see a bit list of features and be told “you have to learn this, it’s great”. (See <a href="https://orgmode.org/manual/">the org mode manual</a> table of contents for an overview).<br />
Partly because the use of those features strikes me as a “long tail”. I’ve tried most of the org-mode features, but most of the time I’m not using most of them.</p>
<p>Org mode is good. Other tools are good.<br />
– If there are things to consider about “what note-taking tool to use”, I’d rather think about limitations.</p>
<p>But.<br />
Org Mode has a wonderful synergy with plaintext.<br />
A lot of the stuff developers work with is good with plaintext.</p>
<p>That makes org-mode’s babel feature killer.</p>
<p>org-mode’s babel works with chunks of code snippets.<br />
Markdown etc. can put prose and code snippets together, but meta-info on code snippets (and keeping the output alongside the code) doesn’t seem to be as common. (I bet 80% of the power of org-babel could be had for 20% of the effort).<br />
<a href="http://www.howardism.org/Technical/Emacs/literate-devops.html">Literate Devops</a> demonstrates a couple of use cases of: “prose, code and output in a plaintext file”.</p>
<p>It really ought to have been obvious from the “Literal DevOps” post, but this usage of org-babel has other uses which are very useful.<br />
e.g. for learning and exploring a codebase, I’ve found it useful as a way for keeping the output of <code>grep</code>s, <code>cloc</code>s and other commands used to explore a repo. Similarly, “keeping the output of CLI programs” naturally makes sense for tools like AWS-CLI.</p>
]]></summary>
</entry>
<entry>
    <title>Doom Eternal</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2020-03-22-doom-eternal.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2020-03-22-doom-eternal.html</id>
    <published>2020-03-22T00:00:00Z</published>
    <updated>2020-03-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 22, 2020
    
        by richardgoulter
    <br/>
    
    Tags: 
    
</div>

<h2 id="hype">Hype</h2>
<p>I watched several interviews the Doom Eternal’s game director Hugo Martin on YouTube.</p>
<p>That he played with a controller on Nightmare difficulty is impressive. That’s legit. (<a href="https://www.youtube.com/watch?v=TzqR04OoTg4">Pax East 2020</a>, from 5:20 onwards).</p>
<p>The <a href="https://www.youtube.com/watch?v=TzqR04OoTg4">Noclip podcast</a> with him is also excellent.<br />
I was surprised to see Hugo Martin say things like: - After Doom 2016, they added features to the player’s abilities. This made the gameplay <em>so boring</em> since it was too easy to never die. They fixed this by making the enemies much harder. - People mocked a video of bad gameplay from Polygon. But, this was an example of Doom 2016’s failure. - Doom 2016 is the most fun when you character is moving around the battle arena, and switching between weapons. - He cites <a href="https://www.youtube.com/watch?v=72S2aAxtZOs">clockner’s speedrun of Kadingr Sanctum</a> as a demonstration of the peak of this. - While Doom 2016’s design did allow many gamers to enter this state-of-flow “fun zone”, it was also possible to play the game i) being very good and just using one weapon the whole time ii) being very bad and killing enemies without dynamic gameplay. - Doom Eternal remediates this in its game design. It punishes players who play outside the intended playstyle. (Hugo Martin compares this to sports like basketball, where everyone is restricted to a playstyle, but it’s still fun to play/watch). - Doom Eternal aims to keep its players engaged by having challenging enemies and encounters. Frustrating the player is <em>fine</em>, so long as the player does not blame the game.</p>
<p>The multiplayer also looked interesting.<br />
Doom 2016 did have some kind of multiplayer, but it wasn’t popular.<br />
Doom Eternal’s multiplayer is much closer in spirit to its single player. It’s 1v2. One player is the ‘doom slayer’. The other two play as weaker ‘demon’ units and are supported by weak AI demon units.<br />
– Asymmetric multiplayer isn’t a new idea. But I’m not aware of popular games which are single player oriented and have multiplayer which tries to feel like single player</p>
<p>I was hyped for this game, and pre-ordered it.</p>
<h2 id="what-i-thought-of-the-game">What I Thought of the Game</h2>
<p>I enjoyed it.</p>
<p>It’s intense.<br />
I’m not so good, but I still enjoyed it.</p>
<p>The gameplay itself is, uh, complicated.<br />
It builds off of Doom 2016’s gameplay.</p>
<h4 id="recall-doom-2016s-gameplay">Recall Doom 2016’s Gameplay</h4>
<p>Doom 2016’s gameplay seemed quite innovative. It certainly rewarded fast-paced gameplay.<br />
The traditional way of treating a player character’s health in first person shooters was to use health packs. But this can slow down gameplay as a player with low health searches for health pickups if they are low on health. – The ‘modern’ solution to this was to allow regenerating health. This chokes gameplay all over, though. (The game needs to damage the player enough so as to avoid an invincible character. So, the player is constantly waiting to regenerate health).<br />
Doom 2016’s solution was to: allow the player to ‘glory kill’ an enemy with low health in order to get health pickups. – A good way to get more health is to keep on attacking.</p>
<p>Doom 2016 also had: - A chainsaw. You’d find units of fuel on the map. Chainsawing a big enemy would need 3 units of fuel, whereas chainsawing a small enemy would take only 1. Chainsawing an enemy instantly kills it, and drops plenty of ammunition for your weapons. - Grenades. Different types of grenades. You could only have one or two. While there would be grenade ammunition on the map, the game also ‘regenerated’ grenades on a timer, so you wouldn’t run out. - Secrets/unlocks, which gave points for things you could upgrade. You could upgrade a lot: - You could add an attachment to your weapon (e.g. adding mini-missiles to your machine-gun). This attachment could then itself have upgrades (e.g. can fire mini-missiles more quickly). A fully-upgraded attachment could then be ‘mastered’ (e.g. kill enough enemies with it) so then it gets better. - Passive player upgrades. e.g. An upgrade point might give more health. - Passive ability upgrades. e.g. pick up items from further away. - ‘Runes’, which provide a passive ability (e.g. player gets a speed boost after glory killing an enemy). The runes can also be ‘mastered’ so that they get better.</p>
<h4 id="doom-eternals-additions">Doom Eternal’s Additions</h4>
<p>Doom Eternal is mostly more complicated than <em>that</em>.<br />
The one simpler thing is: they combine the passive abilities and upgrades for the player.</p>
<p>It makes sense that the player begins relatively weak, and ends the game with more upgrades. Without that scale, the game would be either too overwhelming or too easy at the start.</p>
<p>Gameplay-wise, the thing that gets more complicated than Doom 2016 is: - The game puts a strong emphasis on enemy weaknesses. You ‘can’ just shoot the enemies without considering this, but it’s <em>much</em> harder to do so. e.g. the giant fat monster with rockets for arms is much easier kill if you shoot off the rockets-launchers on its arms first. - This makes the game much more strategic/tactical to play. - You need to consider what weapons to use at each time; what you have available and what threats you’re facing. - The game really restricts the ammunition the player can carry. - This ‘encourages’ switching between weapons. - This also encourages using the chainsaw on enemies. (The player regenerates a unit of fuel if they have no fuel for the chainsaw). - The player has an ice grenade which they can use to freeze enemies, - The player has a flamethrower attachment. This also regenerates usages like the grenade does. It burns enemies. The burning enemies drop armour pickups for the player as they burn / are damaged. - …And a ‘blood punch’. Which does a large amount of damage in a small area. (It’s also used to take the armour off the armoured giant fat monster). - The game also added a ‘lives system’, allowing the player to respawn with full health if they’re killed. (Otherwise the player respawns from the latest checkpoint). This eases the fights against the most difficult enemies. (This feature can be disabled).</p>
<p>There are more enemies of different types. Probably one or two too many. The different strengths/weaknesses really lend to the need to <strong>think</strong> in order to fight well.</p>
<p>There are also unlocks for ‘cheat codes’ which can be used to replay a mission. (e.g. infinite ammo, semi-‘god mode’, etc.).</p>
<h4 id="controversial-design-decisions">Controversial Design Decisions</h4>
<p>The most controversial enemy (judging by the discussion forums) is the ‘marauder’ enemy.<br />
It’s <em>very</em> tough, even on the easiest difficulty.<br />
The marauder has a shield which blocks all damage. The marauder instantly raises the shield, except during a small timeframe when the marauder is attacking the player at a ‘good’ distance. (If the player is too close to the marauder, the marauder’s attack doesn’t lower its shield. Ditto if the player is too far away).</p>
<p>I think the marauder isn’t inherently tough. It’s easier once you learn the right distance to be, and a good rhythm to attack the marauder with.<br />
But it’s also a significantly harder encounter than other enemies. (It’s the only enemy which presents a threat when you’re using cheats, lol. It’s the only enemy that can’t otherwise just be brute forced even with the super weapons). And it’s a punishing enemy to have to learn how to play.<br />
– I think the game didn’t do enough to ease its way up to this enemy. But it’s also in the spirit of the game’s “play it our way”.</p>
<p>Also controversial: Doom Eternal’s addition of platforming.<br />
I don’t think this was so bad most of the time, but there are a couple of spots where I got stuck not knowing where to go next; even when I’d played the level a few times before.<br />
– I think it’s ‘fine’, though, since: i) if the game were 100% intense the whole time, the intensity would be less dramatic ii) it encourages the player to get a better feel for their platforming ability, which encourages the player to move around the arenas more.</p>
<p>I saw some people also disliked: the game added more cutscenes, and more in-your-face tutorial popups. But it’s easy to disable these, so I don’t see the issue.</p>
]]></summary>
</entry>
<entry>
    <title>Developer Training and Knowledge</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-03-10-developer-training-and-knowledge.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-03-10-developer-training-and-knowledge.html</id>
    <published>2020-03-10T00:00:00Z</published>
    <updated>2020-03-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 10, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>“What are the costs?” ought to be a natural question provided alongside “what are the benefits?”. This doesn’t get asked often enough in the discussions of new tools/technologies.<br />
The costs/benefits implicitly impact discussions since the trade-offs will be different in different situations.<br />
As a developer, I ought to have this in mind when consuming discussions.</p>
<p>To get better as a developer, I ought to increase my experience and skills:<br />
Experience is what I gain from recovering from mistakes.<br />
Skills I have are what I get from learning.<br />
So, online discussions about new tools/technolgies are relevant because they ask: “what skills should programmers have?”, and this is implicitly subject to “how much time/effort should be spent learning?”.</p>
<h3 id="costs-and-benefits">Costs and Benefits</h3>
<p>The universal answer to questions in computing is “it depends”.</p>
<p>Different groups/contexts consider costs and benefits differently.</p>
<p>There are innumerably many factors which can be better or worse between different tools. e.g. speed of development, ease of maintenance, ease of writing, ease of reading, ease of learning, similarity to other tools, compilation/runtime speeds, verbosity, implicit vs explicit, etc.<br />
– These will have different levels if importance to different people.</p>
<p>e.g. Steve Yegge’s <a href="https://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html">Portrait of a n00b</a> discusses that “experts” prefer code to be terse, whereas “n00bs” prefer lots of supporting information around the code itself.<br />
For the n00bs, code has a high cost to read, and so this cost is lowered with comments, metadata, and having less code on the screen. For experts, dense code has a higher signal-to-noise ratio.<br />
In its takeaways, the article suggests that paying the cost of metadata doesn’t necessarily give any benefit; but that e.g. surely the benefit of documentation for public-facing APIs is always worth paying for.<br />
– In <a href="http://archive.is/RalDb">this archive.is snapshot of a Google+ post</a>, Yegge further builds on this idea, with different preferences for ‘liberal’ vs ‘conservative’ programmers. The split is seen as different levels of comfort with the risk of breaking code in production. (“just fix it” vs “high level of confidence in correctness”).</p>
<h5 id="why-learn-and-what-to-learn">Why Learn and What to Learn</h5>
<p>This would be irrelavent if you just stuck with the tools/skills you’ve got and never bother to learn anything new.</p>
<p>The main external reasons to need to learn things are because you need to for school, or because the tools are used where you work.<br />
<em>Maybe</em> you’ll want to study more in the hopes of being more efficient in those roles.</p>
<p>As far as I can tell, though, the main reason to learn outside of that is ‘for fun’.<br />
Geeks argue about all this shit because it’s interesting to.</p>
<p>If you’re not learning some skill because you explicitly have to, or not just because you’re naturally interested in it, then at-best you’re making a bet on getting a higher reward (at some point in the future) than the cost you’re paying to learn.</p>
<p>Though, maybe even then there can be some benefit to that.<br />
e.g. <a href="http://www.paulgraham.com/pypar.html">Python Paradox</a> suggests that it’s lower-risk to try and hire developers who use “comparatively esoteric” programming languages like Python. (This was written in 2004), since the only people who would bother to learn Python are people who find it interesting. (Since you’re not going to get a job writing in Python).</p>
<p>This is also another way of describing <a href="https://mcfunley.com/choose-boring-technology">‘Choose Boring Technology’</a>. (It’s less risky to choose technology with known costs; as a rule of thumb, only use a few ‘new technologies’). The perjoratives “Hype-Driven Development” and “Resume Driven Development” also try and push back against choosing technologies for the benefit without understanding the cost.</p>
<h3 id="forever-learning-and-forever-forgetting">Forever Learning and Forever Forgetting</h3>
<p>Developers tend to take a ‘just in time’ approach to learning for work; taking advantage of ‘monkey-see monkey-do’.<br />
This somewhat changes the interpretation of “forever learning” from “there’s always more to learn, so I’ll be forever learning” to “I’m always working with different software development tools, so I’ll be forever learning”.</p>
<p>Either interpretation of “forever learning” would be fine,<br />
but I’m not sure there’s much adjustment for “forever forgetting”:<br />
In The Atlantic’s <a href="https://www.theatlantic.com/science/archive/2018/01/what-was-this-article-about-again/551603/">Why We Forget Most of the Books We Read</a>, the author mentions a <a href="https://en.wikipedia.org/wiki/Forgetting_curve">“forgetting curve”</a>. The article discusses that tools like the internet provide an ‘external memory’, allow us to get information without having to remember it ourselves. The result is that ‘recall memory’ (“ability to spontaneously call information up in your mind”) is less important than ‘recognition memory’ (remembering where the information is, and how to access it).</p>
<p>This feels like a pretty good model to me.</p>
<p>Maybe this means incremental reading isn’t such a bad idea. (Though it’s certainly not a <em>common</em> idea).</p>
<h5 id="boost-recall-with-spaced-repetition">Boost Recall with Spaced Repetition</h5>
<p>Programmers are familiar the idea of external memory. Search engines lead us to StackOverflow, or GitHub issues.<br />
Often documentation is pretty good, and editors with LSP support can even show this as you type out the code.<br />
Things like compiler errors, editor discoverability, and auto-complete help too.</p>
<p>Recall memory seems a bit more dull.<br />
For the tools/languages which I’m familiar with, there’ll be a lot which I don’t need to lookup. e.g. I can remember how to output text to STDOUT, how to import a package, how to define a function.</p>
<p>I think recall-misses where I need to stop to look things up don’t necessarily interrupt a state of flow.<br />
I think “having to look up documentation for stuff unrelated to the problem domain” is less of a problem than not being able to type. I think effective use of a text editor (like with vi or emacs or kakoune keybindings) is more important than either.<br />
– But, still: Surely it’d be great if I could recall things without spending time time to use a search engine to look for an answer.</p>
<p>To improve recall retention, what you want to recall would either need to be something you frequently use, or something you study.</p>
<p>Anki is ‘Spaced Repetition Software’ (SRS).<br />
It’s a flashcard program, but the intervals between when it tests you on a flashcard increase for each correct recall of that card.<br />
– Most of its users (as far as I can tell) use it for vocabulary studies, or for medical studies. As <a href="https://en.wikipedia.org/wiki/Spaced_repetition">Wikipedia’s page on Spaced Repetition</a> puts it: “spaced repetition is commonly applied in contexts in which a learner must acquire many items and retain them indefinitely in memory”.</p>
<p>This post <a href="http://augmentingcognition.com/ltm.html">“Augmenting Long Term Memory”</a> discusses use of Anki. e.g. to assist in digesting technical papers. (e.g. start with being able to recall surface level facts, then incrementally aim to recall facts which build upon those).<br />
The article also points out some drawbacks. It’s difficult to use Anki to improve recall for things you don’t actually care about. Adding flashcards isn’t (and probably shouldn’t be) low-effort. The article’s rule of thumb is it takes about 7 minutes of study per card per 20 years for a good flashcard (if each review of the card is 8 seconds).<br />
– The article also generally suggests against using Anki to remember APIs in the hope that this would one day be useful. It’s better to first know an API before trying to Ankify things about it. But it’s also a bad idea to keep Anki flashcards that you don’t care about around, e.g. if you aren’t likely to use the API again.</p>
<p>For myself, I’ve used Anki for a year and a half. Studied ~80% of those days. Added around 3900 cards. The vast majority of these cards are for vocabulary.<br />
– I do feel Anki does have a great benefit for the cost put into it. But it’s a bit more effort than “recall for free”.</p>
<h5 id="personal-knowledge-base">Personal Knowledge Base</h5>
<p>I’m beginning to like the idea of using a zettelkasten approach to storing reference.<br />
This seems a more suitable approach between “ankify everything” and “go to the effort of recalling exactly what you came across”.</p>
<p>The important part of zettelkasten notes, as I understand it, is that each note in the system is small, the note hyperlinks to other notes, and the use of tagging helps with random lookup/search of the notes.</p>
<p>In particular, there’s not necessarily a hierarchical structure to the notes. The benefit of this is you don’t have to try to remember where a note was put.</p>
<h3 id="examples">Examples</h3>
<p>Some examples in my mind make a bit more sense with “cost vs benefit”.</p>
<ul>
<li><p>I’m hopeful for elm-lang. It strikes me as (relatively) low-cost to learn to use, and I think this cost is far outweighed by the benefits gained.</p></li>
<li><p>I’m pessimistic about the value of Rust for general purpose software development. In constrast to elm-lang (where elm-lang’s syntax was weird, but the logic was easy to follow): Rust’s syntax is kinda sorta weird, writing something you’ve not done before in Rust can be hard even with some familiarity with the language, and Rust’s USP isn’t a big win in common cases.<br />
Using Rust is surely high-reward in some use cases; but I’m not sure it ever becomes low-cost in most cases.</p></li>
<li>I was fascinated by <a href="https://twitter.com/Jonathan_Blow/status/781597528047230976">the argument in favour of the array-processing programming language K</a> and <a href="https://news.ycombinator.com/item?id=22504106">the HN discussion</a>.
<ul>
<li>What strikes me the most as “using a concise sequence of operators” is to using “FP-ish methods like sum” as those are to “explicit for loop”.
<ul>
<li>The best I can make of it is: you’d have to go and learn what each of the symbols does. There aren’t <em>that</em> many and there’s a big benefit to learning them. And without experience(?) you should’t have the expectation to be able to quickly read K programs.</li>
<li>Which is enough to convince me that the idea of a language like that isn’t completely crazy.</li>
<li>But also that: I don’t think using “FP-ish methods” isn’t too far from developers are used to, or able to read. Whereas seeing <code>q::n 9'a</code> doesn’t really bring <a href="https://kparc.com/edit.k">“syntax coloring”</a> to mind.<br />
(So I could believe taking the time to learn K would be worthwhile, I don’t think anyone should be surprised that not everyone sees the benefits when the costs are so apparent).</li>
</ul></li>
<li>I also found the post’s response to the idea of readability interesting. A symbol operator isn’t necessarily harder to read than a full word. With the word you might think you can guess what it means, but you might be wrong. An operator is going to be precise.
<ul>
<li>There are languages which I’m more familiar with which somewhat take this approach.<br />
e.g. Scala’s <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">List</a> keeps <code>+:</code> (for ‘prepend’) and <code>:+</code> (guess what for?), but deprecates <code>/:</code> and <code>:\</code>.<br />
e.g. Haskell has a few (e.g. see <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/doc-index-All.html">the start and end of base’s index</a>).</li>
<li>Overall, I don’t think it’s absolute that terms are ambiguous or that using only operators would give a more accurate understanding of the program ‘for free’.</li>
</ul></li>
</ul></li>
<li>Category Theory. As I understand it, Category Theory is simple, but not easy. So the cost to studying it isn’t so low. But it’s also kinda hard to see the benefits beyond it being inherently interesting.<br />
It’s neat to see <a href="https://blog.ploeh.dk/2019/12/30/semigroup-resonance-fizzbuzz/">unusual solutions to fizzbuzz like ploeh.dk’s</a>; but the code itself can be understood without category theory. (Well, readable if you can recall what <code>&lt;$&gt;</code> and <code>&lt;&gt;</code> do).
<ul>
<li>FWIW, “simple but not easy” seems like a reasonably fine fit for Anki flashcards.</li>
</ul></li>
<li>Haskell.
<ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a> is really cute. And straightforward.
<ul>
<li>With that I can make simple-ish toy projects and then wish other languages had ADTs and pattern matching and type safety like that.</li>
</ul></li>
<li>e.g. <a href="http://degoes.net/articles/modern-fp">This post using free monads</a> is very cool to read. But I’d also want to go and read about what/how a lens <code>Prism</code> is.</li>
<li>I get the impression that ‘real’ Haskell relies on several more complicated concepts like that. Maybe they’re “simple but not easy” too.
<ul>
<li>e.g. the posts linked from https://www.simplehaskell.org/ are very in-line with what I’m trying to get at.
<ul>
<li>It’s not that using ‘fancy types’ or the academic bleeding edge of what’s possible in Haskell is bad, or impractical. But for many non-Haskell developers, the costs to that kind of style look heavy and it’s not apparent that it’d be better than just writing working code in JavaScript.</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>I think the reason we end up with <a href="https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html">“Command Line Tools can be Faster than your Hadoop Cluster”</a> or <a href="https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim">“Your problem with vim is that you don’t grok vi”</a> is because of a lack of consideration of cost/benefit, which led to mistakenly not taking the time to learn things which would have been better.</p></li>
<li><p><a href="https://pythonspeed.com/articles/dont-need-kubernetes/">pythonspeed’s discussion of kubernetes drawbacks</a> makes it clear that the costs of running kubernetes for a small team outweigh the benefits. I think if the complexity had been communicated alongside the hype, it’s not a technical decision anyone would make.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Early Impression of Elm</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-02-28-early-impression-of-elm-lang.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-02-28-early-impression-of-elm-lang.html</id>
    <published>2020-02-28T00:00:00Z</published>
    <updated>2020-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February 28, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>Recently I wrote some Elm-lang code as part of a casual side-project.</p>
<p>The Elm program was simple, though non-trivial.<br />
The program was a UI for making notes from emails. The Elm program presented a list of emails for the user to select, and let the user CRUD a note for the selected email.</p>
<p>Some changesets: - https://github.com/rgoulter/simple-email-data-tool/pull/1/files Initially adding the Elm program with Travis-CI config, RSpec spec with Capybara, and the Elm program. - https://github.com/rgoulter/simple-email-data-tool/pull/5 Changing from a <code>&lt;select/&gt;</code> to a <code>&lt;table&gt;</code> for one of the widgets. (I was surprised by how easy this change was). - https://github.com/rgoulter/simple-email-data-tool/pull/6/files Adding keybindings to the input. - https://github.com/rgoulter/simple-email-data-tool/pull/8/files Adding date filtering, using a third-party pure-Elm library.</p>
<h3 id="where-im-coming-from">Where I’m Coming From</h3>
<ul>
<li><p>I’d be lying if I said I was very experienced with front-end code. e.g. I can’t think of any big mistakes I’ve made and things I’ve learned from said mistakes. The basics are straightforward; and a deep understanding of front-end web development requires an appreciation for all aspects of how a web browser works, which isn’t easy.</p></li>
<li>On the continuum of ‘liberal programmer’ (“if it breaks, just fix it”; likes Python, Ruby) to ‘conservative programmer’ (wants to know if it works at compile time; likes Haskell) I’m towards the ‘conservative’ end.
<ul>
<li>I’m inclined to like Elm.</li>
</ul></li>
</ul>
<h3 id="what-i-didnt-like-about-elm">What I Didn’t Like About Elm</h3>
<ul>
<li>I was surprised that some things in Elm were (much) harder than they would be in JavaScript.
<ul>
<li>I wasn’t able to figure out how to nicely access the query parameters of the URI. (I ended up getting something which could access the query parameters at a specific path; but I couldn’t figure it out for any arbitrary path). This is an example of “easy in JavaScript, hard in Elm”.
<ul>
<li>While I found this frustrating, I think the Elm-lang documentation makes it clear <em>why</em> it makes this kind of thing ‘hard’.
<ul>
<li>Elm is all about removing footguns. In this case, easy access to the window’s URI query params would introduce impurity; so, to access window’s URI your Elm program also need to ‘manage’ the URI.</li>
</ul></li>
<li>But I would anticipate further “of <em>course</em> that wouldn’t be straightforward in Elm” when considering Elm as a language.</li>
</ul></li>
</ul></li>
<li><p>e.g. I wouldn’t wanna write this blog website’s page with Elm, since the Elm runtime is JavaScript; so if I used Elm then it wouldn’t be accessible to users with JavaScript disabled.</p></li>
<li><p>I still have to look into idioms or idiosyncracies about combining modules together. I’m not sure I ‘get’ it, or if the approach I took was stupid or fine.</p></li>
</ul>
<h3 id="what-i-found-interesting-about-elm">What I Found Interesting About Elm</h3>
<ul>
<li>The Elm Architecture. The restricted nature of Elm’s code means that, while code still doesn’t magically end up well designed, it still ends up being somewhat (or close to) idiomatic.
<ul>
<li>My experience with GUIs other than Elm has been with languages that allow you to more/less update the code’s state from anywhere.</li>
<li>With Elm, you have a ‘model’ Algebraic type, a ‘message’ Algebraic type.
<ul>
<li>Anything the Elm program needs to care about goes in its model.</li>
<li>Any ‘action’ that might happen in the Elm program is represented by a message.</li>
<li>The only place the model gets changes is in its update function.</li>
<li>The only way effects happen is through messages.</li>
</ul></li>
<li>The question becomes “what nouns, what verbs do I want in this system? What is each noun? What does each verb do?”.</li>
</ul></li>
<li>Because of that explicitness and lack of mutation, edge cases (and race conditions) are surfaced.</li>
</ul>
<h3 id="what-i-liked-about-elm">What I Liked About Elm</h3>
<ul>
<li><p>It’s not JavaScript. Programming in JavaScript is .. fine. But I don’t particularly like JavaScript. It feels very blobbish.</p></li>
<li><p>95% of the time it’s a joy to write in Elm. (Most of the time it’s not a joy to write in are the times when you’re trying to do something which would be easy to do in JavaScript. Or with impurity like time/randomness).</p></li>
<li><p>Elm mostly has the “if it compiles it works” aspect to it.</p></li>
<li>Elm programs/modules are self contained and small.
<ul>
<li>Everything you need in a module must be explicitly imported.</li>
<li>The lack of mutation means things are much more explicit.</li>
</ul></li>
<li><p>Elm’s record syntax is nicer than Haskell’s.</p></li>
</ul>
<h3 id="my-development-experience">My Development Experience</h3>
<ul>
<li><p>I mocked the API that my Elm program would call with simple Ruby’s Sinatra servers.</p></li>
<li><p>I wrote RSpec specs which would compile the Elm program before running Selenium tests against the Elm program.</p></li>
<li><p>My program wasn’t sophisticated enough to need much development work on components individually. But I did find it easy enough to use “elm reactor” (compiles + serves the Elm source) to focus on one component at a time.</p></li>
<li>I developed my Elm program using Emacs. The most popular elm-mode gave me syntax highlighting. I didn’t feel the need to make use of elm-mode’s other IDE features.
<ul>
<li>For code completion: I developed my Elm program on Windows. There’s an Elm language server. Unfortunately, I think because Windows is slow at launching processes, I found it was too slow for me to use with Emacs on Windows.</li>
</ul></li>
<li><p>I didn’t make good use of it, but there is support in universal-ctags.</p></li>
</ul>
<h3 id="would-i-use-it">Would I Use It?</h3>
<p>After having used it for a side-project, without the burden of needing to ship something reliable by some deadline:</p>
<p>Yes, I’m quite happy with the experience.</p>
<p>Obivously I’m interested in liking it, though; and this wasn’t a high-risk project, so:<br />
What situations/cases would I not recommend using it for?<br />
- Projects which benefit from a rapid prototyping/delivery (e.g. code maintainability/quality can be traded off) by an experienced team which lacks any experience Elm. - Projects which already show evidence of some kind of a “lava flow” antipattern, or projects where using Elm is likely to lead (or contribute) to an anti-pattern like this. - Projects where Elm is chosen without consideration for <a href="https://mcfunley.com/choose-boring-technology">‘Choose Boring Technology’</a>. - If I were given responsibility to maintain some front-end application code which was poorly written in JavaScript using ReactJS: - While it’s possible to interop Elm and JavaScript, I think the complexity of the same maintainers mixing the code would outweigh benefits of using Elm. - etc.</p>
<p>I think websites would be better maintained if they were developed with the discipline that Elm does a lot to help.</p>
]]></summary>
</entry>
<entry>
    <title>On Agile</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2020-01-25-on-agile.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2020-01-25-on-agile.html</id>
    <published>2020-01-25T00:00:00Z</published>
    <updated>2020-01-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 25, 2020
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>“Agile”, “Scrum” and “Kanban” all get a rather bad reputation among developers on the internet. They seem to work well for <em>some</em> teams, but for others these are <a href="https://media.defense.gov/2018/Oct/09/2002049591/-1/-1/0/DIB_DETECTING_AGILE_BS_2018.10.05.PDF">“waterfall or spiral development in agile clothing”</a>.</p>
<p>At worst, teams take tasks off a todo list however they would anyway and call it ‘agile’.</p>
<p>At best, maybe the differences can be explained as “‘agile’ works well for some kinds of development work; but not well for others” (I’m not convinced by this as-such) or “‘agile’ works well for good teams. For good teams, anything would work well”. (Which wouldn’t mean ‘agile’ is useless; so much as, it’s not a silver bullet).</p>
<p>But <em>part</em> of the disagreement, I think, comes from the ol’ “people using the same words to refer to different things”. Especially people with different understandings, let alone experiences.</p>
<p>I’d come across the terms ‘kanban’ and ‘kanban board’ for years before I picked up a book which discussed kanban. I was surprised to see the idea of a kanban board was related to principles: visualize the workflow, limit work in progress.<br />
“Either a worker is idle or a task is idle”. The idea is to maximise ‘flow’ of tasks. Limiting work in progress and visualizing it on a board ought to help identify bottlenecks, which can be addressed.</p>
<p>Beyond that, there are all sorts of details as to tactics and techniques for implementing this. But the basic idea sounds ‘obvious’ and intuitive and, for some workflows, a good idea.</p>
<p>I, uh, don’t know if a ‘kanban board’ can properly be called a ‘kanban board’ if these principles aren’t followed. I suspect places which just use the column-of-tasks aren’t likely to follow “limit WIP”. But I suspect most places which don’t follow “limit WIP” are still happy to say they “do kanban” and are agile.</p>
<p>In any case, it seems unprofessional that so many development teams would be using ‘kanban’ or ‘scrum’ but without following (or knowing) the key ideas. I think this is because agile <em>sounds</em> hip.</p>
<hr />
<p>Being surprised about ‘kanban’, I’ve decided to read up on ‘scrum’. (The one with ‘sprints’ and stuff).</p>
<p>At a glance, it seems to have the same “oh <em>that</em> makes sense” as kanban, as <em>well</em> as “…because of these underlying values”.</p>
<p>But the book I was reading pointed out: <em>of course</em> if the team doesn’t have psychological safety / trust / respect for each other, then ‘scrum’ isn’t going to work.</p>
<p>I’d guess there’s still value in following a process in order to try and surface problems. But surely a political and unsafe team isn’t going to identify or address problems easily.</p>
<p>I think, then, the hype over ‘agile’ is a bit misplaced.<br />
Not because the ideas around it are worthless so much as the heavy-lifting of effective teams seems to be the psychological safety aspect.<br />
From there, I think the ‘agile’ ideas make sense for a reasonably wide variety of work. (I imagine obstacles like: e.g. a focus on small improvements may obscure long-term strategic mistakes).</p>
]]></summary>
</entry>
<entry>
    <title>On the 2019 UK Election Results</title>
    <link href="http://www.rgoulter.com/blog//posts/politics/2019-12-14-on-2019-election-results.html" />
    <id>http://www.rgoulter.com/blog//posts/politics/2019-12-14-on-2019-election-results.html</id>
    <published>2019-12-14T00:00:00Z</published>
    <updated>2019-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December 14, 2019
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>I found these two comments interesting: 1. Twitter Thread https://twitter.com/LukePagarani/status/1205487970897342464?s=20 What I get from this is: The perspective is a leftist voter discussing that people he met didn’t value the same things that Labour/Corbyn did. Such voters valued their national identity, and so really didn’t like Corbyn. 2. Quillette post https://quillette.com/2019/12/13/britains-labour-party-got-woke-and-now-its-broke/</p>
<p>I find it interesting that these two comments more/less agree on many things. – I think they look at “people don’t like Corbyn because they love their country” differently, but that makes how much narrative they share that much more interesting to me.<br />
(Bonus: compare the above Tweeter’s RT of this with the quotes from the article: https://twitter.com/SoysalOzlu/status/1205526147288707074?s=20)</p>
<p>I think the two comments also highlight the way the different moral foundations (of Moral Foundation Theory) are emphasised. “Britain should take care of British people first/foremost” vs “all people are equal” rings true for loyalty and fairness moral foundations respectively.</p>
<p>I remember seeing a comment I saw discussing that the Brexit vote is best justified in terms of a question of identity. (If it were about immigration or economics or whatever, then there would be other more effective measures to reach these ends).</p>
<p>It reminds me of <a href="https://www.youtube.com/watch?v=LJKXJNM3W-c">Stephen Fry at the Munk Debates</a> (at around 4:30) saying that he’s concerned “the greatest human failings is to prefer to be right, than to be effective”. – I don’t interpret this to mean that he’d prefer to be effective at what’s not-right. I interpret this as saying that it’s wrong to focus on symbolic value over more effective results.</p>
<p><a href="https://meaningness.com/metablog/virtue-court">Meaningness’ Court of Values and Bureau of Boringness</a> is a fun play on the problem this can present. The problem is, much of politics today is performance towards showing the right virtues; this distracts or counteracts ‘boring’ solutions to problems. – One (dumb, but fun) suggestion is to allow people one vote towards either a ‘boring’ serious court, or towards a mostly-powerless court which decides what values people should be rewarded/punished for showing.</p>
<p>I see concerns on Twitter about how awful the implications of this result are. (My impression is that these come from the same group as “it’s racist to vote for the options I don’t like”, which isn’t persuasive). I’m also under the impression that these worries still wouldn’t be enough to sway voters! As in, the symbolic value of “our national identity” apparently matters a lot!<br />
– I think the flipside is the same point, though. My understanding is Labour’s absymal result in these elections is the best they could do in the situation. But: if it is the case that the winners won the vote because of a symbolic policy: surely it would be reasonable to appeal to the voters’ symbolic values to support your cause?</p>
<p>It’s probably a bit too much of a simplification, but it’s still tempting to match “voted for Brexit, despite probable material harm” and “won’t say ‘my country is great’, despite likely losing for that” as matching “would rather be right than effective”.</p>
]]></summary>
</entry>
<entry>
    <title>First Impressions of Halo Reach</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2019-12-05-first-impressions-of-halo-reach.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2019-12-05-first-impressions-of-halo-reach.html</id>
    <published>2019-12-05T00:00:00Z</published>
    <updated>2019-12-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December  5, 2019
    
        by richardgoulter
    <br/>
    
    Tags: 
    
</div>

<p>So the Halo Master Chief Collection made its debut on Steam with Halo Reach.</p>
<p>This seems to be in line with Microsoft making money based on the brands they’ve built up before. e.g. They’ve re-released Age of Empires II in an “HD Edition”; and recently re-released Age of Empires II in a “Definitive Edition”. (That said, in addition to graphical and quality of life enhancements, the games also included new game content). Similarly, Age of Empires 1 saw a “Definitive Edition” re-release; although this was initially only through the Microsoft Store. (Also “not just on the Microsoft Store”: the Halo mobile games (Spartan Assault/Spartan Strike) and a Definitive Edition of Halo Wars; although Halo Wars 2 remains only on the Microsoft Store). Age of Mythology had also seen an “Extended Edition” (although the new civ wasn’t very good), and Age of Empires III will receive a Definitive Edition, too.<br />
(Age of Empires: Online being forgotten, apparently).</p>
<p>I did play Halo 1 on the PC way back when.<br />
Just the single-player game.<br />
But the times I’ve touched Halo since then was with its Spartan Assault and Spartan Strike. These are twin-stick shooters; so in terms of “when were we gonna get Halo on PC?”, they “didn’t really count”.</p>
<p>Having played through most of the Halo Reach on PC, I get the impression that the Spartan Assault/Strike give off a fairly good emulation of what Halo gameplay is going for. – There seems to be an emphasis on challenge-based or score-based completion.</p>
<p>See, uh.<br />
Halo is cool. It’s a militaristic sci-fi shooter. (Halo’s impact so pronounced that it defined the new-school only-two-weapons-at-a-time, cinematic shooters).<br />
Other sci-fi shooters aspire to be Halo the same way that fantasy fiction aspires to be Lord of the Rings.</p>
<p>But, I’m not sold on the base gameplay itself. Or maybe I was spoiled by Titanfall 2. <a href="https://www.youtube.com/watch?v=L5uaeT_5HpQ">This outstanding review by Shammy sold me on it</a>.</p>
<p>Halo Reach’s story is just unengaging.<br />
Maybe it wants to be Call of Duty. Everything is big and exploding and swinging from roaring success to absymal failure and the player really has no agency over this or any sense of scope. It’s kinda hard to care. (But maybe that’s ’cause it’s not the first game in the series and there’s story in the other ones and stuff).</p>
<p>The gameplay is more appealing.<br />
I’m not too familiar with the rules or the game logic. The human guns are good at killing unshielded enemies, and the alien guns are good at taking down shields. You have a shield, so you either gotta kill fast, or hide behind cover. The game can be pretty patient with you, which really emphasises the “ludo-narrative dissonance” where the story is saying it’s the end of the world, but the game isn’t advancing while there’s one weak enemy unit running around waiting to be killed. – It kinda feels sluggish to use just the human weapons to kill the enemies, but on normal difficulty the game lets you do it. (Whereas, seems like Bioshock 1 really emphasised its paradigm-shift of ‘zap them then hit them’).</p>
<p>I think where the game is fun to play (at a casual level of “on normal difficulty, not interested in score”) the challenges setup in the arena. Some of the time the enemies are easy to kill with weak weapons. Sometimes the enemies are harder to kill, with weapons or abilities to kill you in one or two hits. Sometimes there are enemy vehicles you can hijack.</p>
<p>I tried playing the controller-centric game with a controller at first. I lasted about five minutes before deciding that keyboard and mouse was just that much more comfortable.</p>
<hr />
<p>Having finished the game, I’d add:<br />
The levels are quite distinctive.</p>
<p>I think the story is more interesting if it’s spoiled going in.<br />
It’s apparently going for the same kindof plot what Star Wars’ Rogue One is going for: all the heroes die in the story, but after they manage to get the McGuffin that is humanity’s last hope to the remaining good guys. Rogue One ends by passing the Death Star plans to Princess Leia, blending into the Star Wars movie. Halo Reach ends with where the first Halo game starts.</p>
<p>I want to like this game. I can chalk my disliking it up to me being bad at it. But, from here I don’t quite get why people like the Halo series so much.</p>
<p>I wonder if remakes like this justify better engineering effort. It makes sense for the first release of a game to have an extreme “just get it done” mentality where maintainability isn’t a consideration. But for content with strong cultural cachet which can be milked for money by improving graphics every few years, surely it’s more viable to invest in maintainability.</p>
]]></summary>
</entry>
<entry>
    <title>Consumption Driven Organising</title>
    <link href="http://www.rgoulter.com/blog//posts/2019-11-17-consumption-driven-organising.html" />
    <id>http://www.rgoulter.com/blog//posts/2019-11-17-consumption-driven-organising.html</id>
    <published>2019-11-17T00:00:00Z</published>
    <updated>2019-11-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on November 17, 2019
    
        by Richard Goulter
    <br/>
    
    Tags: 
    
</div>

<p>I’ve been meaning to try and write down some things about the way I organise things.</p>
<p>I’m still improving, trying to keep the stuff that ‘works’ and ditch the stuff which I’m not consuming.</p>
<p>Anki: I’ve been using Anki for learning Vietnamese vocabulary. Yeah, one tip is to use it on a smartphone; that really reduces friction for revising the sets. I still don’t manage to do it quite every day, but this is almost a metric of how mentally rested I am. (If I’m too stressed or tired, then I won’t be doing my Anki).<br />
What I wish I knew: I find it’s still a bit easy to ‘game’ by remembering it within the first day, but forgetting it after that. (Anki cards start out in a “learning” state where you’re not expected to recall the note. Once a card is learned, not-recalling is bad). So, I adjusted the learning interval. Downside: it can take a long time to ‘learn’ the card, but my impression is that things which do get learned are more solid.<br />
I’d also recommend: feel free to just ‘reset progress’ of cards you get wrong if you have too many cards to revise.<br />
– One ‘motivational technique’ for going through the Anki stuff is: “revise cards until you get one wrong”. (I find, even if I’m tired out of my ass, that I can go for surprisingly long before getting one wrong. But then you’re almost in a flow and you’re fine with “just doing one more”).</p>
<p>Work notes and stuff: I still like using five colours, especially for worklog stuff.</p>
<ul>
<li>I don’t particularly value the notes for a long time; but it’s useful to get concerns, questions, plans, notes out of my head. (So maybe I could use that kickstarter book which works with the Pilot Frixion pens for my work).</li>
<li>What I like doing: using one ‘book’ as kindof a personal sprint / kanban planner; and work notes on refill paper separately.
<ul>
<li>Each sprint, I write up a table of tasks, with columns for each day of the sprint. Kindof like a done-list / Gantt chart kindof thing. (This helps visualise if tasks are taking too long; as well as visualise progress made).</li>
<li>Aside from the table, I’d rule sections for each day. In each section writing down: what I plan to do that day; then at the end of the day: what I did, and what ‘obstacles’ I faced. The “what I did” should contain no negative qualifiers. e.g. “I struggled through X” is worse than “I did X”.</li>
<li>Ideally start each sprint on a fresh page; ideally, each sprint/week covers a double-page spread.</li>
</ul></li>
<li>For work notes:
<ul>
<li>While I don’t really like keeping notes for a long time, I like the notation of using a box for ‘task to be done’. (Then loosely: ‘//’ for “done”, ‘/’ for “enough”, ‘X’ for “not gonna do it”, ‘&gt;’ for “task rewritten later”, etc.).
<ul>
<li>Write boxes like this on the margin. So then it’s super quick/easy to see what ‘tasks’ might need to be addressed. (You could even follow a discipline of rewriting tasks each new page / day).</li>
<li>Margins can also be used to timestamp; e.g. ‘<span class="citation" data-cites="1030h">@1030h</span>’.</li>
</ul></li>
</ul></li>
</ul>
<p>org-mode: It’s still my go-to place for organising stuff. - Tasks in org-mode; org-agenda: I’ve been pretty sloppy about this. I like the rules of thumb: “if it’s right, it will work effortlessly”, “tasks need to be well-organised, reference/notes don’t”. (“capture notes/inputs in as few places as possible” is also nice). - Tasks and Agenda: maybe I need to better organise the ‘TODOs’/tasks. Or maybe the right kinds of tasks for the right times/places. But I’m not really making use of it. - Checklists: one nice use of org-mode is it can be easy to copy-paste a checklist. I found this was useful for me for the start of the day, it would control the distraction of things I needed to do. - Reference: I’ve heard “zettelkasten” is to ‘reference’ what “getting things done” is to TODO lists. AFAIU, ‘zettelkasten’ is about keeping atomically-small reference notes, and linking between the different cards. I think one effect of trying things this way is to make it much easier to use/read the zettels when writing a zettel. I’ve started trying this with org-mode.</p>
<p>A thought which comes to mind is that: this organising is an attempt to save time, hopefully in a way that spending time early saves time later. For a lot of computer / developer stuff, the baseline for how long it takes to find is “google search it”. My experience is: if I’ve googled it before, then I can kinda remember what I searched for and navigate the results better. The best ‘cache hit’ is, from experience, remembering/knowing it.<br />
Anki tries to facilitate the remembering/knowing it. The best criticisms I’ve seen are that: it’s not that Anki doesn’t work, but is it worth doing? If you would benefit from knowing it, you would encounter the stuff frequently enough anyway. (I think this is why med students and language learners benefit. With languages, you don’t know “You Ain’t Gonna Need It” for low-frequency words).</p>
]]></summary>
</entry>

</feed>
