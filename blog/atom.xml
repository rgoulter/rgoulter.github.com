<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Richard Goulter's Blog</title>
    <link href="http://www.rgoulter.com/blog//atom.xml" rel="self" />
    <link href="http://www.rgoulter.com/blog/" />
    <id>http://www.rgoulter.com/blog//atom.xml</id>
    <author>
        <name>Richard Goulter</name>
        
        <email>richard.goulter+blog@gmail.com</email>
        
    </author>
    <updated>2024-04-09T00:00:00Z</updated>
    <entry>
    <title>Using Terraform to Manage an Object Stored in OpenStack Swift</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2024-04-09-using-terraform-to-manage-an-object-stored-in-openstack-swift.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2024-04-09-using-terraform-to-manage-an-object-stored-in-openstack-swift.html</id>
    <published>2024-04-09T00:00:00Z</published>
    <updated>2024-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="technologies">Technologies</h2>
<p><a href="https://www.openstack.org/">OpenStack</a> is a set of software that infrastructure providers can use to give users a user-experience similar to that of AWS or other cloud providers. e.g. <a href="https://cleura.com/">Cleura</a> provides a public cloud service which can be managed with OpenStack APIs. – I think the idea for OpenStack was to enable infrastructure providers to serve as a substitute for AWS.. albeit, even amongst OpenStack public clouds, there remain idiosyncracies such that a deployment in one OpenStack cloud might require effort to deploy to another OpenStack cloud.</p>
<p><a href="https://docs.openstack.org/swift/latest/">OpenStack’s Swift</a> is an ‘object storage’ service. More/less the same thing as AWS’ S3 (or Google Cloud’s cloud storage).</p>
<p><a href="https://www.terraform.io/">Terraform</a>, or its open source fork <a href="https://opentofu.org/">OpenTofu</a>, is a tool for managing declarations of cloud resources. There’s a <a href="https://registry.terraform.io/providers/terraform-provider-openstack/openstack/latest/docs">Terraform Provider for OpenStack</a>, so that Terraform can be used to work with OpenStack resources.</p>
<h2 id="task">Task</h2>
<p>Here are notes on using Terraform to manage an object in a ‘container’ on OpenStack Swift (‘bucket’ in AWS terms), and to create a (temporary) URL to access that object.</p>
<p>The main advantage of this approach is reyling on Terraform to manage the setup/teardown, as opposed to having to use the web console to manage this, or use the CLI client to manage these. I prefer being able to run <code>terraform apply</code> to ensure things are there; and <code>terraform destroy</code> to ensure things are gone.</p>
<h2 id="terraform-code-for-container-and-bucket">Terraform Code for Container and Bucket</h2>
<p>Some boilerplate, using the openstack provider for Terraform:</p>
<pre class="terraform"><code>terraform {
  required_version = &quot;&gt;= 0.14.0&quot;
  required_providers {
    openstack = {
      source  = &quot;terraform-provider-openstack/openstack&quot;
      version = &quot;~&gt; 1.49.0&quot;
    }
  }
}</code></pre>
<p>As the provider documentation mentions, the Terraform OpenStack provider can pick up authentication credentials from <code>OS_</code> environment variables. I used the Cleura public OpenStack cloud, and downloaded an ‘rc’ file with the credentials for an OpenStack user to use with a project there.</p>
<p>Then the Terraform code for creating a container <code>rgoulter-storage</code>, and an object named <code>test</code> in that container:</p>
<pre class="terraform"><code>resource &quot;openstack_objectstorage_container_v1&quot; &quot;self&quot; {
  name = &quot;rgoulter-storage&quot;
  metadata = {
    Temp-URL-Key = &quot;some-secret-value&quot;
  }
}

resource &quot;openstack_objectstorage_object_v1&quot; &quot;self&quot; {
  container_name = openstack_objectstorage_container_v1.self.name
  name           = &quot;test&quot;
  content        = &quot;Hello, world!&quot;
}</code></pre>
<p>Resources are named <code>self</code> out of convention. (There aren’t multiple containers, objects in this Terraform codebase).</p>
<p>In this case, the content of the object is set with the <code>content</code> attribute to the object resource. The <code>source</code> attribute is more suitable when you want some file to be uploaded. (c.f. <a href="https://registry.terraform.io/providers/terraform-provider-openstack/openstack/latest/docs/resources/objectstorage_object_v1">the terraform provider documentation</a>).</p>
<p><code>Temp-URL-Key</code> is set on the container’s metadata to allow creating temporary URLs to provide access. (c.f. <a href="https://docs.openstack.org/swift/latest/api/temporary_url_middleware.html">Swift’s temporary url middleware documentation</a>). – This value should be kept secret; this value is used to create temporary URLs to access objects in the container.</p>
<h2 id="creating-temporary-urls-with-terraform">Creating Temporary URLs: with Terraform</h2>
<pre class="terraform"><code>resource &quot;openstack_objectstorage_tempurl_v1&quot; &quot;self&quot; {
  container  = openstack_objectstorage_container_v1.self.name
  object     = openstack_objectstorage_object_v1.self.name
  method     = &quot;get&quot;
  ttl        = 900
  regenerate = true
}

output &quot;tempurl&quot; {
  value     = openstack_objectstorage_tempurl_v1.self.url
  sensitive = true
}</code></pre>
<p>It’s possible to also use the Terraform OpenStack provider to manage tempurls.</p>
<p>On the one hand, you might as well, if you’re using Terraform for the other parts.
On the other hand, I think it smells a bit too much to ‘declare’ the existance of a tempurl with a time-to-live of 900 seconds.</p>
<p>One nice thing about this approach is the output URL value is simple/easy to figure out. i.e. running <code>terraform output -raw tempurl</code> outputs something like:</p>
<pre><code>https://swift-fra1.citycloud.com:8080/swift/v1/AUTH_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/rgoulter-storage/test?temp_url_sig=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&amp;temp_url_expires=1999999999</code></pre>
<h2 id="creating-temporary-urls-with-command-line-client">Creating Temporary URLs: with Command Line Client</h2>
<p>The <a href="https://docs.openstack.org/swift/latest/api/temporary_url_middleware.html">documentation about temporary url middleware</a> gives instructions on using the OpenStack Swift client to create a temporary URL.</p>
<p>There are various ways to come up with the OpenStack Storage URL (<code>https://swift-cluster.example.com/v1/my_account/</code>), but here’s what I came up with for the container, object, and temp URL key above:</p>
<pre class="sh"><code>OS_STORAGE_URL=$(openstack catalog show object-store --format=json | jq -r .endpoints[2].url)
swift tempurl --digest=sha1 GET 900 ${OS_STORAGE_URL}/rgoulter-storage/test some-secret-value</code></pre>
<p>The <code>jq</code> expression isn’t the cleanest. (The <code>[2]</code> is the index the “public” object-store endpoint happened to be in the output of <code>openstack catalog show object-store</code>; albeit, all the endpoints had the same URL).</p>
<p>The URL from <code>swift tempurl</code> can be used for GET requests to access the storage.</p>]]></summary>
</entry>
<entry>
    <title>Six Months of Going to the Gym</title>
    <link href="http://www.rgoulter.com/blog//posts/2024-03-23-six-months-of-going-to-the-gym.html" />
    <id>http://www.rgoulter.com/blog//posts/2024-03-23-six-months-of-going-to-the-gym.html</id>
    <published>2024-03-23T00:00:00Z</published>
    <updated>2024-03-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been going to the gym consistently for the last six months or so.</p>
<p>Some thoughts:</p>
<h2 id="goals">Goals</h2>
<p>I started going to the gym to improve my health; especially to lose fat.</p>
<p>Alongside going to the gym, I’ve restricted the amount of soft drink I drink, &amp; limited the amount of fried food I eat.<br />
Those changes alone had a significant impact on the progress I made.<br />
– “Restriction” is an unhappy word. Perhaps “control” would be better. By my estimate, the effort it’d take to burn the calories from soft drinks far outweighs the reward from drinking them.</p>
<p>The gym I attend has a fancy bioelectrical impedance analysis machine. This helps assess body composition; i.e. can be used to measure weight, muscle mass (sorta), and fat. – This makes it easier to track “fat loss” as a target, as distinct from “weight loss”. Without that distinction, building muscle (as a gym beginner) somewhat confounds the goal of losing weight; since it’s good to build muscle, but building muscle increases weight. (Although, sure, it’s easier to burn fat with a calorie deficit, and to build muscle with a calorie surplus[1]).</p>
<p>I also recently started keeping a workout journal. It’s easy enough to keep track of progress when using a treadmill (e.g. “Last week I ran 5km. This week I ran 5.2km. Improvement!”). But, I found it difficult to keep track of progress when using weight machines (&amp; weights). I wanted to write down what I’d done, so then I’d have a reference point to compare against for the next session.</p>
<p>In terms of progress?<br />
Shorts which used to tightly hug my bum will now fall off if I don’t wear a belt.<br />
My chess rating has improved online, which I mainly attribute to improved physical fitness.</p>
<h2 id="start-small-then-work-up">Start Small then Work Up</h2>
<p>When I first started going to the gym, I would go two or three times each week. Starting out, I focused exclusively on using the treadmill.</p>
<p>Since starting out, I’ve increased the pace at which I run at, and increased the amount of time I run for.</p>
<p>After developing that to a level I was happy with, I was then able to use the days between running to do whatever else at the gym.</p>
<h2 id="regarding-initial-anxiety-and-such">Regarding Initial Anxiety and Such</h2>
<p>I certainly felt anxious about going to the gym when I started going. I think pretty much everyone feels that way.</p>
<p>I think what I was initially most anxious about was looking silly.. or feeling like some kind of imposter that didn’t belong at the gym.</p>
<p>Part of that was surely thinking “oh, I don’t know what exercises to do; I don’t know how to use the weights or machines”.<br />
There are ways to figure these things out, though.<br />
For one.. since my goal has been ‘fat loss’, it wasn’t so bad to just focus on using the treadmill. For another, the weight machines at the gym are beginner friendly. There are plenty of videos on YouTube which demonstrate how each machine is used. – Though, I’ve seen some pretty compelling arguments that beginners should also make use of free weights.</p>
<p>I think part of gym anxiety is fear of being judged.<br />
Some people who go to the gym are fitter than others; it’d be silly (and rude) for the fitter people to judge others for being less fit at the gym, since by exercising at the gym is a reasonable way to improve fitness.<br />
But, really I can take pride in putting in the effort to show up to the gym, and make each workout a good one that made progress towards my goals. (It takes a long time to lose a bunch of weight; it’s much quicker to change how many times you go to the gym. It’s easier to hit the target of “go to the gym twice a week” and improve that to “three times a week” than it is to hit the target “lose 10kg of fat”).</p>
<p>People do look at what other people are doing in the gym.<br />
Partly this is comparison.<br />
But another reason is curiousity. I know that I’ll want to see what others are doing.<br />
– I reckon not everyone knows everything. I often see the damper on the rowing machines set to a 10. I’m inclined to believe people set it to a 10 thinking “intense workout”, rather than “slow boat”[2].<br />
– The gym I go to has a SkiErg machine. In my months of attending the gym, I hadn’t seen anyone use it. (Although after I used it, I saw PTs advise gym-goers to use it, where the Personal Trainer’s technique diverged unusually/weirdly from the recommended technique[3]).</p>
<p>It varies from gym to gym, but my experience has been that the Personal Trainers are typically unpleasant to interact with. Ideally, PTs would be knowledgeable, friendly, supportive and encouraging. Somehow, commission-based incentives don’t necessarily lead to this. – I mean, dealing with these PTs is an unpleasant part of gym going.</p>
<p>Positively: If you go to the gym routinely, you’ll recognise other people who follow an overlapping routine.</p>
<h2 id="going-to-the-gym-can-be-fun">Going to the Gym Can be Fun</h2>
<p>I became a gym member in order to improve my health, not for the fun of it. And I’m not always excited to go to the gym, and the gym isn’t always fun. Sure.<br />
But I do think it’s kind of a shame that exercise is thought of as a burdensome chore, rather than something fun.</p>
<p>I reckon in the same way that a dog likes going to the park, your body ought to appreciate the chance to exercise.</p>
<p>For losing fat.. I think running at a high intensity for a long period of time is fun. I do get that “runner’s high”.<br />
Some other things help:<br />
While running, I listen to music. I use the Aftershokz headphones, they’re great, and well suited to exercise. (They don’t cover up the ears). – It’s <em>very</em> fun to listen to an upbeat song, and to be running at high speed to that song.<br />
For endurance activities, part of what I find fun is demonstrating a consistent, high level of effort. <em>Of course</em> it’s boring to finish if a run is too easy. And giving up before the end is also not <em>fun</em>. But enduring to the point where you want to give up while still finishing is relieving.</p>
<p>Some of the exercises that gym equipment allows can be pretty fun:</p>
<p>The gym I go to has a ‘curved motorless treadmill’.<br />
This is kinda like a hamster wheel, but for humans.<br />
Since the machine’s tread goes as fast as you go, it allows you to speed up or slow down as you like. This is friendlier than on a motorised treadmill, which maintains whatever pace you set it, and so has very limited allowance for running slower (or faster) than that pace. It also provides instant feedback as to what pace you’re running. This makes it easy enough to try and keep to a certain pace. And, same as a motorised treadmill, you don’t have to worry about traffic or other obstacles.<br />
By letting you run at whatever speed, this helps you get familiar with what running faster feels like, and is a friendlier way for feeling whether you can maintain a certain pace for some time.</p>
<p>I also enjoy using the rowing machine.<br />
At the gym I go to, the rowing machines are often unused. I think that’s a shame, since it’s a versatile piece of equipment: it can be useful for burning calories, or for building strength. Compared to the treadmill, a rowing machine will exercise more of the body (legs, core muscles, and arms); and unlike running, it’s low-impact. Compared to most weight machines, it engages a variety of muscles. Compared to free weights, it’s friendlier for beginners.<br />
I recently found out there are metronome apps for rowing that give useful cues for stroke rate. These make it much easier to do a workout which aims for maintaining a stroke rate for some period of time.</p>
<p>I recently started attending BodyPump group sessions.<br />
I’ve found these to be pretty fun. It’s a good way of getting a good workout in a good amount of time. This is also a neat way to get familiar with free weights and some free weight exercises.</p>
<h2 id="using-chatgpt-for-learning-basic-things">Using ChatGPT for Learning Basic Things</h2>
<p>In addition to seeing demonstations in YouTube videos, I found it useful to ask ChatGPT about fitness things.<br />
Of course, ChatGPT isn’t completely reliable; but.. it’s probably not worse than the blogposts that come up in search engine results (and not worse than a bad PT).
Perhaps it’s comparable to what people say about Wikipedia: you ought to not rely too heavily on it, but it makes for a good starting point.</p>
<p>One of the main faults (or ‘characteristics’?) with ChatGPT is these chatbots are decidedly unopinionated. – I mostly find this preferable over being told an unqualified opinion.<br />
Similarly, the public chat-based LLMs are <em>pathologically</em> positive.<br />
– Whereas, when reading articles or blogposts or watching videos, often these will include strong opinions that you have to evaluate.</p>
<p>Another limitation is as the topic of discussion gets more precise, ChatGPT tends to be less useful.</p>
<h2 id="footnotes">Footnotes</h2>
<p>[1] <a href="https://www.youtube.com/watch?v=8QpjX2K-JY0">Dr. Mike Israetel’s discussion about ‘losing fat while building muscle’</a> seems coherent to me.</p>
<p>[2] <a href="https://www.concept2.com/indoor-rowers/training/tips-and-general-info/damper-setting-101" class="uri">https://www.concept2.com/indoor-rowers/training/tips-and-general-info/damper-setting-101</a></p>
<p>[3] <a href="https://www.youtube.com/watch?v=B0lIgT5PHc8">Concept2’s SkiErg technique demonstration</a></p>]]></summary>
</entry>
<entry>
    <title>Another Factorio Post-Game Ramble</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2024-02-14-another-factorio-post-game-ramble.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2024-02-14-another-factorio-post-game-ramble.html</id>
    <published>2024-02-14T00:00:00Z</published>
    <updated>2024-02-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Factorio is such an enthralling game to play.</p>
<p>If you’ve somehow found this post but don’t know Factorio:
It’s a 2D game which starts out similar to many ‘survival’ games (e.g. you chop wood, mine stone and iron, etc.), but progressively build up ways to automate these tasks away. The eventual goal is to build and launch a rocket; although many players find fun in seeing how big a factory they can build.<br />
Ultimately, the whole ‘challenge’ of Factorio is finding a way to arrange the factory so that all the inputs can get to the right places.. so it’s encouraged to do a first playthrough ‘blind’.</p>
<p>I had been meaning to play some other games on my Nintendo Switch, but after starting a new Factorio playthrough, ended up spending a lot of time on that.</p>
<p>This time, I played on a “ribbon world”. I also set the resource patches to be more frequent and richer (although didn’t change them to be bigger than normal). I decided to play on non-peaceful; but, disabled enemy expansion.</p>
<p>“Ribbon world” limits the height of the map. – This adds some challenge to laying out the base. e.g. the limited vertical space constrains how ‘vertical’ any part of the factory can be; whereas horizontal space has to be cleared (especially on non-peaceful, where enemies have to be cleared), and inputs will end up <em>really far</em> from where they need to be.<br />
On the flipside, the limited height makes defending from the enemies trivial: the enemies can only come from the left or the right, so you only need to worry about defending a tiny perimeter to the left and to the right.</p>
<h2 id="compared-to-previous-playthroughs">Compared to Previous Playthroughs</h2>
<p>On my previous Factorio runs: I mostly stuck to peaceful, and have tried out different strategies for organising the factory.<br />
I did complete a game of non-peaceful.. I’d say that the enemy attacks add some pushback and constraints. e.g. you need to supply defenses, and in order to expand the factory, you somewhat need to clear enemy bases.<br />
In terms of strategies I’ve tried: I’ve tried the game without trains or even bots(!), I tried the game where I used trains to augment a ‘main bus’. I tried a game where I had the whole factory covered with the same bot network, and used this to supplement a main bus (albeit, resource patches were frequent, rich, and big).</p>
<p>Recall.. the “main bus” idea is to put a bunch of common resources on belts in parallel. This makes the “gather inputs” part of the equation much simpler: to assemble an item with inputs “steel, copper, green circuits”, you just branch these resources off from the main bus.<br />
One inevitable problem is that the input requirements for your inputs might be larger than the bandwidth of the bus. (e.g. you’d ideally consume 1000 resources from the bus, but the bus only supplies 500).</p>
<p>Having a factory covered with bots “solves” the problem of getting uncommon items around; and also makes it easy to build up parts of the factory without needing the player around.<br />
I’d hoped for a ‘stacking’ design which automatically could build itself (since the roboports from one part would be able to then build more roboports and other buildings, expanding the factory).<br />
In hindsight, it was excessive to build roboports that covered the whole of the map. It didn’t really help with moving resources around great distances.</p>
<p>For this ribbon world, for moving resources great distances, I opted to go for a train-based approach.</p>
<h3 id="overview-of-the-strategy">Overview of the Strategy</h3>
<p>Generally the strategy I wanted to take for this factory was: use trains to move resources around.</p>
<p>I aimed to have four lanes of rails at the edge of the map: two on the top, two on the bottom. The idea being, train stations can branch-off from the inner pair of rails, whereas the outer pair of rails only ever has junctions to/from the inner pair of rails; trains need to slow down in order to stop, so hopefully this would reduce the need for trains to slow down before reaching their destination.</p>
<p>Using trains then means: have train stations which load resources from mines, and then have groups of train stations which consume those resources (and provide more complex resources in turn).</p>
<p>I hadn’t been against the idea of then using train stations to start off a “main bus”. However, I never ended up doing this. (I did build the same “mall” that I’d used in previous builds, which uses a bus of inputs). – It would take a lot of horizontal space to gather so many inputs, and would take a lot of horizontal space to extend the bus, and there’s not much vertical space to build off of the bus.</p>
<p>Militarily, the game was quite straightforward.<br />
In the early game, the enemy bases are quite far away. The enemy AI is passive, and only attacks in reaction to pollution from your factory reaching their base. It was easy for pace of conquest to outspeed pace of pollution, since the height of the map is limited.<br />
However, it doesn’t take too long until conquering enemy bases become too formidable for the player to take on by themselves. Enemy defenses get so strong that it takes a lot of effort to make incremental progress against them. (Although part of the problem is the tank doesn’t control so well on the Nintendo Switch, I reckon).<br />
In the late game, artillery outreaches the enemy.. so expanding the factory involves building up a wall &amp; some turrets, building out the railway to the wall, then using an artillery train to blast the enemy bases. – Notably, construction bots can be used to build out these, so it can be done without needing the player nearby.</p>
<h3 id="what-went-well-scale">What Went Well: Scale</h3>
<p>One of the challenges of Factorio’s late game is that high-tier items are really expensive, requiring many inputs.<br />
e.g. The simple green circuits require a few iron and copper pieces. The more advanced red circuits then require a few green circuits, a few copper pieces, and a few bits of plastic. The most advanced blue circuits require <em>twenty</em> green circuits, and some red circuits, and some sulfuric acid. – Many of the late game items require hundreds of blue circuits to build.<br />
As noted above, even if it’s not difficult to get inputs connected to a system, one of the problems using belts is hitting bandwidth limits.</p>
<p>Using trains to move resources around allows for huge scale.<br />
I suppose there must be a bandwidth limit on how many resources a rail allows, too. But, with trains only using rails when carrying a bulk of resources at great speed, it’s not really an easy limit to hit.</p>
<p>Trains then allow for ‘decoupling’ where an input is gathered from where it’s consumed.<br />
– With belts, you need a belt that runs all the way from a particular input to where it’s consumed. More resources can be fed into the belt, but resources need to be fed into the belt <em>before</em> where they’re consumed from a belt.<br />
With rail, there’s not this constraint. Resources loaded anywhere on a rail network will find their way to where they need to be unloaded in the rail network.</p>
<p>This ends up making “scaling” relatively straightforward: getting more resources essentially either involves building up how many resources are produced at a particular location (e.g. adding more miners to an ore patch) i.e. “scaling vertically”, or by adding more stations to the rail network which produce that resource i.e. “scaling horizontally”.</p>
<h3 id="practical-differences-between-belt-based-and-rail-based">Practical Differences Between Belt-Based and Rail-Based</h3>
<p>I did run into some practical problems trying a rail-based factory.</p>
<p>There is some edge case stuff.<br />
In rare cases, maybe a train runs out of fuel.<br />
When I tried to be fancy and programatically enable/disable a train station (e.g. “disable this stationn, because it has enough resources”), sometimes a train might stop in the middle of the rail because it suddenly gets disallowed from visiting its destination.<br />
etc.</p>
<p>One downside to the rail-based approach is there is additional overhead to deal with.</p>
<p>One overhead cost is that there may be a longer lead time between when an input is added to a network, and when it can be consumed by the network.<br />
e.g. A simple approach to take is to have a cargo train wait at a loading station until it is full, and then move to a deposit station until it is empty. (Anything more frequent than this would be an ‘inefficiency’). – This means opting to wait the full length of time for a cargo train’s worth of resources to be produced before it meaningfully enters the network. (This increases the delay in the feedback loop for how much some resource is demanded, for better and for worse).</p>
<p>Compared to belts, distribution of resources is more of a problem whenever inputs don’t fully saturate demand.<br />
With belts, splitting resources off of a belt does so in a 50-50 manner. So for a factory with 1000 units of some resource needed by A, B, and C.. 500 will reach A, 250 will reach B, 125 will reach C, leaving 125 to continue to be available on the bus (splitting off into 64, 32, etc.). – Eventually, at least <em>some</em> of the resource will reach even the end of the bus, even before inputs at the start are saturated.<br />
With rails, by default, you don’t get this behaviour. A train will go to the closest station that it can visit. – So while it’s still true that “producing more inputs than is consumed” <em>eventually</em> satiates demand, it takes more care to get expensive resources where they need to be before all inputs are satiated.</p>
<p>I’d say one mistake I made was using big buffers at resource unloading stations for expensive resources. – i.e. Each unloading station would have a buffer which could receive six or seven trains’ worth of cargo. For simple resources, this isn’t much of an issue, since it’s easy to build more stations which provide that resource. For more complex resources, since the time to produce the resource is greater than the time to load the resource onto the train, this meant that a significant amount of time was spent depositing the resource into filling up a buffer, when that resource was starved in other parts of the rail network.</p>
<p>Another overhead cost is space. This perhaps is “different” rather than “worse” than belts.<br />
With belts, moving resources over a long distance is tedious but possible. Moving rare/expensive resources long distances (at worst) involves snaking the belt through the rest of your factory.<br />
With trains, building a ‘block’ of stations for a resource which takes 5 inputs requires taking up a reasonable chunk of horizontal space on the map. (This is mostly more annoying with frequent resource patches, since you might want to avoid building on top of a resource patch).</p>
<p>One decision to make is “what resources to put on the rail network”.<br />
If building up the rail network before electric smelting, then coal is required to turn the ore into plates that get used by most recipes. (Which is why it’s a bad idea to build up a rail network before getting electric smelting).<br />
Yellow Science in particular has complex input requirements, and there are different trade-offs for putting its intermediate input requirements on the bus or assembling them in the same block.</p>
<h3 id="new-to-me-circuit-network-combinators">New to Me: Circuit Network Combinators</h3>
<p>The circuit network allows for programmability with Factorio’s machines.</p>
<p>I had used it before for simple things like “if ammo below certain amount, send an alarm signal” or “only take stuff out from this storage if there are at least 1000 items”.</p>
<p>The circuit network logic complements the rail network nicely.</p>
<p>I was able to use the circuit network to describe a couple of things:</p>
<ul>
<li><p>Dynamically set how many trains are allowed to visit a station, based on how much remaining capacity the storage buffer for the station had. (e.g. if it would only take two trains to fill the storage buffer, limit the number of trains that would visit the station to two).</p></li>
<li><p>Dynamically enable or disable the station based on how full the buffer was. Once the buffer was less than 20% (or whatever) full, then enable the station so that resources would be unloaded there; but once it reached 90% or so, then disable the station until the buffer was back down to only 20% full.</p></li>
</ul>
<p>The problem above of “starving stations not being filled, while buffers elsewhere were being filled” surely could have been mitigated using the circuit network. (The logic is a bit ‘come-from’: rather than saying where trains go <em>to</em>, you’d say which destinations should receive resources. I’m guessing something like: if any stations are ‘starved’, then limit or disable any stations which have at least some resources in their buffer).</p>
<h3 id="what-went-less-than-well-slow-progress-to-reach-late-game">What Went Less Than Well: Slow Progress to Reach Late Game</h3>
<p>Kinda like how playing Sudoku can be fun even though Sudoku solvers exist, playing Factorio can be fun even if you’re not building the best factory ever.<br />
Factorio is essentially just a toy.. and the game’s goal of ‘launch a rocket’ is a decent objective to aim for with Factorio’s systems.</p>
<p>It’d obviously be less fun if I just used console commands to provide infinite resources, or to instantly provide the rocket silo &amp; launch the rocket effortlessly.</p>
<p>I imagine it’d be less fun if I only used blueprints other people created.</p>
<p>I find Factorio fun even without the enemies, or with non-aggressive enemies.</p>
<p>Unfortunately, in this ribbon world playthrough on the Nintendo Switch, I took a long time before getting to the late game.<br />
What I ‘should’ have done was to aim to quickly build a factory which would (even at a trickle’s pace) research towards the late game technologies.<br />
Instead, I meandered and did things I thought were more interesting. Which is fine, but it meant it took a long time before I reached the late game.</p>
<p>The friction is that the problems you face in the early game get solved by the late game:<br />
Routing train rails is difficult when the map has cliffs and water. The cliffs can be blown up, and the water can be filled with later technology.<br />
A busy factory will use a lot of electricity. Nuclear power provides an abundance of electricity.<br />
Enemies block expansion.. and late game artillery ‘solves’ this, and laser turrets ‘solve’ the problem of supplying the defence.<br />
Building the same pattern of buildings repeatedly is slow; bots trivialise this.<br />
– But in order to use these technologies, you have to have researched them.<br />
Aiming to use a train-based factory before the late game ultimately ends up being a bad idea. You don’t have the capacity to expand the factory fast enough to meet the input requirements for the kind of scale that a train-based factory needs.</p>
<h3 id="a-follow-up-playthrough">A Follow-Up Playthrough</h3>
<p>As I was writing the above up, I just <em>had to</em> try again to see if I could do better.</p>
<p>I took time to pre-plan the ‘blocks’ of train stations that I would use. I used the sandbox mode so that this could be done in a safe way.</p>
<p>On the PC, I played using the default ribbon-world settings. (So, compared to my Nintendo Switch playthrough, resources were less frequent, and not quite as rich; plus, enemy expansion was enabled).</p>
<p>Overall, from a second playthrough:</p>
<ul>
<li><p>The gameplay was significantly more difficult with enemy expansion enabled than disabled. With enemy expansion, I very quickly hit a point where clearing enemy bases was impractical without artillery.</p></li>
<li><p>I used a much more compact approach when designing the blocks of train stations. This meant I was better able to utilise space.</p></li>
<li><p>In my first playthrough, I had opted to have each station allow for ‘stacking’ trains. This wasn’t really necessary for the scale I was operating at. (It would be useful if the factory were so large that “time to consume all of trains input” was shorter than “time for another train to arrive”).</p></li>
<li><p>I took the time to ensure my blueprints for “use roboports to expand the factory’s frontier” (place laser turrets, place rail so the artillery train can move further out) could more easily snap-to a course grid. This made it much easier to instruct the bots when expanding the frontier.</p></li>
<li><p>I <em>really</em> felt the contrast between ‘mid game’ and ‘late game’. With ‘mid game’, I was essentially boxed in until I could research artillery. I wasn’t able to easily expand in order to acquire more resource inputs. (Hence.. using a rail-based factory has more disadvantages than advantages). – Probably, though, the lategame alone wouldn’t feel so satisfying without having faced the obstacles in the mid-game.</p></li>
</ul>
<p>For now, that’s enough Factorio, though.</p>]]></summary>
</entry>
<entry>
    <title>Tomb Raider 3</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2024-01-13-tomb-raider-3.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2024-01-13-tomb-raider-3.html</id>
    <published>2024-01-13T00:00:00Z</published>
    <updated>2024-01-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I just finished re-playing Tomb Raider 3.</p>
<p>I’d played it many years ago, but almost certainly with cheats, as well as closely following a walkthrough.</p>
<p>This time, I didn’t lean so hard on the walkthrough, and at least gave an honest try through most areas before looking up the walkthrough.</p>
<p>Overall, I think I can stand by my opinion that Tomb Raider 2 is the better game. TR2’s challenging levels at the end are demanding but not over the top. It’s satisfying to complete the TR2 levels.</p>
<p>I rate TR3 a bit lower since at its worst it’s more obnoxious and less fun than the bad bits of TR2.</p>
<p>Overall, the stuff I found really-not-fun was where the game is unreasonably difficult.</p>
<p>To give a couple of examples of where TR3 was really-not-fun:</p>
<ul>
<li><p>The level “Lud’s Gate” features an obnoxious underwater segment with obfuscated navigation steps. There’s an underwater vehicle, but it’s clunky to control, and your air supply is limited. – The difficulty is obnoxious without being rewarding to complete.</p></li>
<li><p>One part where I got stuck was in the London level “Aldwych”. Aldwych is wonderfully themed, taking place in an abandoned tube station. But.. I recall I was stuck because I couldn’t find two keys.. I had found the old penny (a key item), but to use the old penny, I had been unable to figure out that I was supposed to use it in one of the ticket machines. (The ticket machines all looked the same, and the first few I interacted with did nothing). – Another contributing cause, I had overlooked and gone past an area to get one of the keys. The level was a bit too non-linear.</p></li>
<li><p>I recall being stuck on the level “Crash Site” due to being unable to figure out how to climb on top of the airplane. You can only get up from one spot, and that spot looks very similar to nearby spots where you can’t climb up from.</p></li>
<li><p>On the penultimate level, there are some enemy spawns which seem infinite. (They’re infinite spawners on the Playstation version, and spawn over one or two dozen enemies on PC). That’s .. just lame.</p></li>
</ul>
<p>“Getting stuck” is part of a good adventure game. – In an action game, the obstacles you have to overcome are the enemies you face. In adventure games, you have to figure out how the level you’re exploring “works” (where you’re allowed to go, what ‘locked doors’ are preventing you from reaching other places, how you might get the keys for these), and work your way through the puzzles.</p>
<p>But, whereas, say, I recall in the TR2 level “Living Quarters” when I was stuck.. the area I was stuck in was limited enough that by re-treading all the locations, I was able to find which places I had overlooked. The same is true for many parts of TR3’s levels.</p>
<p>In terms of what the game does well? Kinda the opposite: being challenging enough that you feel good for solving it, but still being easy enough to solve. Some examples of what I liked:</p>
<ul>
<li><p>The training level that is Lara’s Home is great. There’s a surprising amount to do here. You get to have fun with the mechanics in an environment without hostiles or traps. The indoor gym area has a step-by-step introduction to the game’s somewhat idiosyncratic grid-system that the game’s “tank controls” are built around. – I saw someone say that one sample to see how good a shooter game will be is to try just taking a gun and shooting at a wall. If that’s satisfying, the game will be fun to play. Lara’s Home is like that: the area lacks plot or hostile challenges, so you know that since the bare-bones of the game is fun to play with, the game itself ought to be fun.</p></li>
<li><p>The iconic ‘Shiva statues’ in the second level are excellent. There’s tension building up to the fights. The fight isn’t trivial, but it’s also not too difficult. (The animated statues block your bullets when you point your guns at them, so you have to figure out how to defeat them while also not getting killed by them).</p></li>
<li><p>As an example of a puzzle I liked: in the level “Thames Wharf”, there’s a room where there’s some kind of cleaning robot going around the floor. It will kill you if it runs over you, but otherwise isn’t an active threat. You also see there’s a movable block, and a spot in the middle of the room with some kind of console. – There aren’t too many things to try out here, it’s not too difficult to execute any plan you might have. It feels non-trivial, but it’s also not too difficult.</p></li>
<li><p>e.g. The level “Antarctica” is a well design adventure level. It’s non-linear enough that you’ll sometimes be wondering where to go next, but not so non-linear as to be obnoxiously confusing.</p></li>
<li><p>Boss fights: I think these work well. They’re threatening enough that it takes time to figure out what you’re supposed to do.. you can either use your powerful weapons, but the fights aren’t completely obnoxious with pistols, either.</p>
<ul>
<li>The London boss fight in “City” is really short and sweet. You’re kinda rushing through the level under fire from the enemy boss, but it’s not so obnoxious.</li>
</ul></li>
<li><p>The additional platforming elements (ducking/crawling, and monkey-swinging) feel like natural additions to the grid-based navigation.</p></li>
</ul>
<p>Any long-running series is going to have an identity.. things which work with that identity or things which maybe didn’t work so well.</p>
<p>Tomb Raider was the definitive action adventure game of the 90’s, with its gameplay built upon its tank-controls and its grid system, with all sorts of platforming, exploration, puzzles, traps, and combat.<br />
Of these, the combat of the classic games is what feels most archaic. Tank controls are unpopular in the era of twin-stick controllers and WASD+mouse gameplay. And while removing all friction/difficulty from games would ruin the fun.. that the classic Tomb Raider games don’t allow Lara to strafe-around a target she’s locked onto feels limited. – For me, a lot of the combat involved flipping around to get behind where the enemy is. Strafing would make that much easier, and wouldn’t feel out of place.</p>
<p>That said.. the combat itself was never quite the strongest part of Tomb Raider’s gameplay. It provides good pushback so that there’s tangible benefits for exploring: you explore and you find ammo for the good weapons you have, so then you can use the good weapons and take care of enemies easily. And it keeps you on your toes: you’ve gotta be prepared to fight an enemy when you enter a new area (or re-enter an area after solving a puzzle!).<br />
The recent and related-only-in-name Tomb Raider games opted for third person combat … but also lacks an identity. I think the combat in the classic Tomb Raider games at least fits with the rest of the game’s over-the-top acrobatics. I don’t think the classic games’ combat is inherently boring; but I think an extra feature or two could go a long way to making it more dynamic. (e.g. like how Halo at least has energy weapons vs bullet weapons, or how Doom 2016 has the idea of getting health/ammo from enemies directly).</p>
<p>Tomb Raider 3’s Story?<br />
I’d say it doesn’t do much, but that it doesn’t need to do much.<br />
Lara’s exploring for some artifacts. Gets told that there’s more/similar artifacts. Surprise twist that the guy asking her to collect the artifacts has turned crazy. Boss fight. The end.<br />
The game does feature some cutscenes with dialogue, otherwise it’d maybe be a bit too bland.<br />
I guess the story archetype to compare to is Indiana Jones.. “hey, there’s this powerful mystical artefact; let’s find it, and stop the bad guys from finding it”.<br />
The recent big budget games with the title “Tomb Raider” have put much more emphasis on the story (although notably without having such a kickass Lara Croft).. but, focused on drama and relatability, that just didn’t seem all that interesting. – In contrast, I think TR3’s story is simple.<br />
I’m not sure what it’d take to make such a game story “good”. Interesting lore? Compelling villains? Compelling side characters? Stories which really drive the setting? Interesting settings?</p>]]></summary>
</entry>
<entry>
    <title>Experience Writing Firmware with the CH582 Port of QMK</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-12-27-experience-writing-firmware-with-the-ch582-port-of-qmk.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-12-27-experience-writing-firmware-with-the-ch582-port-of-qmk.html</id>
    <published>2023-12-27T00:00:00Z</published>
    <updated>2023-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="../../posts/programming/2023-12-21-notes-on-building-wch-ble-ch592-evt-exam-with-bare-makefile.html">As noted previously</a>,
WeAct Studio have a BLE devboard that costs about $2 (which is MUCH cheaper than the BLE devboards popular in custom mechanical keyboard designs), but there isn’t much community attention for this board; there aren’t many (any?) keyboards designed to use this devboard, and there aren’t many people using firmware for it. There is a port of QMK to use the CH582.</p>
<p>And it’s been announced that <a href="https://www.reddit.com/r/ErgoMechKeyboards/comments/18p99d9/fak_firmware_adds_macros_sticky_mods_mouse_keys/">FAK support for the CH58x/CH59x is planned</a>.</p>
<p>I designed a keyboard to use WeAct Studio’s BLE devboard.<br />
In a sense, this somewhat puts the cart before the horse, since I hadn’t tried proper keyboard firmware with the devboard before designing the keyboard.</p>
<p>The good news is, I was able to get working keyboard firmware for my keyboard using the <a href="https://github.com/O-H-M2/qmk_port_ch582">QMK port for CH582</a>.</p>
<p>Unfortunately, this wasn’t without frustration.</p>
<h2 id="initial-impression">Initial Impression</h2>
<p>I have experience writing keyboard firmware, by way of making use of what others have written.
e.g. I’ve written keyboard definitions for QMK (including before the move to data-driven configuration), implemented the game Snake using QMK’s RGB Matrix effects system; I’ve written keyboard firmware in Rust; I’ve implemented CapsWord functionality for FAK.</p>
<p>My initial impression of the CH582 port of QMK is it feels fragile and finicky.</p>
<p>The structure of the repo wraps CMake lists around the QMK codebase. – To me, this seems like additional effort, for marginal benefit. It’s not clear to me that it’s necessary, either. – This leads to (as noted below) requiring additional effort to use features which QMK implements, &amp; it took significant additional effort to figure out how to re-use the keymap code I had written in QMK.</p>
<p>In terms of QMK, it felt like writing qmk before the data driven configuration. (In order to make use of QMK’s data driven configuration, more CMake code would need to be added to support using the autogenerated keymap code).</p>
<h2 id="obstacles">Obstacles</h2>
<h3 id="didnt-produce-working-firmware-with-the-open-source-risc-v-toolchain">Didn’t Produce Working Firmware with the Open-Source Risc-V Toolchain</h3>
<p>When I build the EVT examples for the CH592, I was able to build and run the examples with either the ‘public’ risc-v gcc distributed by xpack, or the toolchain distributed by MounRiver Studio.</p>
<p>Although I noticed I <a href="https://github.com/O-H-M2/qmk_port_ch582/commit/9f1aa898a913b1bc0af873443c75abc0083fa98e">had to make changes to the CMake lists</a> in order to build the QMK fork for CH582 with the ‘public’ xpack toolchain, I had been able to <em>build</em> the firmware.</p>
<p>Unfortunately, when I was finally able to try running this firmware on a CH582 devboard, only the firmware built by the MounRiver toolchain worked when I ran it.<br />
I don’t know why.</p>
<h3 id="ble-is-still-wip">BLE is Still WIP</h3>
<p>The README currently has the line: “Support wired, Bluetooth, and triple mode 2.4G (WIP)”. I understood this to mean “Supports wired, Bluetooth” and “triple mode 2.4G” is WIP.</p>
<p>But, <a href="https://github.com/O-H-M2/qmk_port_ch582/issues/154">as others have observed</a>, e.g. the TychePad keyboard (which uses BLE) doesn’t build.</p>
<p><a href="https://github.com/O-H-M2/qmk_port_ch582/blob/2dde4b4777d2e91abe0b96c91b64f3fea5cd7ecb/CMakeLists.txt#L312">Enabling BLE requires the wireless lib</a>, but in order to build the wireless lib, <a href="https://github.com/O-H-M2/qmk_port_ch582/blob/2dde4b4777d2e91abe0b96c91b64f3fea5cd7ecb/CMakeLists.txt#L200">the required files aren’t provided in the repo</a>.</p>
<p>Hence, BLE isn’t available with the publicly provided code.</p>
<p>I don’t mind the work being WIP; but I assess it as sloppy to have WIP code that doesn’t build on a release branch.</p>
<p>And $2 for a risc-v devboard is pretty neat, even if for keyboard firmware it’s USB only at the moment.</p>
<h3 id="getting-my-keymap-to-build">Getting My Keymap to Build</h3>
<h5 id="the-cmake-files-dont-support-community-layouts">The CMake Files Don’t Support Community Layouts</h5>
<p>The <code>qmk_firmware</code> repository supports putting keymap definitions in <code>layouts/community</code>. This allows you to define the keymap for some layout (such as <code>ortho_4x12</code> or <code>split_3x5_3</code>), rather than only defining a keymap specific to a keyboard.</p>
<p>At the time of writing, the CMake lists in the CH582 port don’t support using this feature.<br />
Perhaps it could, but it doesn’t at the time of writing.</p>
<h5 id="false-friends-config.h">False Friends: config.h</h5>
<p>This confused me for some time:</p>
<p>Both <a href="https://github.com/O-H-M2/qmk_port_ch582/tree/via/sdk/HAL/include"><code>sdk/HAL/include</code></a> and QMK use header files called <code>config.h</code>.</p>
<p>So, by adding a CMake statement <code>include_directories(...)</code> pointing to a QMK keyboard or keymap directory (which has <code>config.h</code>), this breaks the build since then the CH582 HAL doesn’t correctly include its <code>config.h</code>.</p>
<p>This is more of a -1 to C than to anything else.</p>
<p>I worked around this by using more of the path when including; e.g. rather than <code>#include "rgoulter.h"</code>, I use <code>#include "users/rgoulter/rgoulter.h"</code>.</p>
<h5 id="some-qmk-features-not-implemented">Some QMK Features Not Implemented</h5>
<p>The CH582 port of QMK uses CMake to manage its build.</p>
<p>So, QMK features are enabled <a href="https://github.com/O-H-M2/qmk_port_ch582/blob/via/qmk_porting/common_features.cmake">by checking CMake variables</a>.</p>
<p>Turns out, some of the features I use weren’t described there. <a href="https://github.com/O-H-M2/qmk_port_ch582/commit/27aba0c570a48c0a479b21ef83940ac08abca1c7">I was able to add them</a>.</p>
<p>While for other QMK features (such as the haptic feedback feature) which depend on driving hardware peripherals, it makes more sense that the CH582 platform for QMK lacks the implementation.. for stuff like the leader key or combos, I felt “not implemented” was more due to it needing to be declared in CMake.</p>
<h5 id="custom-keycodes-safe-range">Custom Keycodes: Safe Range</h5>
<p>I also ran into problems where my keymap defined new keycodes.</p>
<p>Again, this is more of a -1 to C, and that it doesn’t necessarily compose things like this well.</p>
<p>The QMK interface for <a href="https://docs.qmk.fm/#/custom_quantum_functions?id=custom-keycodes">defining new keycodes is to use <code>NEW_SAFE_RANGE</code></a>.</p>
<p><a href="https://github.com/O-H-M2/qmk_port_ch582/blob/2dde4b4777d2e91abe0b96c91b64f3fea5cd7ecb/qmk_porting/protocol/extra_keycode.h#L51">This port declares its own <code>NEW_SAFE_RANGE</code></a>.</p>
<p>So, my code needed to untangle a bit from that; and it’d take some care to be aware of whether the codebase I’m building against defines its own <code>NEW_SAFE_RANGE</code> or not.</p>
<h5 id="mirroring-my-community-layout">Mirroring my Community Layout</h5>
<p>Initially I’d tried copying the C files across in order to get my layout on the keyboard. This works, but isn’t the most maintenance friendly approach. (I’d need to re-copy each time I changed my layout).</p>
<p>Once I figured the stuff above out (about <code>config.h</code>, etc.), I was able to come up with a way of using my community layout without too much fuss: <a href="https://github.com/O-H-M2/qmk_port_ch582/commit/67795a2beb647276d30bdf3da771584e6465465f" class="uri">https://github.com/O-H-M2/qmk_port_ch582/commit/67795a2beb647276d30bdf3da771584e6465465f</a></p>
<p>The <code>keymap.c</code> just includes the <code>keymap.c</code> from the community layout:</p>
<pre><code>#include &quot;layouts/community/ortho_5x12/rgoulter/keymap.c&quot;</code></pre>
<p>The <code>qmk_config.h</code> includes the <code>config.h</code> from the community layout dir, and the user dir:</p>
<pre><code>#pragma once

#include &quot;users/rgoulter/config.h&quot;
#include &quot;layouts/community/ortho_5x12/rgoulter/config.h&quot;</code></pre>
<p>and the <code>rules.cmake</code> ports the <code>rules.mk</code> functionality over:</p>
<pre><code>set(COMBO_ENABLE ON CACHE BOOL &quot;KB&quot; FORCE)
set(LEADER_ENABLE ON CACHE BOOL &quot;KB&quot; FORCE)
set(DYNAMIC_MACRO_ENABLE ON CACHE BOOL &quot;KB&quot; FORCE)

list(APPEND QMK_PORTING_SOURCES
    &quot;${QMK_BASE_DIR}/users/rgoulter/rgoulter.c&quot;
)</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>I feel more sour about the above than I should, because it took a bunch of effort to figure this stuff out.</p>
<p>I don’t love the use of CMake. (e.g. my re-implementing stuff from <code>rules.mk</code>, it feels like there are multiple sources of truth for describing the same thing).<br />
I wish it implemented support for QMK’s community layouts, or for QMK’s data driven configuration.</p>
<p>I was disappointed to realise the BLE code wasn’t publicly available, and that the code somehow relies on the proprietary MounRiver distribution of the risc-v toolchain.</p>
<p>But, for the moment, I don’t think there’s any other publicly available keyboard firmware for CH582.</p>]]></summary>
</entry>
<entry>
    <title>Notes on Building WCH BLE CH592 EVT Exam with Bare Makefile</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-12-21-notes-on-building-wch-ble-ch592-evt-exam-with-bare-makefile.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-12-21-notes-on-building-wch-ble-ch592-evt-exam-with-bare-makefile.html</id>
    <published>2023-12-21T00:00:00Z</published>
    <updated>2023-12-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here are some notes from tinkering with the <a href="https://github.com/WeActStudio/WeActStudio.WCH-BLE-Core">WeAct Studio BLE Core Board</a>.</p>
<h3 id="its-not-used-in-many-designs">It’s Not Used in Many Designs</h3>
<p>My interest in the board comes from my interest in custom mechanical keyboard designs.<br />
– The best part of ‘free and open source’ is the “gratis” part.<br />
But the “libre” part is neat, too: it’s much easier to realize an interesting keyboard design if all you need to do is iterate on a keyboard design someone else has made.</p>
<p>I’ve never tried designing a Bluetooth keyboard.<br />
The sour grapes explanation is that Bluetooth devices are finicky to use. (Which is true).<br />
What most hobbyists do for Bluetooth keyboards is use Bluetooth-powered devboards like the nice!nano, and use ZMK firmware. – TBH part of why I’m not interested in this devboard is it costs over 20 USD. (And it’s most common in split keyboards, which’d need one for each side!).</p>
<p>I recently picked up a WeAct Studio BLE Core board, ordered from AliExpress.<br />
(I’ve used a few different devboards from WeAct Studio in several of my keyboard PCB designs; including WCH MCUs).<br />
The BLE core board has designs for the different MCUs: CH573, CH582, CH592.<br />
In contrast, this devboard costs $2.</p>
<p>But despite it being such a cheap board, I can’t find any designs which use this board.</p>
<p>Some notes on what I could find:</p>
<p>The <a href="https://github.com/joric/nrfmicro/wiki/Alternatives#ch582">Alternatives wiki page on joric’s nrfmicro repo</a>
describes the CH582 as:</p>
<blockquote>
<p>QMK has a CH582 port! It has BLE and there’s a dev board for it on Aliexpress for about 2 bucks. That is, if you’re willing to experiment since, as far as I’m aware, no keyboard has been designed with it and there’s not a lot of users yet. [ZMK not supported.]
… Last I looked, datasheets were basically “sorry, not documented” on the registers for BLE hardware. And 32KB of RAM on the CH582F would definitely be a challenge.</p>
</blockquote>
<p>Regarding “low RAM an issue” semickolon (who authored FAK firmware for the CH552 MCU) <a href="https://www.reddit.com/r/ErgoMechKeyboards/comments/18aekwm/comment/kbz35tc/">commented that the chip’s BLE only uses 4KB RAM, and that FAK had about 1KB RAM</a>. (He also mentions he’s got a keyboard working with some firmware he’s building for the chips).</p>
<p>The datasheets indeed omit documentation for the registers for the BLE hardware.</p>
<p>FWIW, I did see some BLE keyboards using these WCH chips on OSHWHub such as <a href="https://oshwhub.com/cansong/ch579_keyboard_v0-1">cansong’s ch579 keyboard</a>, which points to <a href="https://oshwhub.com/JokerAlon/ch579m-64keyboard">JokerAlon’s ch579m</a>. Albeit, the readmes for these aren’t in English. – The schematics are available, at least.</p>
<p>Albeit, at the time of writing, there really aren’t many English search engine results for CH592. Nor CH58x. Nor CH57x.<br />
The keyboards above seem to be row-stagger, and with big spacebars. (The big spacebars make it easier to design a PCB, but don’t make for a good keyboard. – I do recall seeing boardsource.xyz’s solution to this for their <a href="https://www.reddit.com/r/MechanicalKeyboards/comments/t1c5pl/technikable_gb_is_live_on_boardsourcexyz_wireless/">technikable ble ortho</a> was to omit the 2 keys in the bottom corners of each side..).</p>
<p>I wasn’t aware of it before, but both the wiki page above (and the reddit comment) point to <a href="https://github.com/O-H-M2/qmk_port_ch582">O-H-M2’s port of QMK for CH582</a>. (Looking at the port a bit: it retains upstream QMK’s codebase unchanged, and adds some platform-specific code for CH582).<br />
(There are keyboards listed in this; one seems to be a giant handwired ortho, the others are either macropads/numpads, or row-staggered with big spacebars).<br />
The default branch name is <code>via</code>; the readme mentions via functionality is implemented. (I don’t use via/vial, but seems it’s useful for many).</p>
<p>On GitHub, <a href="https://github.com/openwch/ch592">OpenWCH provides EVTs with Examples and SDKs for CH592</a> (and other chips). (Whereas, <a href="https://github.com/SoCXin/CH552.git">CH552 is in the SoCXin org</a>). – These examples include a BLE HID “keyboard” (it periodically sends a HID keyboard report, but doesn’t read GPIO pins).<br />
– So, there is working code, and a README PDF(!) describing how to run the example.. this PDF describes to use <a href="http://www.mounriver.com/download">MounRiver Studio</a>.</p>
<p>Using MounRiver Studio works (at least for building these EVT Examples; I didn’t try flashing from MounRiver).</p>
<p>I saw that the <a href="https://github.com/WeActStudio/WeActStudio.WCH-BLE-Core">WeAct BLE repo</a> included <code>Makefile</code>s for its code (copied from the EVT).<br />
Copy-pasting the comment at the header of the file into a translate service: “generated, do not modify”.<br />
Oh no.</p>
<p>That’s … not a promising sign.</p>
<p>Fortunately, the <a href="https://github.com/O-H-M2/qmk_port_ch582/blob/via/README.md#developers">QMK port to CH582’s readme</a> has instructions which mention downloading the MounRiver Studio toolchain and using <code>cmake</code>/<code>make</code>.</p>
<h2 id="toolchain-building-the-ch582-port-of-qmk">Toolchain: Building the CH582 Port of QMK</h2>
<p>I’m running NixOS, and one of the downsides of using NixOS is it can be difficult to run binaries distributed in tarballs.</p>
<p>MounRiver Studio and its toolchain is distributed as binaries in a tarball.</p>
<p>I was able to come up with some Nix packages for the <code>libmcuupdate.so</code> distributed in the toolchain tarball, and the GCC toolchain:<br />
<a href="https://github.com/O-H-M2/qmk_port_ch582/commit/40828b8361bbc711fb7c7af00374eea565f75d2f" class="uri">https://github.com/O-H-M2/qmk_port_ch582/commit/40828b8361bbc711fb7c7af00374eea565f75d2f</a><br />
(I <a href="https://github.com/NixOS/nixpkgs/blob/54aac082a4d9bb5bbc5c4e899603abfb76a3f6d6/pkgs/development/compilers/gcc-arm-embedded/12/default.nix">adapted another Nix package which downloads GCC in a tarball</a>).</p>
<p>With that, I was able to build the QMK port for CH582 built.</p>
<p>Oh. Wait. Taking a look at the <code>--version</code> for the toolchain MounRiver Studio distributes:</p>
<pre><code>$ riscv-none-embed-gcc --version
riscv-none-embed-gcc (xPack GNU RISC-V Embedded GCC, 64-bit) 8.2.0
Copyright (C) 2018 Free Software Foundation, Inc.</code></pre>
<h2 id="risc-v-toolchain">Risc-V Toolchain</h2>
<p>Links to things:</p>
<p>The old <a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack">riscv-none-embed-gcc-xpack</a>,
and <a href="https://github.com/sifive/riscv-gcc">SiFive’s riscv-gcc</a>.</p>
<p>And the newer <a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack">riscv-none-elf-gcc-xpack</a>.
And this seems related:
https://github.com/riscv-collab/riscv-gnu-toolchain.</p>
<p>The change from <code>riscv-none-embed-gcc</code> to <code>riscv-none-elf-gcc</code> is mentioned in the <a href="https://xpack.github.io/blog/2022/05/14/riscv-none-elf-gcc-v11-3-0-1-released/">xPack riscv gcc 11.3 release notes</a>.</p>
<p>Trying these upstream xpack riscv toolchains with the qmk port for ch582.. for one, <code>TOOLCHAIN_PREFIX</code> needs to be set to <code>risc-none-embed</code> if using the older GCCs. But, I did need to make a couple of other changes:</p>
<p>The MounRiver toolchain has an extra param <code>highcode-gen-section-name</code> that the xpack toolchains don’t have:
<a href="https://github.com/O-H-M2/qmk_port_ch582/commit/347e15458be15a714494d0088fa77243f62e7009" class="uri">https://github.com/O-H-M2/qmk_port_ch582/commit/347e15458be15a714494d0088fa77243f62e7009</a></p>
<p>And, as the <a href="https://xpack.github.io/blog/2022/05/15/riscv-none-elf-gcc-v12-1-0-1-released/#risc-v-isa-updates">xPack riscv gcc 12.1 release notes explain</a>, errors like <code>extension</code>zicsr’ required<code>can be fixed by adding</code>_zicsr` to the arch: <a href="https://github.com/O-H-M2/qmk_port_ch582/commit/dafb73132b6642ac70322239673060fe56d0b9b9" class="uri">https://github.com/O-H-M2/qmk_port_ch582/commit/dafb73132b6642ac70322239673060fe56d0b9b9</a></p>
<p>(I didn’t try <a href="https://github.com/O-H-M2/qmk_port_ch582/tree/2dde4b4777d2e91abe0b96c91b64f3fea5cd7ecb/utils">the toolchain that’s checked into the git repo</a>; but seeing stuff like that makes me wonder if the embedded developers are doing okay).</p>
<h2 id="building-the-examples-outside-mounriver-studio">Building the Examples Outside MounRiver Studio</h2>
<p>The EVT Examples are supplied with only a MounRiver Studio project file.</p>
<p>Since I’m not sure what works and what doesn’t work (in terms of how to compile the examples outside of MounRiver), it’s easiest to start from something that works. – Building it in MounRiver works, which generates some Makefiles.</p>
<p>Using that, I adapted a Makefile with the same compiler flags to get a Makefile which produced a working build.<br />
(Or, honestly: I’d copied the makefile from the broadcaster example, but that set different <code>-D</code> defines, which didn’t play nicely with the BLE HID example, and it took me some time to notice why my Makefile wasn’t producing a working build of the example).</p>
<p>Anyway.</p>
<p>I copied the BLE HID_Example example, put it together with a standalone Makefile, and some Nix files to provide the toolchain, and shared it in this repo: <a href="https://github.com/rgoulter/ch592-ble-hid-keyboard-example" class="uri">https://github.com/rgoulter/ch592-ble-hid-keyboard-example</a></p>
<h2 id="flashing-the-firmware">Flashing the Firmware</h2>
<p>Flashing the CH592 is the same as flashing the CH552. You can enter the bootloader by holding the BOOT button when plugging the board into the computer, and then use <a href="https://github.com/ch32-rs/wchisp">ch32-rs’ wchisp</a> to flash the firmware. (On Windows, I’d had difficulty using <code>wchisp</code>; but the official programs from WCH worked on Windows when I tried with the CH552).</p>]]></summary>
</entry>
<entry>
    <title>Die Another Day not as Bad as I Remembered</title>
    <link href="http://www.rgoulter.com/blog//posts/narrative/2023-12-14-die-another-day-not-as-bad-as-i-remembered.html" />
    <id>http://www.rgoulter.com/blog//posts/narrative/2023-12-14-die-another-day-not-as-bad-as-i-remembered.html</id>
    <published>2023-12-14T00:00:00Z</published>
    <updated>2023-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Still slowly re-watching through the James Bond movies.</p>
<p>Just finished “Die Another Day”, Pierce Brosnan’s last Bond movie.
My wife likes him as Bond as he’s the most handsome James Bond.</p>
<p>I was surprised that the movie wasn’t as bad as I had remembered it.<br />
Perhaps partly that’s because upon rewatching the other Brosnan movies, I realise they’re not as good as I remember them.</p>
<p>I had pretty much remembered the broad plot: something about Bond in North Korea, at some fancy medical clinic in Cuba, fencing in England, and then in some icy location with an orbital beam of death, and somehow the climax of the movie is on a plane. And something about the bad guy being “DNA swapped” of a Korean guy.</p>
<p>It’d be a bad idea to judge the Bond films by the worst moments (seeing as how I think what lingers is generally the positive parts), but “Die Another Day”’s worst parts are definitely its early-2000s CGI.<br />
The CGI happens to work for the invisible car.. but it <em>really</em> doesn’t work for a part in the movie where Bond is para-surfing away on the waves from a collapsing ice shelf. – It’s stupid, but not fun.</p>
<p>Whereas what I didn’t remember all that much was the spy-car-vs-spy-car car chase.. I think maybe in the open tundra this car chase was a bit dull; but I thought it surpassed the bar for “rule of cool” by the time the chase went through the hallways of the ice hotel.</p>
<p>Putting it that way.. I think the film’s premise sounds pretty cool: James Bond has to face off against a villain who has transformed himself into a mirror image of James Bond (gadgets and spy car included).</p>
<p>I think the Bond films are the at their most engaging when there’s some tangible threat that Bond has to track down and stop. (Whereas, without a known threat, it just feels like ‘stuff happens’, and Bond moves from one place to the next). – In “Die Another Day”.. although the supervillain’s doom weapon comes as a late surprise, throughout the film Bond always has a clear target and makes progress towards it. Good.</p>
<p>That said, there’s something very cringeworthy about the film’s premise, too. The bad guy race-swaps himself from Korean to being British. … It’s just really weird.</p>
<p>Some parts of the film are fun. I love the gag where Moneypenny finally gets to make out with Bond.. only for it to be revealed that this was just in the computer simulation. (The gag doesn’t really fit well in the plot; but it’s such a great gag).</p>
<p>Halle Berry’s character is pretty cool in this. She competently does a bunch of spy stuff, doesn’t overshadow Bond, and doesn’t mess things up. – My wife’s usual disapproval for the way Bond women are written is “they’ll have sex with Bond and then turn stupid” (where perhaps the best example of this was the Bond girl in “License to Kill”; if not “Diamonds are Forever”).</p>]]></summary>
</entry>
<entry>
    <title>Experience Designing a Keyboard PCB</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-11-26-experience-designing-a-keyboard-pcb.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-11-26-experience-designing-a-keyboard-pcb.html</id>
    <published>2023-11-26T00:00:00Z</published>
    <updated>2023-11-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I designed a <a href="https://github.com/rgoulter/keyboard-labs/releases/tag/ch552_48-rev2023.1">keyboard PCB</a>, which I’m calling “CH552-48”. (It uses the CH552 MCU, and it has 48 keys).</p>
<p>This was
I have designed <a href="https://github.com/rgoulter/keyboard-labs#keyboards">other keyboard PCBs</a>,
but I’m particularly pleased with this one.<br />
The keyboard PCBs I’ve designed fall into two kinds: those that use a development board (and are relatively easy to solder by hand), and those that are intended to be manufactured with “PCBA”.<br />
However, the devboard-based designs were pretty easy to design; and while I found the PyKey40 tricky to design (I found it quite tricky to fit the MCU between the keyboard switches; an ortholinear keyboard doesn’t allow for much space!), I was more/less modifying an existing PCB design.</p>
<p>To be honest.. the keyboard PCB designs I’ve done aren’t really aiming for “great keyboard” so much as they’re aiming for “interesting PCB to design”.<br />
e.g. designing a split keyboard where each half is smaller than 10x10cm may not make for a ‘great’ keyboard, but the design constraint made it really fun to design.<br />
The “X-2 Lumberjack Arm” is a pretty good keyboard. I think it’s visually very striking. At the time I designed it, there weren’t many Arm-powered (ortholinear) keyboards that could be bought off-the-shelf.<br />
And PyKey40 is also a good keyboard.. but, I had thought it’d be an interesting challenge to try and cram the fully-featured PyKey60 into the smaller 4x12 grid.<br />
– I do like that idea “first time you do something, it’s as a scientist; the second time, as an engineer, but by the third time it’s as a technician”.</p>
<p>I wanted to design the CH552-48 after I came across the <a href="https://github.com/semickolon/fak">fak firmware</a>. Fak firmware was written for the CH552, which has the advantage of being much cheaper than the RP2040 (even if it’s not as powerful).</p>
<p>Something that made this an interesting or constrained PCB to design was that the CH552T MCU only has 14 GPIO pins.<br />
A keyboard uses the GPIO pins for scanning which keys have been pressed. Typically, 1 pin is used for each row and each column of the keyboard matrix. e.g. a 60-key keyboard arranged in 5 rows of 12 columns would typically use 17 pins.<br />
I have seen other projects use the CH552 for keyboards, but these tend to be keyboards with a very low number of keys, such as using it for a numpad, or using a CH552 for one half of a small split keyboard.<br />
I figured that 14 pins allows for 7 rows of 7 columns, or about 49 keys.</p>
<p>Obviously, a square keyboard wouldn’t make for a useful desktop computer keyboard.. but instead, the 7x7 matrix could be the ‘logical’ matrix, and I could arrange the 48 keys in 4 rows of 12 columns. I thought this was pretty neat.</p>
<p>I designed the <a href="https://github.com/rgoulter/keyboard-labs/releases/tag/ch552_44-rev2023.1">CH552-44</a> first, which more/less takes the same shape as the <a href="https://github.com/rgoulter/keyboard-labs/releases/tag/pico42-rev2023.1">Pico42 keyboard</a> which I had designed earlier as a workaround to make use of keyboard cases I borked the design for. (The Pico42 in turn does itself bear close resemblance to the <a href="https://github.com/rgoulter/keyboard-labs#x-2-5x12-ortholinear-arm-powered-adaptation-of-peejs-lumberjack-pcb">X-2 “Lumberjack Arm”</a> keyboard I’d designed earlier..).</p>
<p>It made sense to start with CH552-44 as a proof-of-concept since it would be solderable with only through-hole components, which are <em>very</em> easy to solder.</p>
<p>In designing the CH552-44, I had to come up with some scheme to actually route this logical 7x7 matrix laid out on a physical 4x12 grid.<br />
When the logical matrix is the same size as the physical matrix, it’s straightforward to connect each of the column pins together.<br />
But with a mismatch between the logical matrix and the physical matrix, some complexity was inevitable.</p>
<p>Keyboard designs, especially ortholinear keyboard designs, involve a lot of patterns and repetition.
My experience is that early on when routing the traces for the PCB, it might not be clear what the patterns for the traces <em>should</em> be; but once it does become clear, then routing the traces does become straightforward.</p>
<p>This part of PCB design can be very fun. – In a way, it tickles the same part of the brain that some parts of Factorio do: in Factorio, you need to connect certain outputs to certain inputs, and the challenge is in how to physically arrange the systems as part of a larger factory; ideally in an organised manner, without too much spaghetti. Hobbyist PCB design is exactly the same.</p>
<p>Compare the traces for the Pico42:</p>
<p><img src="https://raw.githubusercontent.com/rgoulter/keyboard-labs/master/docs/images/keyboards/pico42/keyboard-pico42-2023.2-bottom.svg" width=600 /></p>
<p>with those of the CH552-44:</p>
<p><img src="https://raw.githubusercontent.com/rgoulter/keyboard-labs/master/docs/images/keyboards/ch552-44/keyboard-ch552-44-2023.1a-bottom.svg" width=600 /></p>
<p>It’s not an <em>extreme</em> difference, but the CH552-44 does feel like it’s got busier streets and city blocks.</p>
<p>Anyway. Once I’d received these CH552-44 PCBs, and checked that they worked with the CH552 devboard I was using, the next step I wanted to try was to make a PCBA version of the design.</p>
<p>This itself wasn’t too hard, either.</p>
<p>I looked at the devboard’s schematic, saw what parts of that I was using, and replaced the devboard in my schematic with those parts.</p>
<p>Overall, not too much needed to be changed for the PCBA design:</p>
<p><img src="https://raw.githubusercontent.com/rgoulter/keyboard-labs/master/docs/images/keyboards/ch552-48/keyboard-ch552-48-2023.1-bottom.svg" width=600 /></p>
<p>I haven’t done much with PCBA.<br />
I found JLCPCB’s most accessible; since you can search what components they have, and they provide some documentation for the files you need to give them so they can assemble the keyboard for you.<br />
(Whereas, for other places, you have to send them the components?).</p>
<p>But, since this PCBA project was similar enough to the PCBA project I had done before, it wasn’t too much effort to figure out how to set this part up.</p>
<p>The main effort was figuring out how to reduce the PCBA costs. Some of the components that JLCPCB uses are “basic parts”, some are “extended parts”, and it costs a few dollars extra for each “extended part” you use. – So, the goal is to find and use the “basic parts” when you can.</p>
<p>I wasn’t 100% sure that the PCBA design would work. So, it was a relief to find that it worked without issue.</p>
<p>And with the CH552 being a low-budget MCU, the cost to get it manufactured was relatively low.</p>
<p>Overall, it might be that no particular step of this was far beyond my experience. But, it was a satisfying use of the PCB designing I’d been doing before, with a PCB design that had some interesting constraints.</p>]]></summary>
</entry>
<entry>
    <title>Experience with the Tweag Configuration Language as an End User</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-11-15-experience-with-the-tweag-configuration-language-as-an-end-user.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-11-15-experience-with-the-tweag-configuration-language-as-an-end-user.html</id>
    <published>2023-11-15T00:00:00Z</published>
    <updated>2023-11-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently had the chance at writing some keyboard firmware with <a href="https://github.com/semickolon/fak">semickolon’s
fak</a>. (e.g. <a href="https://github.com/rgoulter/fak/tree/rgoulter-keyboards-and-layouts/ncl/keyboards/rgoulter/ch552-44">keyboard
definition</a>,
<a href="https://github.com/rgoulter/fak/blob/rgoulter-keyboards-and-layouts/ncl/keymaps/split_3x5_3/rgoulter/keymap.ncl">keymap
definition</a>).</p>
<p>Fak uses <a href="https://nickel-lang.org/">tweag’s Nickel</a> for declarative definitions
of keyboards and keymaps. – Nickel is sophisticated type-safe configuration
language.</p>
<p>I’d first heard of Tweag in discussions around the Nix package manager, and how
people found the Nix expression language’s lack of types to add friction to
writing packages. I’d put Nickel in the same family as
<a href="https://github.com/dhall-lang/dhall-lang">dhall</a>, or
<a href="https://github.com/cue-lang/cue">cue</a>, or perhaps
<a href="https://github.com/google/jsonnet">jsonnet</a>. (Although of those, I have minor
experience with jsonnet, and briefly tried Dhall. I don’t have enough experience
to do a good comparison). – In a sense, these could all be described as “JSON
plus functions plus modules (plus types)”.</p>
<p>Here are some notes on that.</p>
<h2 id="context-what-kind-of-configuration-does-a-keyboard-use">Context: What Kind of Configuration Does a Keyboard Use</h2>
<p>Fancy keyboards allow the user to customize the keyboard’s behaviour.</p>
<p>One example is for users can change the keyboard’s keymap to some alternative
layout (such as Dvorak, or Colemak) on the keyboard itself; this reduces
friction, since then the computer can assume it’s using a typical QWERTY
keyboard, and the user doesn’t have to worry about changing the OS configuration
to use a keymap that might not be installed on the OS.</p>
<p>Anyway, the point is, in order to be able to change the keyboard’s behaviour,
you have to some way of the user describing that behaviour.</p>
<p>With <a href="https://docs.qmk.fm/">QMK firmware</a>, the approach previously had been that
you’d write out your keyboard definition and keymap definition in the C
programming language, and compile the firmware and flash this onto the keyboard.</p>
<p>C is a simple language; but with the C PreProcessor, it’s also <em>unrestrained</em> and formless.<br />
The formless nature can be a benefit for the creative expression of the end user (in terms of <em>how</em> the keymap is expressed),<br />
but I guess it’s a significant burden for the framework maintainers, presumably
since it makes changing interfaces of the framework difficult.</p>
<p>Hence, there’s been a move towards <a href="https://docs.qmk.fm/#/data_driven_config">data-driven
configuration</a>.</p>
<p>QMK’s <code>info.json</code> adds a layer of abstraction so that the relevant information
can be declared from a single source of truth; this data can then be used to
generate the code which QMK had been using before. The keyboard definitions
describe the keyboard’s pinout, and what features it supports / how it supports
them; and the keymap definitions describe the layout of keys. (e.g. <a href="https://github.com/rgoulter/qmk_firmware/blob/rgoulter-keyboards-and-layouts/keyboards/rgoulter/pykey40/info.json">my
info.json for
PyKey40</a>,
or for my <a href="https://github.com/rgoulter/qmk_firmware/blob/rgoulter-keyboards-and-layouts/keyboards/rgoulter/x_2/info.json">“X-2”
keyboard</a>).</p>
<p>And, as I described in my previous post that I’d rather read Rust than read C;
it’s easier to read someone else’s JSON than to read someone else’s C.</p>
<p>So. Custom keyboard firmware makes use of configurations for things like
keyboard definitions and keymap definitions.</p>
<h2 id="nickel">Nickel</h2>
<p>Roughly, my feeling is that Nickel is to JSON and YAML what Rust is to C and
C++.</p>
<p>C is ubiquitous, and bare bones. C++ has some features which make it seem nicer
for some use cases, but it’s got many rough edges. Rust is ‘complex’, but avoids
many of the previous rough edges, and has some really nice features.</p>
<p>JSON is ubiquitous, and bare bones. etc.</p>
<p>Technically, these “JSON plus functions plus modules” languages operate at a
different level than JSON.. but I think that since the goal is to declare a
particular configuration, I’d put them alongside each other when writing them.</p>
<p>Cosmetically, much of Nickel’s syntax does seem similar to Rust. (Whereas, say,
Dhall’s syntax seems similar to Haskell).</p>
<p>Since I was using Nickel to write configuration (as opposed to writing the
application which uses the configuration, or library modules for the
configuration), I didn’t poke around with Nickel’s typing or contracts.</p>
<h2 id="json-plus-functions-allows-for-clearer-configuration">“JSON plus Functions” Allows for Clearer Configuration</h2>
<p>With JSON, there’s no choice but to be explicit, unfactored, and undocumented.</p>
<p>Consider the value each of the additions to JSON in “JSON plus functions plus
modules (plus types)”.</p>
<p>Types can be useful for avoiding ‘illegal’ configurations, or otherwise
navigating code, even though technically types provide no value at runtime.</p>
<p>“Plus functions” implies “plus variables”. – I recall one way of describing
programming was: “means of naming, means of combining, and means of
abstraction”. That’s really the functionality “JSON plus functions” is getting
at.</p>
<p>“Plus modules” on top of that is (more/less) simply being able to break up one
big file into many smaller ones.</p>
<p>Without a means of naming/combining/abstracting, JSON values must be explicit
and can’t be factored. “list of numbers from 4 to 30” would be tedious to
describe in JSON, but may be useful to describe in USB keyboard configurations
(e.g. “values A-Z in the <a href="https://www.usb.org/sites/default/files/hut1_21.pdf">keyboard usage
page</a>”).</p>
<p>And for anything non-trivial, there’s always going to be a benefit in being able
to add documentation.</p>
<h2 id="configuration-languages-hamstrung-by-json">Configuration Languages Hamstrung by JSON</h2>
<p>These “JSON plus functions” languages do allow for a nicer experience, but I
think they’re also inherently limited by JSON’s success.</p>
<p>I like sum types, pattern matching and value destructuring. (And apparently
alongside pattern matching, I like tuples).</p>
<p>But since JSON values are either primitive (null, boolean, number, string) or an
array or an dictionary… there’s not really a natural way to express sum types
(or tuples) as JSON values. – Or languages like Go-lang also lack sum types; so
while you can parse JSON into Go values without too much difficulty, there’s
more friction trying to do the same with sum types.</p>
<p>I guess with sum types, you need to know all the variations of the type before
you can do meaningfully useful things with the value (check for invalid
variants, exhaustively check variants have been considered, etc.); the other
JSON values don’t have this constraint. Still, it’d be nice to somehow have sum
types in more places.</p>
<h2 id="it-lacks-tuples">It Lacks Tuples</h2>
<p>I’m not sure if it was a deliberate design decision motivated by a preference
for the explicit, or a distaste of implementing a tuple using heterogeneous
values in an array (or perhaps a limitation that lists can’t be heterogeneous?),
but I noticed that Nickel doesn’t support tuple types (in contrast to its other
fancy features).</p>
<p>e.g. the signature for <a href="https://nickel-lang.org/stdlib/std-array/#partition">Nickel’s
std.array.partition</a> is:</p>
<pre><code>partition : forall a. (a -&gt; Bool) -&gt; Array a -&gt; { right : Array a, wrong : Array a }</code></pre>
<p>whereas e.g. <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-List.html#v:partition">Haskell’s
Data.List.partition</a>
uses tuples:</p>
<pre><code>partition :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a]) </code></pre>
<p>Similarly,
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition">Rust’s Iterator’s partition returns a tuple</a>,
<a href="https://lodash.com/docs/4.17.15#partition">JavaScript’s lodash returns an array</a>,
<a href="https://package.elm-lang.org/packages/elm/core/latest/List#partition">elm’s List.partition returns a tuple</a>.</p>
<p>I don’t think the other “JSON plus functions” languages have tuples, either; so
it’s not Nickel’s so much as JSON’s limitation.</p>
<h2 id="smelly-syntax-lists-vs-arrays-and-recursive-vs-iterative">Smelly Syntax: Lists vs Arrays and Recursive vs Iterative</h2>
<p>In my use case, use of <code>nickel</code> was done at compile time on a powerful machine,
so I’m not concerned with memory consumption, nor too concerned about runtime.</p>
<p>My taste was <em>tickled</em> by that Nickel’s <code>std.array</code> has functions which are
geared towards list manipulation (e.g.
<a href="https://nickel-lang.org/stdlib/std-array/#fold_left">fold_left</a>), whereas the
structure is an array.</p>
<p>I found this at times awkward since AFAICT in Nickel, arrays don’t have syntax
to destructure them.</p>
<p>Rather, it’s natural to interact with lists recursively. A list is recursively
defined as either an empty list, or some item followed by a list. (e.g. the
<code>(list 1 2 3)</code> is <code>1</code> followed by <code>(list 2 3)</code>; and ultimately <code>(list 3)</code> is <code>3</code>
followed by the empty list). In Haskell, a list can be pattern-matched against
<code>x:xs</code> (the head of the list, followed by its tail).</p>
<p>Whereas, it’s natural to interact with arrays using loops and indices.</p>
<p>It’s natural for an expression-oriented language like Nickel to work with lists
(and it would be unusual for an expression-based language to have loop
constructs, I think); and JSON has arrays.</p>
<h2 id="configuration-complexity-is-about-how-you-use-it">Configuration Complexity is About How You Use It</h2>
<p>A blogpost I think about a lot is the <a href="https://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html">“Configuration Complexity
Clock”</a>.
Its picture tells 1,000 words; but roughly the point is that at each step, the
trade-offs look desirable for going from hard-coded values to a configuration;
and from a configuration to a DSL; and from a DSL to hard-coded values. –
Hence, don’t just accept “hard coded values bad” as a dogma, and take care when
adopting a configuration or a DSL.</p>
<p>What’s “too hard to read” is also dependent on the person.. <a href="https://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html">Steve Yegge’s
“Portrait of a
n00b”</a> discusses
that what’s considered acceptable to someone unfamiliar with the code may be
unacceptable to someone who is very familiar with the code. (Code that’s too
sparse or too verbose means changing the code takes more effort than it needs
to; whereas code that’s too dense or too terse also means changing the code
takes more effort than it needs to).</p>
<p>Adding functions to JSON provides a more powerful tool for configuration. But,
sometimes a “more powerful tool” is like a rocket-powered chainsaw: if you’re
not careful about how you’re using it, you might end up causing more damage than
it’s worth.</p>
<h2 id="types-arent-sufficient-to-describe-interfaces">Types Aren’t Sufficient to Describe Interfaces</h2>
<p>Something John Ousterhout’s <a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">A Philosophy of Software
Design</a> talks about is about
the distinction between a software module’s interface and its implementation.
Its interface is “what someone needs to know to use the module”. – He gives the
example of a bad interface: on Windows, you can’t delete a file if it’s open by
some process; this is ‘bad’ because in order to delete a file, you need to also
know that the file is not opened by any process (or which processes to close!).</p>
<p>The broader point is that a module is “complex” if its interface requires
superfluous details (the interface is over-specified), or if using the interface
also requires knowing implementation details not exposed as part of the
interface (the interface is under-specified).</p>
<p>PoSD makes the point that, similar to how Test-Driven Development emphasises the
benefits of writing unit tests before writing the implementation, it’s similarly
beneficial to write out a module’s documentation before writing the
implementation.</p>
<p>While types show what an implementation is capable of, documentation describes
what a module user needs to know in order to use the module (especially since
it’s often not practical or possible to describe with types).</p>
<p>To illustrate the point, looking at <a href="https://github.com/semickolon/fak/blob/8f3d29d3705a0e7b7cadcd1650c162fceaba7ced/ncl/fak/keymap.ncl#L26-L53">a rather gnarly Nickel excerpt in
fak</a>:</p>
<pre><code>let HoldTapKeyInterrupt = {
  decision | [| &#39;none, &#39;hold, &#39;tap |] | default = &#39;none,
  trigger_on | [| &#39;press, &#39;release |] | default = &#39;press
} in

let HoldTapKeyInterrupts = (
  # ...
  std.contract.Sequence [ Array HoldTapKeyInterrupt, ValidLength ]
) in

let HoldTapBehavior = let
  default_key_interrupts = std.array.replicate key_count {}
in {
  timeout_decision | [| &#39;hold, &#39;tap |] | default = &#39;hold,
  timeout_ms | Uint16 | default = 200,
  key_interrupts | HoldTapKeyInterrupts | default = default_key_interrupts,
  # ...
} in</code></pre>
<p>It’s not too hard to discern what values can be constructed for these types
(e.g. a <code>HoldTapKeyInterrupt</code> could be <code>{ "decision": "none", "trigger_on": "press" }</code>), but the types themselves aren’t sufficient to describe what the key
interrupt logic is, or how the values should be used. (For this code, there’s
<a href="https://github.com/semickolon/fak/tree/ebbb07c63721009c60d9951112d0587929657e3d#complex-hold-tap-behaviors">documentation
elsewhere</a>).</p>
<p>A <code>HoldTapBehavior</code> value could be expressed in JSON. having types <em>and
documentation</em> guide understanding.</p>
<p>Getting back to Nickel: it does support adding documentation by way of adding a
<code>doc</code> <a href="https://nickel-lang.org/user-manual/syntax/#metadata">metadata decoration to record
fields</a>. – But I guess I
wish I saw people say “types <em>and</em> documentation”. (Although perhaps by the time
you add enough features to the DSL, you’ve essentially just got hard-coded
values in a general purpose programming language).</p>
<h2 id="toolinglsp">Tooling/LSP</h2>
<p>I expect it will improve, but I found that the Nickel LSP server wasn’t quite
clever enough to go-to-definition for all the situations I tried it in.</p>
<h2 id="overall">Overall</h2>
<p>Overall, I was pleased with my experience.</p>
<p>“JSON plus functions” does let me apply creativity to describe a configuration
in a way that I find to be a good balance of cleverness and clarity.</p>
<p>There are more costs/risks to using Nickel compared to using plain JSON, but
there are also many benefits.</p>]]></summary>
</entry>
<entry>
    <title>Experience Report on Updating Keyboard Firmware Written in Rust</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-10-30-experience-report-on-updating-keyboard-firmware-written-in-rust.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-10-30-experience-report-on-updating-keyboard-firmware-written-in-rust.html</id>
    <published>2023-10-30T00:00:00Z</published>
    <updated>2023-10-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here are some notes on the experiences I had updating some keyboard firmware I had written in the Rust programming language.</p>
<h2 id="context-my-dive-into-the-mechanical-keyboard-rabbit-hole">Context: My Dive into the Mechanical Keyboard Rabbit Hole</h2>
<p>This was for keyboard firmware I’d written in Rust.</p>
<p>In mid-2020, I took my first steps into the mechanical keyboard hobby when I bought the BM40 keyboard.
I thought it looked pretty neat, since the keys were arranged in a symmetrical grid, and the keyboard was very small (so would require some skill to use). It was a decent keyboard to start with.</p>
<p>One of the nice things about the mechanical keyboard hobby is there are all sorts ways you can be creative with fancy keyboards. (e.g. from purchasing a different set of keycaps so that your keyboard looks nicer, trying out different styles of keyboard switches, etc.).</p>
<p>By the start of 2021, I was trying to design keyboard PCBs. (You can find the results of my playing around at github, <a href="https://github.com/rgoulter/keyboard-labs">rgoulter/keyboard-labs</a>). – The idea of trying to pack bells &amp; whistles onto a keyboard all within a pair of 100x100mm PCBs sounded like such a fun/interesting challenge.</p>
<p>These PCBs would need firmware written for them. Fortunately, almost all of the custom keyboards that enthusiasts buy allow customising the keyboard layout. And, the most popular by far was QMK, which is relatively easy to work with. I had enough experience to work with QMK. (I was the one who added HSRGB functionality to the BM40 rev1, which took about 3 days to merge; I also made a PR for BM40 rev2, which took just over 550 days to get merged…). I was able to use QMK to write firmware for my custom designs.</p>
<p>But, I also came across the <a href="https://github.com/teXitoi/keyberon">keyberon</a>, a library which supported writing keyboard firmware in Rust. Of course, I had to try it.</p>
<h2 id="mechanical-keyboard-firmware-options">Mechanical Keyboard Firmware Options</h2>
<p>For writing keyboard firmware, there are several popular options. There are probably others, but to my mind:</p>
<ul>
<li><p>QMK, by far the most popular and featureful.</p></li>
<li><p>ZMK, for keyboards which have Bluetooth.</p></li>
<li><p>KMK, which is built upon CircuitPython.</p></li>
<li><p>Keyberon, which uses Rust.</p></li>
</ul>
<p>My experience has been that QMK is by far the most practical one of these to use.</p>
<p>e.g. Although it’s much easier to iterate on firmware using CircuitPython (since “flash firmware” is as simple as “copy file to thumbdrive”), my experience with KMK was that its tap-hold functionality didn’t work well enough for home-row modifiers; which essentially makes the firmware impractical for small keyboards.</p>
<p>However. Keyberon is written in Rust, so I was curious to give it a try.</p>
<h2 id="general-impressions-of-rust-keyboard-firmware">General Impressions of Rust Keyboard Firmware</h2>
<p>It’s to QMK’s credit that it does such a great job at making writing keyboard firmware so accessible.
As QMK is a framework, you just bolt on your own parts to it (e.g. a keyboard pinout, if the keyboard isn’t already supported by QMK; and a keymap). You to can make use of a wide variety of software features (like layering, or tap-dance key behaviour), as well as hardware features (such as RGB LEDs, OLED screens, etc.). – Essentially, almost no embedded system knowledge is required to write a keymap, and very little is required to add on a keyboard definition.</p>
<p>As I understand it, Keyberon’s goal isn’t to compete with QMK. Its goal is to be a library for helping write keyboard firmware. (I think limiting the project scope is a good thing).</p>
<p>I reckon a downside to this is: it ends up that the keyboard firmware written in Rust that I’ve seen all have the feeling of “copied and pasted” to them. – The potential upside to this is all the keyboard firmware programs are small and easy to understand; but I can’t help but feel that everyone doing this copying-and-pasting is having to pay the cost of a learning curve in each instance.</p>
<h2 id="on-rust-vs-c">On Rust vs C</h2>
<p>I really like that Rust has features like Sum types (tagged unions), and destructuring.</p>
<p>I got the impression that in order to write Rust code, you still need to have a decent mental model for how C works. – e.g. when I’m writing TypeScript or Python, I don’t need to care about whether the values I’m using are concrete or abstract; however, in Rust, I’d frequently make the compiler point out that with the code I had written, the size of the value couldn’t be determined. To me, that kind of restriction is less confusing if I can think “oh, right, in C, you’d have to …”.</p>
<p>In terms of “reading others’ code”: I would rather read code written in Rust than code written in C. – Frequently, C’s CPP <code>#ifdefs</code> make its code complex to read, since it’s that much more you need to keep in mind when reading the code. It’s also harder to setup tooling for C such that you can use development-environment features like “jump to definition”.</p>
<p>It’s really useful to be able to rely on code others have written. I wouldn’t want to set up a C project to depend on others code. (It’s more straightforward to add a dependency to a Rust project than to a C project). But, especially for this use case, building on QMK allows firmware which does more, with a wider variety of peripherals, than writing Rust code would. To an extent, I’d think the much of the code that gets into QMK also benefitted from there being more embedded firmware code in C than in Rust.</p>
<p>It’s difficult to write Rust code.<br />
It can be difficult to correctly express lifetimes, or generic trait bounds. A strict compiler which adds friction is great for <em>maintaining</em> code, but it makes just shitting out code much harder. (And sometimes “shitting out code” is what you want to be doing).</p>
<p>In terms of “risk of writing code that’s too clever”: If someone’s writing code in C that’s <em>too clever</em>, one mechanism they have to use is the C Pre-Processor. Rust’s macros can be very similar; but Rust also has other ways of writing code that’s <em>too clever</em>.</p>
<p>Rust is also a complex language. I don’t want to point to any one thing and say “this is too hard to understand”; but with so many sophisticated features, it can be difficult to have a good intuition for how Rust’s features interact with each other. – So if you’re coming back to a codebase after some months of not having used Rust, it can take time to recall a good mental model.</p>
<p>That QMK is much more practical to use than the other keyboard firmware alternatives is a testament to just how much work has gone into making the project accessible.</p>
<h2 id="earlier-iterations-of-my-rust-firmware">Earlier Iterations of my Rust Firmware</h2>
<p>My Rust keyboard firmware has been a project which I return to maintain once or twice a year. I initially wrote it, largely by copy-pasting from similar codebases. As a sideproject / hobby repo, each iteration was an opportunity for me to have fun, and make the code more sophisticated. e.g.:</p>
<ul>
<li><p>by refactoring the code by breaking up a single file into several modules,</p></li>
<li><p>adding firmware code for a different keyboard,</p></li>
<li><p>adding Nix support code, so that it’d be easier to build,</p></li>
</ul>
<p>I mean, each iteration was a chance to take something that worked, and add onto it a bit so the code was less messy. – “The first time, as a scientist; the second time, as an engineer”.</p>
<h2 id="updating-the-code">Updating the Code</h2>
<p>I had tried (and failed) to update the code’s dependencies back in 2023 May.</p>
<p>My expectation when updating dependencies is: if I can bump the dependencies and there are no compilation errors, I expect the code to work as it did before.<br />
If I run into compilation errors (e.g. function signatures or types changed), then I’ll have to look to see what changed, figure out the smallest reasonable change to get the code to compile, and hope that works.</p>
<p>I found difficulty in updating 3 things: the version of the realtime framework (RTIC), the version of the HAL (API for driving the hardware), and the toolchain version. – When I updated <em>just that</em>, then the code might compile but the firmware wouldn’t work as it did before.</p>
<p>When I updated the toolchain, the code compiled but didn’t run the same way it had before. – This was frustrating and unfortunate.<br />
But, given that I was able to update the toolchain after resolving the other two problems, my best understanding is: my code was wrong, and happened to work with the old compiler version.</p>
<p>Similarly, when I tried updating the HAL dependency, the code would compile but wouldn’t result in a working keyboard; ditto for the RTIC.<br />
This was frustrating and unfortunate.<br />
But in this case, I think the problem was more clearly my bad code.<br />
– I was using the wrong kind of Timer in the firmware. A closer read of the documentation indicated “if the system runs above such and such frequency, then don’t use this Timer”.<br />
If there’s any fault of the dependencies, it’s apparently that they happened to previously be lenient enough to run bad code.</p>
<p>I’d put this frustrating experience up to the difficulty of embedded development.</p>
<p>That said, I will say I also ended up replacing the dependency of the USB HID keyboard from Keyberon’s implementation to <a href="https://docs.rs/usbd-human-interface-device/latest/usbd_human_interface_device/">usbd-human-interface-device</a>’s.<br />
For one, <code>usbd-human-interface-device</code> implemented support for media keys (play/pause, next track, etc.) which Keyberon didn’t.<br />
But I’d ran into a bug related to sending USB HID reports when using Keyberon’s implementation, which went away when using <code>usbd-human-interface-device</code>’s.</p>
<h2 id="things-i-found-difficult-about-embedded-development">Things I Found Difficult about Embedded Development</h2>
<h3 id="deploying-the-program-is-harder">Deploying the Program is Harder</h3>
<p>The easiest kind of deployment action is to run software on some Linux machine that you control. e.g. To deploy a web server, copy the program over, and then run the program there.</p>
<p>Running a program on an embedded device is somewhat more involved.</p>
<p>For a newbie, there are many things about this which are quite confusing.</p>
<p>Fortunately, it has become much easier in the time since I started. With UF2 bootloaders, flashing the firmware onto a device is as simple as copying a file to a thumbdrive. – Albeit, compiling the UF2 file is not totally trivial; and you still have to flash a UF2 bootloader onto the device.</p>
<h3 id="printf-debugging-harder-to-set-up">Printf Debugging Harder to Set Up</h3>
<p>A staple of debugging is “printf debugging”. You put a bunch of <code>print</code> statements in your code, and use those as evidence to lead you to a better understanding of how a system works.</p>
<p>With embedded devices (even very powerful ones), it’s … not quite that simple.</p>
<p>Ideally, with USB devices, you can somehow set up some kind of CDC serial console and output messages over that. But, if you’re at the level of copy-paste coding, this isn’t so simple to set up. (… and doesn’t help if you mess up something in the firmware before it gets to that point).</p>
<p>I saw <a href="https://probe.rs/">probe-rs</a> puts in a bunch of effort to make debugging embedded software much easier, to the extent where you can just run <code>cargo embed</code> and you <em>can</em> have this printf debugging. – But, you still have to figure out how to setup a probe device, and connect that to your device, etc.</p>
<h3 id="the-small-details-might-really-matter">The Small Details Might Really Matter</h3>
<p>In one sense, programming is about structuring complexity so that you only need to pay attention to the things that are important to you (and can ignore the things that aren’t).</p>
<p>But I’d say with embedded development, it’s more likely that small details will be significant, compared to writing an HTTP API server.</p>
<p>One mistake I made was constructing a USB class after I’d constructed a USB device; this caused the program to crash, and it wasn’t obvious to me as to why. (Well, once I got the SWD connected and printf debugging working, <em>then</em> it was obvious what was happening).</p>
<h3 id="getting-a-good-mental-model-of-rust">Getting a Good Mental Model of Rust</h3>
<p>I think it’s widely accepted that when learning Rust, you’ll be struggling to get code to compile. (Even code which would be acceptable in memory-managed languages like TypeScript or Python). Especially with concepts related to ownership and lifetimes.</p>
<p>More than once, I’d encounter difficulty trying to convince the compiler that my code was fine; or I might have some intuition that what I wanted to try was okay, but would have difficulty expressing that in how Rust actually worked. – I do believe many experienced Rust developers will try and avoid having to fight the compiler when they get into these situations.</p>
<h2 id="fancy-tech-that-helped">Fancy Tech that Helped</h2>
<h3 id="llms">LLMs</h3>
<p>I used LLMs both for code-assistance in the IDE, as well as asking questions to a chat bot.</p>
<h4 id="code-suggestions-in-the-editor">Code Suggestions in the Editor</h4>
<p>Because the code for keyboard firmware so naturally reflected the structure of the keyboard’s schematic, the kind of code I was writing was very easy for GitHub’s CoPilot to predict. – e.g. you might leave a comment saying “the column pins are PA3, PB7, PB8, PA13, …”, and then GitHub CoPilot is able to predict what you’ll want <code>let col_pins =</code> to match against. This effectively removes a lot of drudge; rather than having to type 30-50 chars of what you know, you only have to type about 5 or so.</p>
<p>CoPilot didn’t get it right 100% of the time; but, with a nudge in the right direction, it was able to suggest exactly the code I wanted to write. – Even with having to check the output &amp; adjust, overall, it was beneficial to use CoPilot.</p>
<p>CoPilot was also very useful for writing rote bits of code which I’d describe as “the kind of stuff you’d seach ‘how do I do this’ and copy-paste” (if you’re new to the language/library) or perhaps “the kind of thing you’d write without thought” (if you’re familiar with the language/library).<br />
– Perhaps a <em>downside</em> being, if you’re not familiar with best practices, nor idioms of what the code <em>should</em> be, then maybe you’re just writing bad code.</p>
<p>(I also ran into some tooling problems: there were some contexts where CoPilot didn’t make suggestions, and some contexts where “use CoPilot’s completion” conflicted with other bindings).</p>
<h4 id="asking-llms-for-help">Asking LLMs for Help</h4>
<p>I liked the idea that Go-lang made for a good language to use for side-projects, since the language strives to be simple to write. This reduces the cost of coming back to the project after months of not having touched the technology; whereas with a more complicated language, you have more to recall.</p>
<p>Rust is a complex language. There are going to be things that won’t be obvious.</p>
<p>This is the kind of problem StackOverflow is good for. You’re likely to have the same questions as other people, and ask “how can I…?” or “why can’t I combine this and that…?”.</p>
<p>I tried asking ChatGPT for help whenever I was stuck with something.</p>
<p>The results were hit and miss.</p>
<p>When I got a good result, it would provide code snippets tailored closely to what I’d asked for.</p>
<p>When I got bad results, the LLM would confidently tell me “oh, this is how this works”, and it felt the <a href="https://www.youtube.com/watch?v=oN2_NarcM8c">Abbott and Costello joke about 7x13 = 28</a>. – The joke is funny because I know basic multiplication; but I wonder what the joke is like if you have no understanding of the domain.</p>
<p>Ultimately, at the moment, I think this leaves only a few places where I’m comfortable asking LLMs stuff: domains where inaccuracy leaves me no-worse-off than the average person; and domains where I know enough to verify the LLM output to make use of it.</p>
<h3 id="nix">Nix</h3>
<p>Probably <code>rustup</code> with a toolchain file and <code>Cargo.lock</code> are sufficient to reproduce the same binaries/behaviour that had worked before. I used Nix to take care of this, instead.</p>
<p>The additional benefits I got from Nix:</p>
<ul>
<li><p>By declaring the tools I used as part of a nix shell, I didn’t have to worry about how to install these programs.
With embedded development, there were several tools which were useful for working with the binaries (such as <code>probe-rs</code> or <code>st-write</code>).</p></li>
<li><p>I found it nice to have the outputs I wanted declared as a package.</p></li>
</ul>
<p>I’m able to trust that a Nix package isn’t affected by a dirty environment in a way that’s difficult to achieve with a Makefile.</p>
<h3 id="just-task-runner">Just (Task Runner)</h3>
<p>One thing I don’t see eye to eye on with QMK is it has its own bespoke <code>qmk</code> CLI (which both depends on, and is intended for use within the qmk_firmware repository; you can’t use <code>make</code> without having <code>qmk</code> installed).</p>
<p>One DX improvement I value from the <code>qmk</code> cli is its <code>qmk flash</code>, which has a “do what I mean” feel to it, in that it waits for the expected device to become available, and then will flash the firmware appropriately.</p>
<p>While <code>Makefile</code>s are suitable for describing how files are to be built, <code>justfile</code>s are suitable for describing tasks to be run. So, I added a <code>justfile</code> with a convenience command to help me flash the firmware. It’s a small thing, but it improved the DX.</p>
<h3 id="lsp">LSP</h3>
<p>https://grugbrain.dev/#grug-on-type-systems</p>
<blockquote>
<p>grug very like type systems make programming easier. for grug, type systems most value when grug hit dot on keyboard and list of things grug can do pop up magic. this 90% of value of type system or more to grug</p>
</blockquote>
<p>LSP means it’s easier for “hit dot on keyboard and list of things grug can do pop up magic”.</p>
<p>Also useful is: being able to show the type, and being able to show the documentation for the type.</p>
<p>(Albeit, for some reason, the LSP in Helix was better able to find information in the RTIC framework’s tasks than the LSP I used with Emacs could. Perhaps this has to do with proc macros or some other thing.).</p>]]></summary>
</entry>

</feed>
