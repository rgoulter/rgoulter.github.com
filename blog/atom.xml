<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Richard Goulter's Blog</title>
    <link href="http://www.rgoulter.com/blog//atom.xml" rel="self" />
    <link href="http://www.rgoulter.com/blog/" />
    <id>http://www.rgoulter.com/blog//atom.xml</id>
    <author>
        <name>Richard Goulter</name>
        <email>richard.goulter+blog@gmail.com</email>
    </author>
    <updated>2023-12-21T00:00:00Z</updated>
    <entry>
    <title>2023-12-21-notes-on-building-wch-ble-ch592-evt-exam-with-bare-makefile</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-12-21-notes-on-building-wch-ble-ch592-evt-exam-with-bare-makefile.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-12-21-notes-on-building-wch-ble-ch592-evt-exam-with-bare-makefile.html</id>
    <published>2023-12-21T00:00:00Z</published>
    <updated>2023-12-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here are some notes from tinkering with the <a href="https://github.com/WeActStudio/WeActStudio.WCH-BLE-Core">WeAct Studio BLE Core Board</a>.</p>
<h3 id="its-not-used-in-many-designs">It’s Not Used in Many Designs</h3>
<p>My interest in the board comes from my interest in custom mechanical keyboard designs.<br />
– The best part of ‘free and open source’ is the “gratis” part.<br />
But the “libre” part is neat, too: it’s much easier to realize an interesting keyboard design if all you need to do is iterate on a keyboard design someone else has made.</p>
<p>I’ve never tried designing a Bluetooth keyboard.<br />
The sour grapes explanation is that Bluetooth devices are finicky to use. (Which is true).<br />
What most hobbyists do for Bluetooth keyboards is use Bluetooth-powered devboards like the nice!nano, and use ZMK firmware. – TBH part of why I’m not interested in this devboard is it costs over 20 USD. (And it’s most common in split keyboards, which’d need one for each side!).</p>
<p>I recently picked up a WeAct Studio BLE Core board, ordered from AliExpress.<br />
(I’ve used a few different devboards from WeAct Studio in several of my keyboard PCB designs; including WCH MCUs).<br />
The BLE core board has designs for the different MCUs: CH573, CH582, CH592.<br />
In contrast, this devboard costs $2.</p>
<p>But despite it being such a cheap board, I can’t find any designs which use this board.</p>
<p>Some notes on what I could find:</p>
<p>The <a href="https://github.com/joric/nrfmicro/wiki/Alternatives#ch582">Alternatives wiki page on joric’s nrfmicro repo</a>
describes the CH582 as:</p>
<blockquote>
<p>QMK has a CH582 port! It has BLE and there’s a dev board for it on Aliexpress for about 2 bucks. That is, if you’re willing to experiment since, as far as I’m aware, no keyboard has been designed with it and there’s not a lot of users yet. [ZMK not supported.]
… Last I looked, datasheets were basically “sorry, not documented” on the registers for BLE hardware. And 32KB of RAM on the CH582F would definitely be a challenge.</p>
</blockquote>
<p>Regarding “low RAM an issue” semickolon (who authored FAK firmware for the CH552 MCU) <a href="https://www.reddit.com/r/ErgoMechKeyboards/comments/18aekwm/comment/kbz35tc/">commented that the chip’s BLE only uses 4KB RAM, and that FAK had about 1KB RAM</a>. (He also mentions he’s got a keyboard working with some firmware he’s building for the chips).</p>
<p>The datasheets indeed omit documentation for the registers for the BLE hardware.</p>
<p>FWIW, I did see some BLE keyboards using these WCH chips on OSHWHub such as <a href="https://oshwhub.com/cansong/ch579_keyboard_v0-1">cansong’s ch579 keyboard</a>, which points to <a href="https://oshwhub.com/JokerAlon/ch579m-64keyboard">JokerAlon’s ch579m</a>. Albeit, the readmes for these aren’t in English. – The schematics are available, at least.</p>
<p>Albeit, at the time of writing, there really aren’t many English search engine results for CH592. Nor CH58x. Nor CH57x.<br />
The keyboards above seem to be row-stagger, and with big spacebars. (The big spacebars make it easier to design a PCB, but don’t make for a good keyboard. – I do recall seeing boardsource.xyz’s solution to this for their <a href="https://www.reddit.com/r/MechanicalKeyboards/comments/t1c5pl/technikable_gb_is_live_on_boardsourcexyz_wireless/">technikable ble ortho</a> was to omit the 2 keys in the bottom corners of each side..).</p>
<p>I wasn’t aware of it before, but both the wiki page above (and the reddit comment) point to <a href="https://github.com/O-H-M2/qmk_port_ch582">O-H-M2’s port of QMK for CH582</a>. (Looking at the port a bit: it retains upstream QMK’s codebase unchanged, and adds some platform-specific code for CH582).<br />
(There are keyboards listed in this; one seems to be a giant handwired ortho, the others are either macropads/numpads, or row-staggered with big spacebars).<br />
The default branch name is <code>via</code>; the readme mentions via functionality is implemented. (I don’t use via/vial, but seems it’s useful for many).</p>
<p>On GitHub, <a href="https://github.com/openwch/ch592">OpenWCH provides EVTs with Examples and SDKs for CH592</a> (and other chips). (Whereas, <a href="https://github.com/SoCXin/CH552.git">CH552 is in the SoCXin org</a>). – These examples include a BLE HID “keyboard” (it periodically sends a HID keyboard report, but doesn’t read GPIO pins).<br />
– So, there is working code, and a README PDF(!) describing how to run the example.. this PDF describes to use <a href="http://www.mounriver.com/download">MounRiver Studio</a>.</p>
<p>Using MounRiver Studio works (at least for building these EVT Examples; I didn’t try flashing from MounRiver).</p>
<p>I saw that the <a href="https://github.com/WeActStudio/WeActStudio.WCH-BLE-Core">WeAct BLE repo</a> included <code>Makefile</code>s for its code (copied from the EVT).<br />
Copy-pasting the comment at the header of the file into a translate service: “generated, do not modify”.<br />
Oh no.</p>
<p>That’s … not a promising sign.</p>
<p>Fortunately, the <a href="https://github.com/O-H-M2/qmk_port_ch582/blob/via/README.md#developers">QMK port to CH582’s readme</a> has instructions which mention downloading the MounRiver Studio toolchain and using <code>cmake</code>/<code>make</code>.</p>
<h2 id="toolchain-building-the-ch582-port-of-qmk">Toolchain: Building the CH582 Port of QMK</h2>
<p>I’m running NixOS, and one of the downsides of using NixOS is it can be difficult to run binaries distributed in tarballs.</p>
<p>MounRiver Studio and its toolchain is distributed as binaries in a tarball.</p>
<p>I was able to come up with some Nix packages for the <code>libmcuupdate.so</code> distributed in the toolchain tarball, and the GCC toolchain:<br />
https://github.com/O-H-M2/qmk_port_ch582/commit/40828b8361bbc711fb7c7af00374eea565f75d2f<br />
(I <a href="https://github.com/NixOS/nixpkgs/blob/54aac082a4d9bb5bbc5c4e899603abfb76a3f6d6/pkgs/development/compilers/gcc-arm-embedded/12/default.nix">adapted another Nix package which downloads GCC in a tarball</a>).</p>
<p>With that, I was able to build the QMK port for CH582 built.</p>
<p>Oh. Wait. Taking a look at the <code>--version</code> for the toolchain MounRiver Studio distributes:</p>
<pre><code>$ riscv-none-embed-gcc --version
riscv-none-embed-gcc (xPack GNU RISC-V Embedded GCC, 64-bit) 8.2.0
Copyright (C) 2018 Free Software Foundation, Inc.</code></pre>
<h2 id="risc-v-toolchain">Risc-V Toolchain</h2>
<p>Links to things:</p>
<p>The old <a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack">riscv-none-embed-gcc-xpack</a>,
and <a href="https://github.com/sifive/riscv-gcc">SiFive’s riscv-gcc</a>.</p>
<p>And the newer <a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack">riscv-none-elf-gcc-xpack</a>.
And this seems related:
https://github.com/riscv-collab/riscv-gnu-toolchain.</p>
<p>The change from <code>riscv-none-embed-gcc</code> to <code>riscv-none-elf-gcc</code> is mentioned in the <a href="https://xpack.github.io/blog/2022/05/14/riscv-none-elf-gcc-v11-3-0-1-released/">xPack riscv gcc 11.3 release notes</a>.</p>
<p>Trying these upstream xpack riscv toolchains with the qmk port for ch582.. for one, <code>TOOLCHAIN_PREFIX</code> needs to be set to <code>risc-none-embed</code> if using the older GCCs. But, I did need to make a couple of other changes:</p>
<p>The MounRiver toolchain has an extra param <code>highcode-gen-section-name</code> that the xpack toolchains don’t have:
https://github.com/O-H-M2/qmk_port_ch582/commit/347e15458be15a714494d0088fa77243f62e7009</p>
<p>And, as the <a href="https://xpack.github.io/blog/2022/05/15/riscv-none-elf-gcc-v12-1-0-1-released/#risc-v-isa-updates">xPack riscv gcc 12.1 release notes explain</a>, errors like <code>extension</code>zicsr’ required<code>can be fixed by adding</code>_zicsr` to the arch: https://github.com/O-H-M2/qmk_port_ch582/commit/dafb73132b6642ac70322239673060fe56d0b9b9</p>
<p>(I didn’t try <a href="https://github.com/O-H-M2/qmk_port_ch582/tree/2dde4b4777d2e91abe0b96c91b64f3fea5cd7ecb/utils">the toolchain that’s checked into the git repo</a>; but seeing stuff like that makes me wonder if the embedded developers are doing okay).</p>
<h2 id="building-the-examples-outside-mounriver-studio">Building the Examples Outside MounRiver Studio</h2>
<p>The EVT Examples are supplied with only a MounRiver Studio project file.</p>
<p>Since I’m not sure what works and what doesn’t work (in terms of how to compile the examples outside of MounRiver), it’s easiest to start from something that works. – Building it in MounRiver works, which generates some Makefiles.</p>
<p>Using that, I adapted a Makefile with the same compiler flags to get a Makefile which produced a working build.<br />
(Or, honestly: I’d copied the makefile from the broadcaster example, but that set different <code>-D</code> defines, which didn’t play nicely with the BLE HID example, and it took me some time to notice why my Makefile wasn’t producing a working build of the example).</p>
<p>Anyway.</p>
<p>I copied the BLE HID_Example example, put it together with a standalone Makefile, and some Nix files to provide the toolchain, and shared it in this repo: https://github.com/rgoulter/ch592-ble-hid-keyboard-example</p>
<h2 id="flashing-the-firmware">Flashing the Firmware</h2>
<p>Flashing the CH592 is the same as flashing the CH552. You can enter the bootloader by holding the BOOT button when plugging the board into the computer, and then use <a href="https://github.com/ch32-rs/wchisp">ch32-rs’ wchisp</a> to flash the firmware. (On Windows, I’d had difficulty using <code>wchisp</code>; but the official programs from WCH worked on Windows when I tried with the CH552).</p>]]></summary>
</entry>
<entry>
    <title>Die Another Day not as Bad as I Remembered</title>
    <link href="http://www.rgoulter.com/blog//posts/narrative/2023-12-14-die-another-day-not-as-bad-as-i-remembered.html" />
    <id>http://www.rgoulter.com/blog//posts/narrative/2023-12-14-die-another-day-not-as-bad-as-i-remembered.html</id>
    <published>2023-12-14T00:00:00Z</published>
    <updated>2023-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Still slowly re-watching through the James Bond movies.</p>
<p>Just finished “Die Another Day”, Pierce Brosnan’s last Bond movie.
My wife likes him as Bond as he’s the most handsome James Bond.</p>
<p>I was surprised that the movie wasn’t as bad as I had remembered it.<br />
Perhaps partly that’s because upon rewatching the other Brosnan movies, I realise they’re not as good as I remember them.</p>
<p>I had pretty much remembered the broad plot: something about Bond in North Korea, at some fancy medical clinic in Cuba, fencing in England, and then in some icy location with an orbital beam of death, and somehow the climax of the movie is on a plane. And something about the bad guy being “DNA swapped” of a Korean guy.</p>
<p>It’d be a bad idea to judge the Bond films by the worst moments (seeing as how I think what lingers is generally the positive parts), but “Die Another Day”’s worst parts are definitely its early-2000s CGI.<br />
The CGI happens to work for the invisible car.. but it <em>really</em> doesn’t work for a part in the movie where Bond is para-surfing away on the waves from a collapsing ice shelf. – It’s stupid, but not fun.</p>
<p>Whereas what I didn’t remember all that much was the spy-car-vs-spy-car car chase.. I think maybe in the open tundra this car chase was a bit dull; but I thought it surpassed the bar for “rule of cool” by the time the chase went through the hallways of the ice hotel.</p>
<p>Putting it that way.. I think the film’s premise sounds pretty cool: James Bond has to face off against a villain who has transformed himself into a mirror image of James Bond (gadgets and spy car included).</p>
<p>I think the Bond films are the at their most engaging when there’s some tangible threat that Bond has to track down and stop. (Whereas, without a known threat, it just feels like ‘stuff happens’, and Bond moves from one place to the next). – In “Die Another Day”.. although the supervillain’s doom weapon comes as a late surprise, throughout the film Bond always has a clear target and makes progress towards it. Good.</p>
<p>That said, there’s something very cringeworthy about the film’s premise, too. The bad guy race-swaps himself from Korean to being British. … It’s just really weird.</p>
<p>Some parts of the film are fun. I love the gag where Moneypenny finally gets to make out with Bond.. only for it to be revealed that this was just in the computer simulation. (The gag doesn’t really fit well in the plot; but it’s such a great gag).</p>
<p>Halle Berry’s character is pretty cool in this. She competently does a bunch of spy stuff, doesn’t overshadow Bond, and doesn’t mess things up. – My wife’s usual disapproval for the way Bond women are written is “they’ll have sex with Bond and then turn stupid” (where perhaps the best example of this was the Bond girl in “License to Kill”; if not “Diamonds are Forever”).</p>]]></summary>
</entry>
<entry>
    <title>Experience Designing a Keyboard PCB</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-11-26-experience-designing-a-keyboard-pcb.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-11-26-experience-designing-a-keyboard-pcb.html</id>
    <published>2023-11-26T00:00:00Z</published>
    <updated>2023-11-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I designed a <a href="https://github.com/rgoulter/keyboard-labs/releases/tag/ch552_48-rev2023.1">keyboard PCB</a>, which I’m calling “CH552-48”. (It uses the CH552 MCU, and it has 48 keys).</p>
<p>This was
I have designed <a href="https://github.com/rgoulter/keyboard-labs#keyboards">other keyboard PCBs</a>,
but I’m particularly pleased with this one.<br />
The keyboard PCBs I’ve designed fall into two kinds: those that use a development board (and are relatively easy to solder by hand), and those that are intended to be manufactured with “PCBA”.<br />
However, the devboard-based designs were pretty easy to design; and while I found the PyKey40 tricky to design (I found it quite tricky to fit the MCU between the keyboard switches; an ortholinear keyboard doesn’t allow for much space!), I was more/less modifying an existing PCB design.</p>
<p>To be honest.. the keyboard PCB designs I’ve done aren’t really aiming for “great keyboard” so much as they’re aiming for “interesting PCB to design”.<br />
e.g. designing a split keyboard where each half is smaller than 10x10cm may not make for a ‘great’ keyboard, but the design constraint made it really fun to design.<br />
The “X-2 Lumberjack Arm” is a pretty good keyboard. I think it’s visually very striking. At the time I designed it, there weren’t many Arm-powered (ortholinear) keyboards that could be bought off-the-shelf.<br />
And PyKey40 is also a good keyboard.. but, I had thought it’d be an interesting challenge to try and cram the fully-featured PyKey60 into the smaller 4x12 grid.<br />
– I do like that idea “first time you do something, it’s as a scientist; the second time, as an engineer, but by the third time it’s as a technician”.</p>
<p>I wanted to design the CH552-48 after I came across the <a href="https://github.com/semickolon/fak">fak firmware</a>. Fak firmware was written for the CH552, which has the advantage of being much cheaper than the RP2040 (even if it’s not as powerful).</p>
<p>Something that made this an interesting or constrained PCB to design was that the CH552T MCU only has 14 GPIO pins.<br />
A keyboard uses the GPIO pins for scanning which keys have been pressed. Typically, 1 pin is used for each row and each column of the keyboard matrix. e.g. a 60-key keyboard arranged in 5 rows of 12 columns would typically use 17 pins.<br />
I have seen other projects use the CH552 for keyboards, but these tend to be keyboards with a very low number of keys, such as using it for a numpad, or using a CH552 for one half of a small split keyboard.<br />
I figured that 14 pins allows for 7 rows of 7 columns, or about 49 keys.</p>
<p>Obviously, a square keyboard wouldn’t make for a useful desktop computer keyboard.. but instead, the 7x7 matrix could be the ‘logical’ matrix, and I could arrange the 48 keys in 4 rows of 12 columns. I thought this was pretty neat.</p>
<p>I designed the <a href="https://github.com/rgoulter/keyboard-labs/releases/tag/ch552_44-rev2023.1">CH552-44</a> first, which more/less takes the same shape as the <a href="https://github.com/rgoulter/keyboard-labs/releases/tag/pico42-rev2023.1">Pico42 keyboard</a> which I had designed earlier as a workaround to make use of keyboard cases I borked the design for. (The Pico42 in turn does itself bear close resemblance to the <a href="https://github.com/rgoulter/keyboard-labs#x-2-5x12-ortholinear-arm-powered-adaptation-of-peejs-lumberjack-pcb">X-2 “Lumberjack Arm”</a> keyboard I’d designed earlier..).</p>
<p>It made sense to start with CH552-44 as a proof-of-concept since it would be solderable with only through-hole components, which are <em>very</em> easy to solder.</p>
<p>In designing the CH552-44, I had to come up with some scheme to actually route this logical 7x7 matrix laid out on a physical 4x12 grid.<br />
When the logical matrix is the same size as the physical matrix, it’s straightforward to connect each of the column pins together.<br />
But with a mismatch between the logical matrix and the physical matrix, some complexity was inevitable.</p>
<p>Keyboard designs, especially ortholinear keyboard designs, involve a lot of patterns and repetition.
My experience is that early on when routing the traces for the PCB, it might not be clear what the patterns for the traces <em>should</em> be; but once it does become clear, then routing the traces does become straightforward.</p>
<p>This part of PCB design can be very fun. – In a way, it tickles the same part of the brain that some parts of Factorio do: in Factorio, you need to connect certain outputs to certain inputs, and the challenge is in how to physically arrange the systems as part of a larger factory; ideally in an organised manner, without too much spaghetti. Hobbyist PCB design is exactly the same.</p>
<p>Compare the traces for the Pico42:</p>
<p><img src="https://raw.githubusercontent.com/rgoulter/keyboard-labs/master/docs/images/keyboards/pico42/keyboard-pico42-2023.2-bottom.svg" width=600 /></p>
<p>with those of the CH552-44:</p>
<p><img src="https://raw.githubusercontent.com/rgoulter/keyboard-labs/master/docs/images/keyboards/ch552-44/keyboard-ch552-44-2023.1a-bottom.svg" width=600 /></p>
<p>It’s not an <em>extreme</em> difference, but the CH552-44 does feel like it’s got busier streets and city blocks.</p>
<p>Anyway. Once I’d received these CH552-44 PCBs, and checked that they worked with the CH552 devboard I was using, the next step I wanted to try was to make a PCBA version of the design.</p>
<p>This itself wasn’t too hard, either.</p>
<p>I looked at the devboard’s schematic, saw what parts of that I was using, and replaced the devboard in my schematic with those parts.</p>
<p>Overall, not too much needed to be changed for the PCBA design:</p>
<p><img src="https://raw.githubusercontent.com/rgoulter/keyboard-labs/master/docs/images/keyboards/ch552-48/keyboard-ch552-48-2023.1-bottom.svg" width=600 /></p>
<p>I haven’t done much with PCBA.<br />
I found JLCPCB’s most accessible; since you can search what components they have, and they provide some documentation for the files you need to give them so they can assemble the keyboard for you.<br />
(Whereas, for other places, you have to send them the components?).</p>
<p>But, since this PCBA project was similar enough to the PCBA project I had done before, it wasn’t too much effort to figure out how to set this part up.</p>
<p>The main effort was figuring out how to reduce the PCBA costs. Some of the components that JLCPCB uses are “basic parts”, some are “extended parts”, and it costs a few dollars extra for each “extended part” you use. – So, the goal is to find and use the “basic parts” when you can.</p>
<p>I wasn’t 100% sure that the PCBA design would work. So, it was a relief to find that it worked without issue.</p>
<p>And with the CH552 being a low-budget MCU, the cost to get it manufactured was relatively low.</p>
<p>Overall, it might be that no particular step of this was far beyond my experience. But, it was a satisfying use of the PCB designing I’d been doing before, with a PCB design that had some interesting constraints.</p>]]></summary>
</entry>
<entry>
    <title>Experience with the Tweag Configuration Language as an End User</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-11-15-experience-with-the-tweag-configuration-language-as-an-end-user.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-11-15-experience-with-the-tweag-configuration-language-as-an-end-user.html</id>
    <published>2023-11-15T00:00:00Z</published>
    <updated>2023-11-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently had the chance at writing some keyboard firmware with <a href="https://github.com/semickolon/fak">semickolon’s
fak</a>. (e.g. <a href="https://github.com/rgoulter/fak/tree/rgoulter-keyboards-and-layouts/ncl/keyboards/rgoulter/ch552-44">keyboard
definition</a>,
<a href="https://github.com/rgoulter/fak/blob/rgoulter-keyboards-and-layouts/ncl/keymaps/split_3x5_3/rgoulter/keymap.ncl">keymap
definition</a>).</p>
<p>Fak uses <a href="https://nickel-lang.org/">tweag’s Nickel</a> for declarative definitions
of keyboards and keymaps. – Nickel is sophisticated type-safe configuration
language.</p>
<p>I’d first heard of Tweag in discussions around the Nix package manager, and how
people found the Nix expression language’s lack of types to add friction to
writing packages. I’d put Nickel in the same family as
<a href="https://github.com/dhall-lang/dhall-lang">dhall</a>, or
<a href="https://github.com/cue-lang/cue">cue</a>, or perhaps
<a href="https://github.com/google/jsonnet">jsonnet</a>. (Although of those, I have minor
experience with jsonnet, and briefly tried Dhall. I don’t have enough experience
to do a good comparison). – In a sense, these could all be described as “JSON
plus functions plus modules (plus types)”.</p>
<p>Here are some notes on that.</p>
<h2 id="context-what-kind-of-configuration-does-a-keyboard-use">Context: What Kind of Configuration Does a Keyboard Use</h2>
<p>Fancy keyboards allow the user to customize the keyboard’s behaviour.</p>
<p>One example is for users can change the keyboard’s keymap to some alternative
layout (such as Dvorak, or Colemak) on the keyboard itself; this reduces
friction, since then the computer can assume it’s using a typical QWERTY
keyboard, and the user doesn’t have to worry about changing the OS configuration
to use a keymap that might not be installed on the OS.</p>
<p>Anyway, the point is, in order to be able to change the keyboard’s behaviour,
you have to some way of the user describing that behaviour.</p>
<p>With <a href="https://docs.qmk.fm/">QMK firmware</a>, the approach previously had been that
you’d write out your keyboard definition and keymap definition in the C
programming language, and compile the firmware and flash this onto the keyboard.</p>
<p>C is a simple language; but with the C PreProcessor, it’s also <em>unrestrained</em> and formless.<br />
The formless nature can be a benefit for the creative expression of the end user (in terms of <em>how</em> the keymap is expressed),<br />
but I guess it’s a significant burden for the framework maintainers, presumably
since it makes changing interfaces of the framework difficult.</p>
<p>Hence, there’s been a move towards <a href="https://docs.qmk.fm/#/data_driven_config">data-driven
configuration</a>.</p>
<p>QMK’s <code>info.json</code> adds a layer of abstraction so that the relevant information
can be declared from a single source of truth; this data can then be used to
generate the code which QMK had been using before. The keyboard definitions
describe the keyboard’s pinout, and what features it supports / how it supports
them; and the keymap definitions describe the layout of keys. (e.g. <a href="https://github.com/rgoulter/qmk_firmware/blob/rgoulter-keyboards-and-layouts/keyboards/rgoulter/pykey40/info.json">my
info.json for
PyKey40</a>,
or for my <a href="https://github.com/rgoulter/qmk_firmware/blob/rgoulter-keyboards-and-layouts/keyboards/rgoulter/x_2/info.json">“X-2”
keyboard</a>).</p>
<p>And, as I described in my previous post that I’d rather read Rust than read C;
it’s easier to read someone else’s JSON than to read someone else’s C.</p>
<p>So. Custom keyboard firmware makes use of configurations for things like
keyboard definitions and keymap definitions.</p>
<h2 id="nickel">Nickel</h2>
<p>Roughly, my feeling is that Nickel is to JSON and YAML what Rust is to C and
C++.</p>
<p>C is ubiquitous, and bare bones. C++ has some features which make it seem nicer
for some use cases, but it’s got many rough edges. Rust is ‘complex’, but avoids
many of the previous rough edges, and has some really nice features.</p>
<p>JSON is ubiquitous, and bare bones. etc.</p>
<p>Technically, these “JSON plus functions plus modules” languages operate at a
different level than JSON.. but I think that since the goal is to declare a
particular configuration, I’d put them alongside each other when writing them.</p>
<p>Cosmetically, much of Nickel’s syntax does seem similar to Rust. (Whereas, say,
Dhall’s syntax seems similar to Haskell).</p>
<p>Since I was using Nickel to write configuration (as opposed to writing the
application which uses the configuration, or library modules for the
configuration), I didn’t poke around with Nickel’s typing or contracts.</p>
<h2 id="json-plus-functions-allows-for-clearer-configuration">“JSON plus Functions” Allows for Clearer Configuration</h2>
<p>With JSON, there’s no choice but to be explicit, unfactored, and undocumented.</p>
<p>Consider the value each of the additions to JSON in “JSON plus functions plus
modules (plus types)”.</p>
<p>Types can be useful for avoiding ‘illegal’ configurations, or otherwise
navigating code, even though technically types provide no value at runtime.</p>
<p>“Plus functions” implies “plus variables”. – I recall one way of describing
programming was: “means of naming, means of combining, and means of
abstraction”. That’s really the functionality “JSON plus functions” is getting
at.</p>
<p>“Plus modules” on top of that is (more/less) simply being able to break up one
big file into many smaller ones.</p>
<p>Without a means of naming/combining/abstracting, JSON values must be explicit
and can’t be factored. “list of numbers from 4 to 30” would be tedious to
describe in JSON, but may be useful to describe in USB keyboard configurations
(e.g. “values A-Z in the <a href="https://www.usb.org/sites/default/files/hut1_21.pdf">keyboard usage
page</a>”).</p>
<p>And for anything non-trivial, there’s always going to be a benefit in being able
to add documentation.</p>
<h2 id="configuration-languages-hamstrung-by-json">Configuration Languages Hamstrung by JSON</h2>
<p>These “JSON plus functions” languages do allow for a nicer experience, but I
think they’re also inherently limited by JSON’s success.</p>
<p>I like sum types, pattern matching and value destructuring. (And apparently
alongside pattern matching, I like tuples).</p>
<p>But since JSON values are either primitive (null, boolean, number, string) or an
array or an dictionary… there’s not really a natural way to express sum types
(or tuples) as JSON values. – Or languages like Go-lang also lack sum types; so
while you can parse JSON into Go values without too much difficulty, there’s
more friction trying to do the same with sum types.</p>
<p>I guess with sum types, you need to know all the variations of the type before
you can do meaningfully useful things with the value (check for invalid
variants, exhaustively check variants have been considered, etc.); the other
JSON values don’t have this constraint. Still, it’d be nice to somehow have sum
types in more places.</p>
<h2 id="it-lacks-tuples">It Lacks Tuples</h2>
<p>I’m not sure if it was a deliberate design decision motivated by a preference
for the explicit, or a distaste of implementing a tuple using heterogeneous
values in an array (or perhaps a limitation that lists can’t be heterogeneous?),
but I noticed that Nickel doesn’t support tuple types (in contrast to its other
fancy features).</p>
<p>e.g. the signature for <a href="https://nickel-lang.org/stdlib/std-array/#partition">Nickel’s
std.array.partition</a> is:</p>
<pre><code>partition : forall a. (a -&gt; Bool) -&gt; Array a -&gt; { right : Array a, wrong : Array a }</code></pre>
<p>whereas e.g. <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-List.html#v:partition">Haskell’s
Data.List.partition</a>
uses tuples:</p>
<pre><code>partition :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a]) </code></pre>
<p>Similarly,
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition">Rust’s Iterator’s partition returns a tuple</a>,
<a href="https://lodash.com/docs/4.17.15#partition">JavaScript’s lodash returns an array</a>,
<a href="https://package.elm-lang.org/packages/elm/core/latest/List#partition">elm’s List.partition returns a tuple</a>.</p>
<p>I don’t think the other “JSON plus functions” languages have tuples, either; so
it’s not Nickel’s so much as JSON’s limitation.</p>
<h2 id="smelly-syntax-lists-vs-arrays-and-recursive-vs-iterative">Smelly Syntax: Lists vs Arrays and Recursive vs Iterative</h2>
<p>In my use case, use of <code>nickel</code> was done at compile time on a powerful machine,
so I’m not concerned with memory consumption, nor too concerned about runtime.</p>
<p>My taste was <em>tickled</em> by that Nickel’s <code>std.array</code> has functions which are
geared towards list manipulation (e.g.
<a href="https://nickel-lang.org/stdlib/std-array/#fold_left">fold_left</a>), whereas the
structure is an array.</p>
<p>I found this at times awkward since AFAICT in Nickel, arrays don’t have syntax
to destructure them.</p>
<p>Rather, it’s natural to interact with lists recursively. A list is recursively
defined as either an empty list, or some item followed by a list. (e.g. the
<code>(list 1 2 3)</code> is <code>1</code> followed by <code>(list 2 3)</code>; and ultimately <code>(list 3)</code> is <code>3</code>
followed by the empty list). In Haskell, a list can be pattern-matched against
<code>x:xs</code> (the head of the list, followed by its tail).</p>
<p>Whereas, it’s natural to interact with arrays using loops and indices.</p>
<p>It’s natural for an expression-oriented language like Nickel to work with lists
(and it would be unusual for an expression-based language to have loop
constructs, I think); and JSON has arrays.</p>
<h2 id="configuration-complexity-is-about-how-you-use-it">Configuration Complexity is About How You Use It</h2>
<p>A blogpost I think about a lot is the <a href="https://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html">“Configuration Complexity
Clock”</a>.
Its picture tells 1,000 words; but roughly the point is that at each step, the
trade-offs look desirable for going from hard-coded values to a configuration;
and from a configuration to a DSL; and from a DSL to hard-coded values. –
Hence, don’t just accept “hard coded values bad” as a dogma, and take care when
adopting a configuration or a DSL.</p>
<p>What’s “too hard to read” is also dependent on the person.. <a href="https://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html">Steve Yegge’s
“Portrait of a
n00b”</a> discusses
that what’s considered acceptable to someone unfamiliar with the code may be
unacceptable to someone who is very familiar with the code. (Code that’s too
sparse or too verbose means changing the code takes more effort than it needs
to; whereas code that’s too dense or too terse also means changing the code
takes more effort than it needs to).</p>
<p>Adding functions to JSON provides a more powerful tool for configuration. But,
sometimes a “more powerful tool” is like a rocket-powered chainsaw: if you’re
not careful about how you’re using it, you might end up causing more damage than
it’s worth.</p>
<h2 id="types-arent-sufficient-to-describe-interfaces">Types Aren’t Sufficient to Describe Interfaces</h2>
<p>Something John Ousterhout’s <a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">A Philosophy of Software
Design</a> talks about is about
the distinction between a software module’s interface and its implementation.
Its interface is “what someone needs to know to use the module”. – He gives the
example of a bad interface: on Windows, you can’t delete a file if it’s open by
some process; this is ‘bad’ because in order to delete a file, you need to also
know that the file is not opened by any process (or which processes to close!).</p>
<p>The broader point is that a module is “complex” if its interface requires
superfluous details (the interface is over-specified), or if using the interface
also requires knowing implementation details not exposed as part of the
interface (the interface is under-specified).</p>
<p>PoSD makes the point that, similar to how Test-Driven Development emphasises the
benefits of writing unit tests before writing the implementation, it’s similarly
beneficial to write out a module’s documentation before writing the
implementation.</p>
<p>While types show what an implementation is capable of, documentation describes
what a module user needs to know in order to use the module (especially since
it’s often not practical or possible to describe with types).</p>
<p>To illustrate the point, looking at <a href="https://github.com/semickolon/fak/blob/8f3d29d3705a0e7b7cadcd1650c162fceaba7ced/ncl/fak/keymap.ncl#L26-L53">a rather gnarly Nickel excerpt in
fak</a>:</p>
<pre><code>let HoldTapKeyInterrupt = {
  decision | [| &#39;none, &#39;hold, &#39;tap |] | default = &#39;none,
  trigger_on | [| &#39;press, &#39;release |] | default = &#39;press
} in

let HoldTapKeyInterrupts = (
  # ...
  std.contract.Sequence [ Array HoldTapKeyInterrupt, ValidLength ]
) in

let HoldTapBehavior = let
  default_key_interrupts = std.array.replicate key_count {}
in {
  timeout_decision | [| &#39;hold, &#39;tap |] | default = &#39;hold,
  timeout_ms | Uint16 | default = 200,
  key_interrupts | HoldTapKeyInterrupts | default = default_key_interrupts,
  # ...
} in</code></pre>
<p>It’s not too hard to discern what values can be constructed for these types
(e.g. a <code>HoldTapKeyInterrupt</code> could be <code>{ "decision": "none", "trigger_on": "press" }</code>), but the types themselves aren’t sufficient to describe what the key
interrupt logic is, or how the values should be used. (For this code, there’s
<a href="https://github.com/semickolon/fak/tree/ebbb07c63721009c60d9951112d0587929657e3d#complex-hold-tap-behaviors">documentation
elsewhere</a>).</p>
<p>A <code>HoldTapBehavior</code> value could be expressed in JSON. having types <em>and
documentation</em> guide understanding.</p>
<p>Getting back to Nickel: it does support adding documentation by way of adding a
<code>doc</code> <a href="https://nickel-lang.org/user-manual/syntax/#metadata">metadata decoration to record
fields</a>. – But I guess I
wish I saw people say “types <em>and</em> documentation”. (Although perhaps by the time
you add enough features to the DSL, you’ve essentially just got hard-coded
values in a general purpose programming language).</p>
<h2 id="toolinglsp">Tooling/LSP</h2>
<p>I expect it will improve, but I found that the Nickel LSP server wasn’t quite
clever enough to go-to-definition for all the situations I tried it in.</p>
<h2 id="overall">Overall</h2>
<p>Overall, I was pleased with my experience.</p>
<p>“JSON plus functions” does let me apply creativity to describe a configuration
in a way that I find to be a good balance of cleverness and clarity.</p>
<p>There are more costs/risks to using Nickel compared to using plain JSON, but
there are also many benefits.</p>]]></summary>
</entry>
<entry>
    <title>Experience Report on Updating Keyboard Firmware Written in Rust</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-10-30-experience-report-on-updating-keyboard-firmware-written-in-rust.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-10-30-experience-report-on-updating-keyboard-firmware-written-in-rust.html</id>
    <published>2023-10-30T00:00:00Z</published>
    <updated>2023-10-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here are some notes on the experiences I had updating some keyboard firmware I had written in the Rust programming language.</p>
<h2 id="context-my-dive-into-the-mechanical-keyboard-rabbit-hole">Context: My Dive into the Mechanical Keyboard Rabbit Hole</h2>
<p>This was for keyboard firmware I’d written in Rust.</p>
<p>In mid-2020, I took my first steps into the mechanical keyboard hobby when I bought the BM40 keyboard.
I thought it looked pretty neat, since the keys were arranged in a symmetrical grid, and the keyboard was very small (so would require some skill to use). It was a decent keyboard to start with.</p>
<p>One of the nice things about the mechanical keyboard hobby is there are all sorts ways you can be creative with fancy keyboards. (e.g. from purchasing a different set of keycaps so that your keyboard looks nicer, trying out different styles of keyboard switches, etc.).</p>
<p>By the start of 2021, I was trying to design keyboard PCBs. (You can find the results of my playing around at github, <a href="https://github.com/rgoulter/keyboard-labs">rgoulter/keyboard-labs</a>). – The idea of trying to pack bells &amp; whistles onto a keyboard all within a pair of 100x100mm PCBs sounded like such a fun/interesting challenge.</p>
<p>These PCBs would need firmware written for them. Fortunately, almost all of the custom keyboards that enthusiasts buy allow customising the keyboard layout. And, the most popular by far was QMK, which is relatively easy to work with. I had enough experience to work with QMK. (I was the one who added HSRGB functionality to the BM40 rev1, which took about 3 days to merge; I also made a PR for BM40 rev2, which took just over 550 days to get merged…). I was able to use QMK to write firmware for my custom designs.</p>
<p>But, I also came across the <a href="https://github.com/teXitoi/keyberon">keyberon</a>, a library which supported writing keyboard firmware in Rust. Of course, I had to try it.</p>
<h2 id="mechanical-keyboard-firmware-options">Mechanical Keyboard Firmware Options</h2>
<p>For writing keyboard firmware, there are several popular options. There are probably others, but to my mind:</p>
<ul>
<li><p>QMK, by far the most popular and featureful.</p></li>
<li><p>ZMK, for keyboards which have Bluetooth.</p></li>
<li><p>KMK, which is built upon CircuitPython.</p></li>
<li><p>Keyberon, which uses Rust.</p></li>
</ul>
<p>My experience has been that QMK is by far the most practical one of these to use.</p>
<p>e.g. Although it’s much easier to iterate on firmware using CircuitPython (since “flash firmware” is as simple as “copy file to thumbdrive”), my experience with KMK was that its tap-hold functionality didn’t work well enough for home-row modifiers; which essentially makes the firmware impractical for small keyboards.</p>
<p>However. Keyberon is written in Rust, so I was curious to give it a try.</p>
<h2 id="general-impressions-of-rust-keyboard-firmware">General Impressions of Rust Keyboard Firmware</h2>
<p>It’s to QMK’s credit that it does such a great job at making writing keyboard firmware so accessible.
As QMK is a framework, you just bolt on your own parts to it (e.g. a keyboard pinout, if the keyboard isn’t already supported by QMK; and a keymap). You to can make use of a wide variety of software features (like layering, or tap-dance key behaviour), as well as hardware features (such as RGB LEDs, OLED screens, etc.). – Essentially, almost no embedded system knowledge is required to write a keymap, and very little is required to add on a keyboard definition.</p>
<p>As I understand it, Keyberon’s goal isn’t to compete with QMK. Its goal is to be a library for helping write keyboard firmware. (I think limiting the project scope is a good thing).</p>
<p>I reckon a downside to this is: it ends up that the keyboard firmware written in Rust that I’ve seen all have the feeling of “copied and pasted” to them. – The potential upside to this is all the keyboard firmware programs are small and easy to understand; but I can’t help but feel that everyone doing this copying-and-pasting is having to pay the cost of a learning curve in each instance.</p>
<h2 id="on-rust-vs-c">On Rust vs C</h2>
<p>I really like that Rust has features like Sum types (tagged unions), and destructuring.</p>
<p>I got the impression that in order to write Rust code, you still need to have a decent mental model for how C works. – e.g. when I’m writing TypeScript or Python, I don’t need to care about whether the values I’m using are concrete or abstract; however, in Rust, I’d frequently make the compiler point out that with the code I had written, the size of the value couldn’t be determined. To me, that kind of restriction is less confusing if I can think “oh, right, in C, you’d have to …”.</p>
<p>In terms of “reading others’ code”: I would rather read code written in Rust than code written in C. – Frequently, C’s CPP <code>#ifdefs</code> make its code complex to read, since it’s that much more you need to keep in mind when reading the code. It’s also harder to setup tooling for C such that you can use development-environment features like “jump to definition”.</p>
<p>It’s really useful to be able to rely on code others have written. I wouldn’t want to set up a C project to depend on others code. (It’s more straightforward to add a dependency to a Rust project than to a C project). But, especially for this use case, building on QMK allows firmware which does more, with a wider variety of peripherals, than writing Rust code would. To an extent, I’d think the much of the code that gets into QMK also benefitted from there being more embedded firmware code in C than in Rust.</p>
<p>It’s difficult to write Rust code.<br />
It can be difficult to correctly express lifetimes, or generic trait bounds. A strict compiler which adds friction is great for <em>maintaining</em> code, but it makes just shitting out code much harder. (And sometimes “shitting out code” is what you want to be doing).</p>
<p>In terms of “risk of writing code that’s too clever”: If someone’s writing code in C that’s <em>too clever</em>, one mechanism they have to use is the C Pre-Processor. Rust’s macros can be very similar; but Rust also has other ways of writing code that’s <em>too clever</em>.</p>
<p>Rust is also a complex language. I don’t want to point to any one thing and say “this is too hard to understand”; but with so many sophisticated features, it can be difficult to have a good intuition for how Rust’s features interact with each other. – So if you’re coming back to a codebase after some months of not having used Rust, it can take time to recall a good mental model.</p>
<p>That QMK is much more practical to use than the other keyboard firmware alternatives is a testament to just how much work has gone into making the project accessible.</p>
<h2 id="earlier-iterations-of-my-rust-firmware">Earlier Iterations of my Rust Firmware</h2>
<p>My Rust keyboard firmware has been a project which I return to maintain once or twice a year. I initially wrote it, largely by copy-pasting from similar codebases. As a sideproject / hobby repo, each iteration was an opportunity for me to have fun, and make the code more sophisticated. e.g.:</p>
<ul>
<li><p>by refactoring the code by breaking up a single file into several modules,</p></li>
<li><p>adding firmware code for a different keyboard,</p></li>
<li><p>adding Nix support code, so that it’d be easier to build,</p></li>
</ul>
<p>I mean, each iteration was a chance to take something that worked, and add onto it a bit so the code was less messy. – “The first time, as a scientist; the second time, as an engineer”.</p>
<h2 id="updating-the-code">Updating the Code</h2>
<p>I had tried (and failed) to update the code’s dependencies back in 2023 May.</p>
<p>My expectation when updating dependencies is: if I can bump the dependencies and there are no compilation errors, I expect the code to work as it did before.<br />
If I run into compilation errors (e.g. function signatures or types changed), then I’ll have to look to see what changed, figure out the smallest reasonable change to get the code to compile, and hope that works.</p>
<p>I found difficulty in updating 3 things: the version of the realtime framework (RTIC), the version of the HAL (API for driving the hardware), and the toolchain version. – When I updated <em>just that</em>, then the code might compile but the firmware wouldn’t work as it did before.</p>
<p>When I updated the toolchain, the code compiled but didn’t run the same way it had before. – This was frustrating and unfortunate.<br />
But, given that I was able to update the toolchain after resolving the other two problems, my best understanding is: my code was wrong, and happened to work with the old compiler version.</p>
<p>Similarly, when I tried updating the HAL dependency, the code would compile but wouldn’t result in a working keyboard; ditto for the RTIC.<br />
This was frustrating and unfortunate.<br />
But in this case, I think the problem was more clearly my bad code.<br />
– I was using the wrong kind of Timer in the firmware. A closer read of the documentation indicated “if the system runs above such and such frequency, then don’t use this Timer”.<br />
If there’s any fault of the dependencies, it’s apparently that they happened to previously be lenient enough to run bad code.</p>
<p>I’d put this frustrating experience up to the difficulty of embedded development.</p>
<p>That said, I will say I also ended up replacing the dependency of the USB HID keyboard from Keyberon’s implementation to <a href="https://docs.rs/usbd-human-interface-device/latest/usbd_human_interface_device/">usbd-human-interface-device</a>’s.<br />
For one, <code>usbd-human-interface-device</code> implemented support for media keys (play/pause, next track, etc.) which Keyberon didn’t.<br />
But I’d ran into a bug related to sending USB HID reports when using Keyberon’s implementation, which went away when using <code>usbd-human-interface-device</code>’s.</p>
<h2 id="things-i-found-difficult-about-embedded-development">Things I Found Difficult about Embedded Development</h2>
<h3 id="deploying-the-program-is-harder">Deploying the Program is Harder</h3>
<p>The easiest kind of deployment action is to run software on some Linux machine that you control. e.g. To deploy a web server, copy the program over, and then run the program there.</p>
<p>Running a program on an embedded device is somewhat more involved.</p>
<p>For a newbie, there are many things about this which are quite confusing.</p>
<p>Fortunately, it has become much easier in the time since I started. With UF2 bootloaders, flashing the firmware onto a device is as simple as copying a file to a thumbdrive. – Albeit, compiling the UF2 file is not totally trivial; and you still have to flash a UF2 bootloader onto the device.</p>
<h3 id="printf-debugging-harder-to-set-up">Printf Debugging Harder to Set Up</h3>
<p>A staple of debugging is “printf debugging”. You put a bunch of <code>print</code> statements in your code, and use those as evidence to lead you to a better understanding of how a system works.</p>
<p>With embedded devices (even very powerful ones), it’s … not quite that simple.</p>
<p>Ideally, with USB devices, you can somehow set up some kind of CDC serial console and output messages over that. But, if you’re at the level of copy-paste coding, this isn’t so simple to set up. (… and doesn’t help if you mess up something in the firmware before it gets to that point).</p>
<p>I saw <a href="https://probe.rs/">probe-rs</a> puts in a bunch of effort to make debugging embedded software much easier, to the extent where you can just run <code>cargo embed</code> and you <em>can</em> have this printf debugging. – But, you still have to figure out how to setup a probe device, and connect that to your device, etc.</p>
<h3 id="the-small-details-might-really-matter">The Small Details Might Really Matter</h3>
<p>In one sense, programming is about structuring complexity so that you only need to pay attention to the things that are important to you (and can ignore the things that aren’t).</p>
<p>But I’d say with embedded development, it’s more likely that small details will be significant, compared to writing an HTTP API server.</p>
<p>One mistake I made was constructing a USB class after I’d constructed a USB device; this caused the program to crash, and it wasn’t obvious to me as to why. (Well, once I got the SWD connected and printf debugging working, <em>then</em> it was obvious what was happening).</p>
<h3 id="getting-a-good-mental-model-of-rust">Getting a Good Mental Model of Rust</h3>
<p>I think it’s widely accepted that when learning Rust, you’ll be struggling to get code to compile. (Even code which would be acceptable in memory-managed languages like TypeScript or Python). Especially with concepts related to ownership and lifetimes.</p>
<p>More than once, I’d encounter difficulty trying to convince the compiler that my code was fine; or I might have some intuition that what I wanted to try was okay, but would have difficulty expressing that in how Rust actually worked. – I do believe many experienced Rust developers will try and avoid having to fight the compiler when they get into these situations.</p>
<h2 id="fancy-tech-that-helped">Fancy Tech that Helped</h2>
<h3 id="llms">LLMs</h3>
<p>I used LLMs both for code-assistance in the IDE, as well as asking questions to a chat bot.</p>
<h4 id="code-suggestions-in-the-editor">Code Suggestions in the Editor</h4>
<p>Because the code for keyboard firmware so naturally reflected the structure of the keyboard’s schematic, the kind of code I was writing was very easy for GitHub’s CoPilot to predict. – e.g. you might leave a comment saying “the column pins are PA3, PB7, PB8, PA13, …”, and then GitHub CoPilot is able to predict what you’ll want <code>let col_pins =</code> to match against. This effectively removes a lot of drudge; rather than having to type 30-50 chars of what you know, you only have to type about 5 or so.</p>
<p>CoPilot didn’t get it right 100% of the time; but, with a nudge in the right direction, it was able to suggest exactly the code I wanted to write. – Even with having to check the output &amp; adjust, overall, it was beneficial to use CoPilot.</p>
<p>CoPilot was also very useful for writing rote bits of code which I’d describe as “the kind of stuff you’d seach ‘how do I do this’ and copy-paste” (if you’re new to the language/library) or perhaps “the kind of thing you’d write without thought” (if you’re familiar with the language/library).<br />
– Perhaps a <em>downside</em> being, if you’re not familiar with best practices, nor idioms of what the code <em>should</em> be, then maybe you’re just writing bad code.</p>
<p>(I also ran into some tooling problems: there were some contexts where CoPilot didn’t make suggestions, and some contexts where “use CoPilot’s completion” conflicted with other bindings).</p>
<h4 id="asking-llms-for-help">Asking LLMs for Help</h4>
<p>I liked the idea that Go-lang made for a good language to use for side-projects, since the language strives to be simple to write. This reduces the cost of coming back to the project after months of not having touched the technology; whereas with a more complicated language, you have more to recall.</p>
<p>Rust is a complex language. There are going to be things that won’t be obvious.</p>
<p>This is the kind of problem StackOverflow is good for. You’re likely to have the same questions as other people, and ask “how can I…?” or “why can’t I combine this and that…?”.</p>
<p>I tried asking ChatGPT for help whenever I was stuck with something.</p>
<p>The results were hit and miss.</p>
<p>When I got a good result, it would provide code snippets tailored closely to what I’d asked for.</p>
<p>When I got bad results, the LLM would confidently tell me “oh, this is how this works”, and it felt the <a href="https://www.youtube.com/watch?v=oN2_NarcM8c">Abbott and Costello joke about 7x13 = 28</a>. – The joke is funny because I know basic multiplication; but I wonder what the joke is like if you have no understanding of the domain.</p>
<p>Ultimately, at the moment, I think this leaves only a few places where I’m comfortable asking LLMs stuff: domains where inaccuracy leaves me no-worse-off than the average person; and domains where I know enough to verify the LLM output to make use of it.</p>
<h3 id="nix">Nix</h3>
<p>Probably <code>rustup</code> with a toolchain file and <code>Cargo.lock</code> are sufficient to reproduce the same binaries/behaviour that had worked before. I used Nix to take care of this, instead.</p>
<p>The additional benefits I got from Nix:</p>
<ul>
<li><p>By declaring the tools I used as part of a nix shell, I didn’t have to worry about how to install these programs.
With embedded development, there were several tools which were useful for working with the binaries (such as <code>probe-rs</code> or <code>st-write</code>).</p></li>
<li><p>I found it nice to have the outputs I wanted declared as a package.</p></li>
</ul>
<p>I’m able to trust that a Nix package isn’t affected by a dirty environment in a way that’s difficult to achieve with a Makefile.</p>
<h3 id="just-task-runner">Just (Task Runner)</h3>
<p>One thing I don’t see eye to eye on with QMK is it has its own bespoke <code>qmk</code> CLI (which both depends on, and is intended for use within the qmk_firmware repository; you can’t use <code>make</code> without having <code>qmk</code> installed).</p>
<p>One DX improvement I value from the <code>qmk</code> cli is its <code>qmk flash</code>, which has a “do what I mean” feel to it, in that it waits for the expected device to become available, and then will flash the firmware appropriately.</p>
<p>While <code>Makefile</code>s are suitable for describing how files are to be built, <code>justfile</code>s are suitable for describing tasks to be run. So, I added a <code>justfile</code> with a convenience command to help me flash the firmware. It’s a small thing, but it improved the DX.</p>
<h3 id="lsp">LSP</h3>
<p>https://grugbrain.dev/#grug-on-type-systems</p>
<blockquote>
<p>grug very like type systems make programming easier. for grug, type systems most value when grug hit dot on keyboard and list of things grug can do pop up magic. this 90% of value of type system or more to grug</p>
</blockquote>
<p>LSP means it’s easier for “hit dot on keyboard and list of things grug can do pop up magic”.</p>
<p>Also useful is: being able to show the type, and being able to show the documentation for the type.</p>
<p>(Albeit, for some reason, the LSP in Helix was better able to find information in the RTIC framework’s tasks than the LSP I used with Emacs could. Perhaps this has to do with proc macros or some other thing.).</p>]]></summary>
</entry>
<entry>
    <title>John Wick 4 is Good Fun</title>
    <link href="http://www.rgoulter.com/blog//posts/narrative/2023-09-27-john-wick-4-is-good-fun.html" />
    <id>http://www.rgoulter.com/blog//posts/narrative/2023-09-27-john-wick-4-is-good-fun.html</id>
    <published>2023-09-27T00:00:00Z</published>
    <updated>2023-09-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I finally got around to watching John Wick 4.</p>
<p>I hadn’t <em>loved</em> John Wick 3.<br />
In JW3, Wick takes <em>a lot</em> of physical punishment and manages to keep fighting against all his enemies. What ruins the movie for me is scenes like where his enemies beat him, but they then don’t kill him; and so Wick is then able to keep fighting and kill them.</p>
<p>Fortunately, I enjoyed John Wick 4 much better.</p>
<p>Perhaps I went in with a more suitable mindset. – The films aren’t really good as a coherent “how would one super assassin survive against a horde of other assassins”.<br />
Instead, I think films like JW4 are more like excuses for stringing a bunch of action scenes together that have all sorts of fantastic stunts.</p>
<p>e.g. Extraction 2 is directed by a stuntman.. its first third has an unbelievably impressive fight scene in an open courtyard during a prison riot.</p>
<p>In JW4.. does it make sense to have a fist fight in the middle of a busy street at night, in front of a muscle car that’s been turned on its side? No. Not one detail makes sense. (Traffic would stop, or the assassins would shoot Wick, or whatever). – But, it looks striking.</p>
<p>Does it make sense for assassins to have tacti-cool models of old firearms like the WW2-era’s Thompson gun, or the Wild West era’s lever action? No, but it follows rule-of-cool.</p>
<p>I reckon JW4 does a better job at integrating its ensemble of assassins and villains than the previous movies. The series has always had a set of heroes and villains.. but, I liked it in this one.<br />
The fights are perhaps ‘accommodating’ for the sake of rule-of-cool.<br />
One of the fun ideas that hasn’t been beaten to death is the idea of competing assassins protecting a target. – The anti-hero Mr Nobody in this movie wants to make lots of money off of killing John Wick, and so he kills the other assassins who are attacking Wick.</p>
<p>Plot wise… it’s so “rule of cool” that it’s as if it’s been perfectly rendered from the mind of a 12 year old.</p>
<p>I assume the series is going to continue.<br />
I hope the next one is a bit more chilled out. The Fast and the Furious series is fun, but it’s a bit too over-the-top.</p>]]></summary>
</entry>
<entry>
    <title>So I Just Finished Tomb Raider 2</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2023-09-20-so-i-just-finished-tomb-raider-2.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2023-09-20-so-i-just-finished-tomb-raider-2.html</id>
    <published>2023-09-20T00:00:00Z</published>
    <updated>2023-09-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Well. I’d played it years ago. And I would’ve cheated when I played it last.</p>
<p>I had fun playing it again now.</p>
<p>I loved the adventure aspects of the game.<br />
It’s satisfying to have enough of a grasp of how the level is designed so as to make your way through it!</p>
<p>The designs of the levels themselves are interesting.<br />
The levels themselves are laid out along an easily discernable grid.<br />
This makes the navigation physics pretty easy to understand.<br />
But, it’s also quite a constraint on the ability to design good looking levels.</p>
<p>Despite that, there are many memorable moments throughout the game that leaves more of an impact than, say, a more spectacle-heavy game like Call of Duty.</p>
<h3 id="the-gameplay-loop">The Gameplay Loop</h3>
<p>At its moments of low friction, Tomb Raider II involves traversing through an area, dealing with any threats (e.g. enemies or traps), and perhaps collecting key items or interacting with switches in order to get to the next area. – e.g. you’ll notice there’s a switch, you’ll pull the switch, and this opens a door nearby where you’ll then proceed to the next area.</p>
<p>When there’s more friction, often you’ll have overlooked some part of the area that allows you to proceed; or perhaps there’s some under-explained puzzle mechanic that you need to understand to continue.</p>
<p>“Under-explained puzzle mechanic” is a good thing. A puzzle explained isn’t much of a puzzle.<br />
It just means you’ll need to try different things.</p>
<p>The “overlooked some part of the area” I have more mixed feelings about.<br />
Most of the game, the area you need to look in isn’t all <em>that</em> large; and so it’s not too mean.<br />
On the other hand, if they used guide paint to highlight the areas to go next, that’d take out most of the fun. – Often the level <em>does</em> have markers suggesting where to go next, but it’s typically very subtle.</p>
<p>In terms of friction,<br />
I’d say it’s “soft stuck” when you’re not fully certain how to proceed to the next area, but you still have plenty of things to try.<br />
Whereas, you feel “hard stuck” if you still think you’ve checked everywhere, and you think you’ve tried everything that could possibly work.<br />
– It’s <em>really</em> satisfying to think: “Hmm, okay, I’ll try this,” and for that to be the solution.</p>
<p>I felt more stuck early on in the game. For the last two levels, the challenge shifted to the areas being trap-heavy.</p>
<h3 id="the-controls">The Controls</h3>
<p>These days, with twin stick controllers, the most common controls involve using the right stick for controlling the camera, and the left stick for movement.</p>
<p>These classic Tomb Raider games use “tank controls”. i.e. up/down/left/right control Lara relative to <em>Lara’s body</em>, regardless of where the camera is looking.</p>
<p>This works well with the grid system to have a navigation logic which works quite discretely. It’s something like: Lara can do a standing jump reaching 1 block away; or a running jump reaching 2 blocks away; or she can grab the edge of a block 3 blocks away after a running jump.</p>
<p>Some people don’t like these controls somehow. I guess there’s a subtlety to the running jump, where Lara needs to run 1 block before will do a running jump.</p>
<p>In terms of combat, Lara auto-aims her weapons.<br />
This makes combat more about acrobatically dodging around enemies (and navigating the terrain while doing so) than about aiming with a mouse.<br />
Two things I miss from twin-stick controls: the controls don’t support strafing around an enemy; and with the auto aim, it’s difficult to tell which target I’m aiming at (which is important for one level where there are friendly units).</p>
<p>The tank controls are more direct, more raw, and ‘lower level’ than the twin-stick controls. – You can screw up and look stupid; but it’s satisfying to pull off an elegant maneouver.</p>
<p>What <em>doesn’t</em> work well is that since the tank controls’ camera is automatically controlled, this can result in awkward situations where you can’t see what’s in front of you. This mostly impacts combat in some places.</p>
<h3 id="memorable-moments">Memorable Moments</h3>
<p>The start of the underwater missions sees Lara underwater, and the first thing we have to do is find a pocket of air to breathe in!<br />
I don’t <em>love</em> the underwater levels; I think the underwater combat is lame.<br />
But, the design of the levels is fun. At one part, you’re in an upside-down ocean liner.</p>
<p>In the Tibetan mountains, there’s a dark room filled with the growls of yetis. Lara can’t light the room and shoot at the same time. Although, yeah, turns out the yetis are safely in cages, until you flip the switch that lights the room a bit.</p>
<p>The ancient temple near the end, where we once again hunt down the titular Dagger of Xian.. it’s a trap-heavy level, it feels a little mean, but it’s got such a fascinating feel to it.</p>
<p>The epilogue strikes me as special. Yeah, sure, it’s got Lara wearing a bathrobe. But, it’s also got gameplay where you’re fighting off a bunch of goons from what was otherwise an iconic training area outside of the main game.</p>]]></summary>
</entry>
<entry>
    <title>Classic Lara Croft is Back, Huh</title>
    <link href="http://www.rgoulter.com/blog//posts/games/2023-09-19-classic-lara-croft-is-back-huh.html" />
    <id>http://www.rgoulter.com/blog//posts/games/2023-09-19-classic-lara-croft-is-back-huh.html</id>
    <published>2023-09-19T00:00:00Z</published>
    <updated>2023-09-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://twitter.com/tombraider/status/1702355960809812035">A remaster of the first three Tomb Raider games has been announced</a>.</p>
<h3 id="remastered-games">Remastered Games</h3>
<p>This continues a trend of classic games receiving touch ups and being sold as new.</p>
<p>For gamers, this has the advantage of making these remastered games easy to play on modern systems. Without such remasters, you’d either have to play the game on a console with physical media, or perhaps fiddle with compatibility mechanisms to get the game to play on PC.</p>
<p>This seems to have gone quite well for the “Age of Empires” series.<br />
I remember a decade ago or so, the idea of polishing AoE2 and re-releasing it was quite popular.<br />
In the end, they re-released it twice: with an “HD” edition, and then with a “Definitive” edition. I suspect the “HD” edition was more of a pilot to gauge response; and “Definitive” was more of a continuation.</p>
<p>Another remaster I was excited for was for “Commandos 2”.<br />
Unfortunately, here the remaster altered some of the iconic graphics from the original. The game removed nazi swastikas, but also some of the Japanese “rising sun” icons. (Although I disagree with their removal from the game, I can at least understand why you’d want to remove nazi swastikas; I find removing big red circles a bit too much, though). – The game doesn’t depict brutal realities of war; but it does depict situations where a small crew of Allied commandos go and beat up a bunch of the bad guys (including situations where enemies occupy towns, and use prisoners of war for labour).<br />
So, the argument of “the removed symbols may remind people of the bad things done in war” is bizarre, since you’re playing as <em>the good guys stopping the bad guys</em>.</p>
<p>Other old classics like Crash Bandicoot and Spyro have had faithful re-releases.</p>
<h3 id="different-laras">Different Laras</h3>
<p>The “Tomb Raider” series has had several different generations of its series:</p>
<p>The original, classic “Tomb Raider” was developed by Core Design; these Tomb Raider games still have numbers after the title. By “Tomb Raider IV”, the developers were a somewhat burnt out, and so killed off Lara at the end of the game. TR5 was told as flashbacks. – TR6 was an attempt at making a new game for the next generation of consoles; but the game was released in an unfinished state and wasn’t all that good.</p>
<p>Crystal Dynamics picked up “Tomb Raider” with a reboot with a more dramatic “Lara Croft”; these games “Tomb Raider: Legend”, “Tomb Raider: Anniversary” (a remake of TR1), and “Tomb Raider: Underworld” were quite different than the classics: the controls were for twin-stick controllers, giving players control of the camera; and Lara had a different look (replacing the classic green tank top with a khaki top).</p>
<p>This Lara then gets ditched in the 2013 reboot “Tomb Raider”, and its sequels “Rise of the Tomb Raider” (2015) and “Shadow of the Tomb Raider” (2018).<br />
This Lara is called “Survivor Lara”.<br />
The gameplay in the games changes again, now closer to an open-world action game. Lara’s looks have changed too (I recall it being described as: the devs made her boobs smaller until play testers stopped looking at them). Lara here is <em>very</em> dramatic; where the story’s excuse for this is each of these games are an origin story telling <em>how</em> Lara comes to be such a badass.</p>
<p>The best discussion of this I’ve seen is in <a href="https://www.youtube.com/watch?v=kJMj3B1BFko">Liana Kerzner’s Lady Bits series</a>.<br />
Kerzner describes classic Lara as a Byronic heroine (passionate and heroic, but unlikable/antisocial), whose exaggerated figure reflects the exaggerated gameplay; whereas Survivor Lara is more down to earth as a character, with a relatively more realistic figure, but more of a damsel-in-distress in a game with mass-market accessibility.</p>
<p>(The ways in which Survivor Lara is less-than-ideal is also interesting: the more action-oriented gameplay leads to this ‘realistic’ Lara killing <em>way</em> more people than the classic Lara ever did; and although the new look is more ‘realistic’, it’s still the same Megan-Fox-in-Transformers glamorous with a thin layer of dirt on top despite the brutal adventuring).</p>
<p>Kerzner also describes the current zeitgeist’s attitude to big boobs as “eww, icky”, as a response to negative sexual attention many women receive; that the big boobs get removed so as to reduce repulsiveness (as opposed to adding other stuff, to add appeal elsewhere). – This leads to the notion that the title of Kerzner’s video responds to: that Survivor Lara is presumed to be ‘more feminist’.</p>
<h3 id="classic-lara-is-back">Classic Lara is Back</h3>
<p>And so it’s quite surprising to see that these remastered games feature a Lara that retains the look of the original.</p>
<p>Or as <a href="https://www.youtube.com/watch?v=-4HX0fXY8yo">Melonie Mac</a> puts it:</p>
<p>“[I wanted a remaster, but was worried they] would mess it up … the design would look bad, they would change Lara’s proportions, they would change the controls. That’s a huge thing: the controls!”</p>
<p>I find it funny that the way Lara looks is coupled to the gameplay.</p>
<p>Mac reacts to the idea of making the games more accessible the same way many reacted to Netflix’s 2022 “Persuasion”: significantly simplifying the original removes a lot of the depth that brought quality to the original.</p>
<p>I suppose it makes sense. Both “reducing the aggressively-attractive features” and “making the gameplay easier” intend to make the game reach a broader audience. – But a part of me still wonders what it’d be like if the gameplay remained, but the looks were toned down.</p>
<p>My favourite part of Mac’s video is this:</p>
<p>“[if you don’t like the classic controls] spend 30 minutes learning them and then it’ll be all worth it. Here’s the thing, classic Tomb Raiders were built on a grid based system…”</p>
<p>It’s just such unadulterated nerd talk.</p>
<p>Watching some of Mac’s other thoughts:</p>
<ul>
<li><p>There’s the idea that ‘attractive female character’ is only for men, attractive female characters make women feel bad. – Mac reckons that in similar way that super tough male character is a male power fantasy, an attractive (female) character is a female power fantasy. https://www.youtube.com/watch?v=AotyaLxqMmk – When women <em>do</em> get the chance to customise their character, you’ll see women play as attractive characters.</p></li>
<li><p>And in this video: https://www.youtube.com/watch?v=uqOn9w-OrqY Mac discusses “classic Lara Croft was sexist”.</p>
<ul>
<li><p>Mac’s not fussed about Lara wearing short-shorts in the snowy Tibetan foothills. Mac argues the other outfits Lara wears aren’t more revealing than what you’d see at the gym. Mac reckons that the classic Lara had a figure only slightly exaggerated from that of a gym rat;</p></li>
<li><p>whereas Legend Lara is too stretched out (&amp; it’s Legend Lara has the sexy revealing dress, and the option to dress Lara in a bikini in-game);</p></li>
<li><p>and by Shadow of the Tomb Raider, the outfits are extremely muted, and Lara’s body is unathletic (and legs are very short).</p></li>
</ul></li>
</ul>
<p>Overall.. short-shorts in the snow is a bit silly; but, as is someone carrying around an arsenal of weapons, leaping acrobatics around in gunfights, going 1-on-1 against a T-Rex!, and dodging around ancient traps. – Short-shorts in snow is silly, but I don’t think it weighs significantly so as to degrade the character.</p>
<h3 id="hashtag-representation">Hashtag Representation</h3>
<p>I find it striking that a number of the people reacting on social media to the announcement of the TR Remaster were women.</p>
<p>As always: generally, you can’t say “this group of people all think the same way”. It’s frustrating for people to feel left out or rejected.<br />
Kerzner’s video does a good job discussing why some women don’t love the classic Lara look.<br />
But it’s also clear to see that the women who do love the way classic Lara looks feel <em>really</em> rejected when classic Lara is denegrated.</p>
<p>The assumption “people want to see characters that look like themselves” is obnoxious…<br />
and I don’t doubt many of the women who enjoyed Tomb Raider enjoy other games too,<br />
I’d say Tomb Raider’s protagonist being a woman brought more women to the game. Or, probably there’d be significantly fewer female fans of Tomb Raider if its main protagonist was a man.</p>
<p>And <em>maybe</em> it’s a bit presumptuous, but.. Mac describes the Shiva statues in TR3 as scary for her when she was a young girl. Those TR3 levels <em>are</em> scary. –</p>
<p>Above, both Kerzner and Mac discuss that the newer games feature significantly easier gameplay, and a more dramatic Lara with a more down to earth look. – I get the feeling that if the Tomb Raider games had kept the hardcore difficulty, and still made the changes to Lara’s appearance from “aggressively, conspicuously attractive” to a more muted everyday look, there’d still be some women upset.<br />
– The games aren’t really realistic: having a stunningly feminine protagonist in such wild environments is silly. I can see why toning down the feminine aspects of Lara’s character, but retaining unrealistic action in the gameplay would come across as “femininity not welcome”.</p>
<p>Related, but in contrast: e.g. <a href="https://www.youtube.com/watch?v=AGql5ay5TVY">Angel Eduardo discusses how he likes Superman</a> despite that he doesn’t share skin colour with Superman. Eduardo is disagreeing with “making superman non-white would make him more accessible to non-white people”.<br />
(Eduardo argues: diversity requires more depth than just skin colour;
it’s absurd to say “superman is just for whites” just because his skin is white, &amp; seeing superman as “white” is regressive, changing his skin colour validates that; superman is an immigrant, an orphan, and an outsider, so it ought to be easy for many to relate to him).</p>
<p>(Now I’m wondering if they race-swapped Lara, but kept the hardcore gameplay, and the aggressively attractive looks…).</p>
<p>In both cases above, the fans of a classic character don’t like the idea of changing the character’s appearance (at least) for the sake of ‘representation’.<br />
– Although <em>surely</em> women being upset at a character’s femininity being diminished relates to ‘representation’?</p>
<p>In Eduardo’s argument, race-swapping-as-representation undermines the value of a character that people should otherwise all be able to see themselves in. By ‘race swapping’, it emphasises differences rather than similarities.<br />
In Mac’s discussion that classic Lara’s appearance is significant, by reducing the character’s aggressive beauty, it at least mutes the character from something distinct into something bland (and perhaps is ashamed of the femininity).</p>]]></summary>
</entry>
<entry>
    <title>Using NixOS on an OpenStack Public Cloud</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-09-09-using-nixos-on-an-openstack-public-cloud.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-09-09-using-nixos-on-an-openstack-public-cloud.html</id>
    <published>2023-09-09T00:00:00Z</published>
    <updated>2023-09-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Here are some notes on using NixOS in an OpenStack public cloud.</p>
<p>Recall, NixOS is an operating system which makes use of the Nix package manager to manage its system configuration.<br />
That NixOS allows declarative configuration of a system lends itself to building cloud VM images.</p>
<p>OpenStack is a standard cloud computing platform. It offers services broadly similar to AWS’ EC2, S3, etc..</p>
<p>One option for deploying NixOS configurations to a cloud VM is to run a NixOS VM, and then switch that VM to the configuration you want. – If the cloud provider doesn’t have a NixOS VM image to run, you’ll have to build your own image.</p>
<h3 id="general-approach">General Approach</h3>
<p>The most ‘challenging’ part of this is wanting to run a NixOS VM, but the cloud provider not having a public NixOS image.</p>
<p>It’s possible to build a your own image in a format the cloud provider wants.</p>
<p>The <a href="https://github.com/nix-community/nixos-generators">nix-community’s nixos-generators</a> is a good place to start for this.<br />
Many popular image formats are supported.</p>
<p>In the case of OpenStack images, there’s a generator specifically for that.<br />
I guess for other cloud providers, some customisation may be required; I’d dig through the
code within <a href="https://github.com/NixOS/nixpkgs/tree/master/nixos/maintainers/scripts/">nixos’ maintainers/scripts/</a> and <a href="https://github.com/NixOS/nixpkgs/tree/master/nixos/modules/virtualisation">modules/virtualisation/</a> to get an idea of what was done for the ones which are supported.</p>
<h3 id="using-terraform-to-launch-a-vm-on-an-openstack-public-cloud">Using Terraform to Launch a VM on an OpenStack Public Cloud</h3>
<p>I was doing this from a rather weak Macbook Air (Intel). I figured it’d be easier to build Linux images using Linux; so the first thing to do is launch a linux VM in the cloud.</p>
<p>My experience with using OpenStack on public clouds is that the networking may be handled slightly differently from one public cloud and another.<br />
(The related “used to hope this would work” is the idea of “Terraform works with different clouds” translating to “plenty of Terraform code can be reused in order to easily support a multi-cloud deployment; e.g. have the same service in both AWS and GCP”. Maybe for OpenStack public clouds this could be largely true; but, it’s unlikely Terraform code for networking resources can be reused).</p>
<p>With AWS, I would think that an example of a simple Terraform task is “launch a VM with a publicly accessible IP”.<br />
From what I’ve tried, it’s slightly trickier with OpenStack public clouds.</p>
<p>I had some spare credits with <a href="https://cleura.com/">Cleura</a> to use, and they offer a public cloud with an OpenStack API.</p>
<p>Managing OpenStack resources from outside the cloud console requires an OpenStack user.
I found it convenient to download the RC file for the user, and use <a href="https://direnv.net/">direnv</a> to load those credentials.</p>
<p>Here’s the code listing for a <code>main.tf</code> to achieve this (with some notes below):</p>
<pre><code>terraform {
  required_providers {
    openstack = {
      source  = &quot;terraform-provider-openstack/openstack&quot;
      version = &quot;~&gt; 1.49.0&quot;
    }
  }
}

provider &quot;openstack&quot; {}

# Variables

variable &quot;default_user_name&quot; {
  description = &quot;the name of the default user&quot;
  type        = string
  default     = &quot;debian&quot;
}

variable &quot;ssh_public_key&quot; {
  description = &quot;the SSH public key used to access the VM&quot;
  type        = string
  default     = &quot;ssh-ed25519 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
}

variable &quot;allow_ssh_access_cidr&quot; {
  description = &quot;the CIDR to allow SSH access to. Defaults to 0.0.0.0/0 (unrestricted)&quot;
  type        = string
  default     = &quot;0.0.0.0/0&quot;
}

variable &quot;flavor&quot; {
  description = &quot;the compute flavor to use&quot;
  type        = string
  default     = &quot;1C-2GB-20GB&quot;
}

variable &quot;image_name&quot; {
  description = &quot;the name of the image the VM uses&quot;
  type        = string
  default     = &quot;Debian 11 Bullseye x86_64&quot;
}

variable &quot;instance_name&quot; {
  description = &quot;the name of the VM&quot;
  type        = string
  default     = &quot;debian&quot;
}

# OpenStack Server flavor &amp; image

data &quot;openstack_compute_flavor_v2&quot; &quot;self&quot; {
  name = var.flavor
}

data &quot;openstack_images_image_v2&quot; &quot;self&quot; {
  name        = var.image_name
  most_recent = true
}

# Networking

data &quot;openstack_networking_network_v2&quot; &quot;ext&quot; {
  name = &quot;ext-net&quot;
}

resource &quot;openstack_networking_network_v2&quot; &quot;self&quot; {
  name           = &quot;terraform_vm_network&quot;
  admin_state_up = &quot;true&quot;
}

resource &quot;openstack_networking_subnet_v2&quot; &quot;self&quot; {
  name       = &quot;terraform_vm_subnet&quot;
  network_id = openstack_networking_network_v2.self.id
  cidr       = &quot;192.168.199.0/24&quot;
  ip_version = 4
}

resource &quot;openstack_networking_router_v2&quot; &quot;self&quot; {
  name                = &quot;terraform_vm_router&quot;
  external_network_id = data.openstack_networking_network_v2.ext.id
}

resource &quot;openstack_networking_router_interface_v2&quot; &quot;self&quot; {
  router_id = openstack_networking_router_v2.self.id
  subnet_id = openstack_networking_subnet_v2.self.id
}

resource &quot;openstack_networking_floatingip_v2&quot; &quot;self&quot; {
  pool = data.openstack_networking_network_v2.ext.name
}

# Security

resource &quot;openstack_compute_secgroup_v2&quot; &quot;allow_ssh&quot; {
  name        = &quot;allow_ssh&quot;
  description = &quot;allow SSH from the given CIDR&quot;

  rule {
    from_port   = 22
    to_port     = 22
    ip_protocol = &quot;tcp&quot;
    cidr        = var.allow_ssh_access_cidr
  }
}

resource &quot;openstack_compute_keypair_v2&quot; &quot;self&quot; {
  name       = &quot;terraform_keypair&quot;
  public_key = var.ssh_public_key
}

# Instance

resource &quot;openstack_compute_instance_v2&quot; &quot;self&quot; {
  name            = var.instance_name
  flavor_id       = data.openstack_compute_flavor_v2.self.id
  key_pair        = openstack_compute_keypair_v2.self.name
  security_groups = [openstack_compute_secgroup_v2.allow_ssh.name]
  user_data       = &lt;&lt;-USER
  #cloud-config
  system_info:
   default_user:
    name: ${var.default_user_name}
  chpasswd: { expire: false }
  ssh_pwauth: false
  package_upgrade: true
  manage_etc_hosts: localhost
  runcmd:
    - &quot;curl --proto &#39;=https&#39; --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install --no-confirm&quot;
  USER

  block_device {
    uuid                  = data.openstack_images_image_v2.self.id
    source_type           = &quot;image&quot;
    volume_size           = 20 # GBs
    boot_index            = 0
    destination_type      = &quot;volume&quot;
    delete_on_termination = true
  }
}

resource &quot;openstack_compute_floatingip_associate_v2&quot; &quot;self&quot; {
  floating_ip = openstack_networking_floatingip_v2.self.address
  instance_id = openstack_compute_instance_v2.self.id
}

# Outputs

output &quot;public_ipv4&quot; {
  value = openstack_networking_floatingip_v2.self.address
}</code></pre>
<p>Again, I found the networking details to be a quite complicated.<br />
The details were found by observing what resources were created when creating a VM with a public IP in the console.<br />
Cleara uses the public network <code>ext-net</code>.<br />
I’m not sure on the exact details, but I create a private network with a subnet, and to get a public IP (i.e. a floating ip in <code>ext-net</code>) to route to the VM, I create a router for the <code>ext-net</code> and a router interface which routes that to the private subnet. That public IP then gets associated with the VM.</p>
<p>Another part that can be annoying with OpenStack is specifying the VM resources (CPU/memory/storage).<br />
It’s more flexible than AWS’ “c5.small/medium/large”.<br />
One thing I found annoying it it’s not quite so freeform as <code>"xC-yGB-zGB"</code> for arbitrary x,y,z; I had to list the flavors to find one.<br />
(The impression I got was that the console lets you choose the number of cpu/mem/disk, so the flavor is created on demand for that).</p>
<p>Idiosyncracies of OpenStack clouds aside, I think the other details are relatively straightforward.<br />
The name <code>"Debian 11 Bullseye x86_64"</code> comes from running <code>openstack images list</code>.<br />
(An easy way to get the <code>openstack</code> client is to run <code>nix shell nixpkgs#openstackclient</code>).</p>
<p>Looking at the user data passed to the VM…</p>
<pre><code>#cloud-config
system_info:
 default_user:
  name: ${var.default_user_name}
chpasswd: { expire: false }
ssh_pwauth: false
package_upgrade: true
manage_etc_hosts: localhost
runcmd:
  - &quot;curl --proto &#39;=https&#39; --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install --no-confirm&quot;</code></pre>
<p>…this uses <a href="https://cloud-init.io/">cloud-init</a>, which declares some things we want set up in the VM.<br />
The <code>curl ... | sh</code> installs the <a href="https://github.com/DeterminateSystems/nix-installer">determinate-systems nix installer</a>.<br />
This means the VM will have <code>nix</code> available shortly after the VM launches. (Running the command <code>cloud-init status</code> on the launched VM shows whether cloud-init has finished).</p>
<p>Running the Terraform file involves (as is usual):</p>
<pre><code>terraform apply</code></pre>
<p>(and removing these resources with <code>terraform destroy</code>).</p>
<p>The public IP is an <code>output</code>, which allows SSH’ing into the VM with a command like:</p>
<pre><code>ssh debian@(terraform output -json public_ipv4 | jq -r)</code></pre>
<h3 id="building-the-nixos-image-for-openstack">Building the NixOS Image for OpenStack</h3>
<p>This is the <code>flake.nix</code> file. Below, some implementation notes, and the commands for building/uploading.</p>
<pre><code>{
  inputs = {
    nixos-generators = {
      url = &quot;github:nix-community/nixos-generators&quot;;
      inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    };
    nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-22.11&quot;;
    rgoulter.url = &quot;github:rgoulter/nix-user-repository&quot;;
  };

  outputs = {
    self,
    nixos-generators,
    nixpkgs,
    rgoulter,
    ...
  }: {
    packages.&quot;x86_64-linux&quot;.small-openstack = nixos-generators.nixosGenerate {
      pkgs = nixpkgs.legacyPackages.&quot;x86_64-linux&quot;;
      format = &quot;openstack&quot;;
      modules = [
        rgoulter.nixosModules.cloud-interactive
        rgoulter.nixosModules.ssh
        rgoulter.nixosModules.ssh-users
        rgoulter.nixosModules.tailscale
      ];
    };
  };
}</code></pre>
<p>Recall, a <code>flake.nix</code> file is more/less equivalent to a <code>package.json</code>/<code>Cargo.toml</code>/etc. project file,
and is a standard entry point into a Nix codebase.</p>
<p>Here, the OpenStack image is declared as a package, using <a href="https://github.com/nix-community/nixos-generators">nixos-generators</a>
and its <code>nixosGenerate</code> package. (The OpenStack specific part is the <code>format = "openstack";</code> attribute. As mentioned above, you can dig into the details in <code>nixos/</code>, which <code>nixos-generators</code> makes use of).</p>
<p>The <code>rgoulter.nixosModules</code> refers to the <a href="https://github.com/rgoulter/nix-user-repository/tree/95968968d32f7a6754978f099e975ca56b916977/modules">modules</a> in my <code>nix-user-repository</code>. (Though, you could just inline these all as one module in this <code>flake.nix</code> file, etc.).</p>
<p>e.g. cloud-interactive ensures that some CLI tools I like are installed:</p>
<pre><code>{
  config,
  lib,
  pkgs,
  ...
}: {
  environment.systemPackages = with pkgs; [
    direnv
    fd
    fish
    git
    helix
    jq
    ripgrep
    starship
    tmux
  ];
  nix = {
    extraOptions = &#39;&#39;
      experimental-features = nix-command flakes
    &#39;&#39;;
  };
  security.sudo.wheelNeedsPassword = false;
}</code></pre>
<p>and <code>ssh-users</code> declares the user I log in with:</p>
<pre><code>{
  config,
  lib,
  pkgs,
  ...
}:
{
  users.users.rgoulter = {
    isNormalUser = true;
    extraGroups = [
      &quot;wheel&quot;
    ];
    openssh.authorizedKeys.keys = [
      &quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOmQ9/u9qV9Vvy2pbcPtGiAmIrhXdi/vY6IesJ5RYpS4&quot;
    ];
  };
}</code></pre>
<p>(This doesn’t necessarily need to be hard coded into the image; but, for this use case, doing it this way is simple).</p>
<p>With this <code>flake.nix</code>, on a Linux computer with <code>nix</code> installed (and flakes, nix-command enabled, as the determinate-systems does),
the image is built by running a command like:</p>
<pre><code>nix build .#small-openstack</code></pre>
<p>(A quick &amp; dirty approach is to just copy the <code>flake.nix</code> file to the Linux VM we’re running. But, it’d also be possible to have a <code>nixosGenerate</code> package in a <code>flake.nix</code> in a repository else &amp; refer to it using the appropriate flake URI).</p>
<p>The resulting file is linked to by <code>./result/nixos.qcow2</code>.</p>
<h3 id="uploading-the-image">Uploading the Image</h3>
<p>With the <code>openstack</code> client (use <code>nix shell nixpkgs#openstackclient</code> to make it available to the shell),
and appropriate openstack credentials (e.g. copying the openstack user RC file over and <code>source</code>’ing it),
the built image can be uploaded with:</p>
<pre><code>openstack image create \
  --private \
  --disk-format qcow2 \
  --container-format bare \
  --file ./result/nixos.qcow2 \
  my-nixos</code></pre>
<p>which creates the OpenStack image <code>my-nixos</code>.</p>
<h3 id="launching-a-vm-with-our-private-nixos-image">Launching a VM with Our Private NixOS Image</h3>
<p>This is straightforward, by re-using the code from “Using Terraform to Launch a VM”.</p>
<p>Simply change the <code>name</code> of the image in the <code>data.openstack_images_image_v2</code> block to <code>"my-nixos"</code>. (e.g. change the value of the Terraform variable <code>image_name</code>). – The NixOS image ignores the user data.</p>
<h3 id="switching-configuration-after-launch">Switching Configuration After Launch</h3>
<p>There are uses cases where it makes sense to ‘switch’ the NixOS configuration after the VM has launched.</p>
<p>There are plenty of options for doing this.</p>
<p>I liked using a command like:</p>
<pre><code>ssh -A &quot;rgoulter@${IP}&quot; -- &quot; \
  sudo sh -c &#39;mkdir -p ~/.ssh &amp;&amp; \
  chmod 700 ~/.ssh &amp;&amp; \
  ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts &amp;&amp; \
  echo switch to ${FLAKE_URI} &amp;&amp; \
  nixos-rebuild switch --flake ${FLAKE_URI}&#39; \
&quot;</code></pre>
<p>I think another option instead of doing the <code>ssh-keyscan</code> here is to add it to
<a href="https://search.nixos.org/options?channel=23.05&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=services.openssh.knownHosts">services.openssh.knownHosts</a>.</p>]]></summary>
</entry>
<entry>
    <title>Two Kinds of Small Keyboards</title>
    <link href="http://www.rgoulter.com/blog//posts/programming/2023-08-29-two-kinds-of-small-keyboards.html" />
    <id>http://www.rgoulter.com/blog//posts/programming/2023-08-29-two-kinds-of-small-keyboards.html</id>
    <published>2023-08-29T00:00:00Z</published>
    <updated>2023-08-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In an earlier post, <a href="../programming/2023-06-29-opinion-on-small-keyboards-and-big-spacebars.html">“Opinion on Small Keyboards and Big Spacebars”</a>,
I discussed the design flaws of traditional keyboards. – Mainly, traditional keyboards have big spacebars. Our thumbs are stronger than our pinky fingers, so it would be better to be able to use the thumbs more than the pinky fingers. A large spacebar results in the opposite: our thumbs only get to use one key, and our pinky fingers get used for all sorts of <em>frequently used</em> keys. The other flaws being that the traditional keyboard is asymmetrical, and has a row stagger, etc.</p>
<p>I neglected to explicitly describe the link between “big spacebar is stupid” and “small keyboards are good”.</p>
<p>It happens to be the case that most keyboards which fix those design problems of the traditional keyboard layout are small. – Although there are small keyboards which don’t fix the traditional keyboard layout’s design flaws.</p>
<p>So, I’d suggest this way of categorising (small) keyboards:</p>
<ol type="1">
<li><p>Traditional Keyboard Layouts</p>
<ul>
<li>Big Spacebar</li>
<li>Row-Stagger</li>
<li>Essentially the same as small keyboards on a laptop</li>
</ul></li>
<li><p>Ergonomic Keyboard Layouts</p>
<ul>
<li>Many thumb keys</li>
<li>Ortholinear, Column Stagger (or similar)</li>
</ul></li>
</ol>
<p>There is a third group, of non-traditional keyboards which are also not ergonomic; or with other design incoherencies. I don’t think these are good at all: if it’s got a traditional layout, it’s not good, but it’s <em>understandably</em> bad. (Traditional = retains familiar design elements). So, if a design isn’t traditional, it will take time to get used to; but, effort spent getting used to the keyboard doesn’t result in an ergonomic keyboard.</p>
<h2 id="techniques-of-small-keyboard-keymaps">Techniques of Small Keyboard Keymaps</h2>
<p>I distinguish “big spacebar =&gt; traditional” vs “many thumbkeys =&gt; ergonomic” small keyboards in part because of the techniques small keyboards use:</p>
<p>Small keyboards make use of techniques like “layers”, “tap-hold”, “chords”, etc.</p>
<p>Layers: Layers are a more general mechanism of the “Fn” key, something laptop users are familiar with. e.g. on Macbooks, there are a row of F-keys F1-F12; but these keys also have special functionality such as “screen dimmer / brighter”. By holding the Fn key, the key changes its functionality.<br />
The alternate functionality is considered a “layer” of a keymap; and a key like Fn will momentarily switch keys to use that “layer” of functionality.</p>
<p>Tap-Hold: The keys behaves one way when tapped, and behaves another way when held down. e.g. For programmers, I’ve seen some will change the CapsLock key to “Esc when tapped, Ctrl when held”; Ctrl is a useful key in many shortcuts, and Esc is a useful key in programs such as vim.<br />
Home Row Modifiers: Using Tap-Hold keys to put the modifier keys “Shift, Ctrl, Win, Alt” underneath the home row keys fdsa and jkl;.</p>
<p>Some keyboard layouts don’t allow the possibility of pressing keys like F1-F12, etc., even in layers.<br />
These keyboard layouts aren’t layouts which can be used for serious purposes.<br />
– Whereas, even a small keyboards, even those which lack a number row, will likely still allow users to enter numbers (on a layer).</p>
<p>Albeit, sure, a keyboard without a number row isn’t as easy to use for playing FPS games.</p>
<h2 id="why-thumb-keys-matter">Why Thumb Keys Matter</h2>
<p>Thumb keys make a keyboard more ergonomic for two reasons:</p>
<ul>
<li><p>Thumb keys allow using keys with the thumb instead of the pinky fingers (e.g. it’s useful to put backspace, enter, tab, escape as well as space on thumb keys).</p></li>
<li><p>“Fn” keys on thumbs (especially with tap-hold, so the thumb key can be used for something else too) also avoids having to use the pinky fingers.</p></li>
</ul>
<p>Most “traditional” small keyboards I’ve seen have Fn keys which are clearly meant to be pushed using the pinky fingers.</p>
<p>Whereas, with ergonomic small keyboards, the thumbs get to be useful, and allow the pinky fingers to work less.</p>
<p>I’d say essentially the difference is:</p>
<ul>
<li><p>‘Traditional’ small keyboards use Fn keys because the keyboard <em>must</em> be smaller. (e.g. on laptops).</p></li>
<li><p>‘Ergonomic’ small keyboards are (often) small because they do not need
to be bigger; the full functionality of a standard keyboard is within
easy reach of the thumbs and fingers.</p></li>
</ul>
<h2 id="example-keymap">Example Keymap</h2>
<p>Here’s an example of a keymap for a small keyboard with several thumbkeys.</p>
<p><img src="../../images/small-keyboards/layout-ortho-4x12.jpg" /></p>
<p>To step through it a bit more slowly:</p>
<ul>
<li><p>The keymap retains many mnemonics / spacial similarities to traditional keyboards:</p>
<ul>
<li><p>The keys <code>0-9</code> (Well, <code>1-9, 0</code>) are available in the same column as on a standard keyboard, just brought a row down. (And not staggered).</p></li>
<li><p>The <code>~</code> key is still in the top-left.</p></li>
<li><p>The <code>-=</code> keys are adjacent to each other.</p></li>
<li><p><code>PrintScr</code>/<code>ScrollLock</code>/<code>PauseBrk</code> remain adjacent to each other.</p></li>
<li><p><code>Ins</code> is ‘above’ <code>Del</code>, in the same way the symbols are ‘above’ numbers.</p></li>
</ul></li>
<li><p>And some things I think are improvements:</p>
<ul>
<li><p>The <code>[]</code> keys have been brought closer to the middle of the keyboard;
but are on the same columns as <code>()</code>.</p></li>
<li><p><code>/\</code> are now adjacent to each other.</p></li>
<li><p>The cursor keys follow an ‘hjkl’ vim-style setup. The Home/PgDn/PgUp/End follows the same idiom, and is placed in the same columns.</p></li>
</ul></li>
<li><p>Symmetrical and reduced usage of pinky finger:</p>
<ul>
<li><p>The modifier keys (shift/ctrl/win/alt) are available in similar places to a traditional keyboard; but these don’t need to be used, since the keymap has home row modifiers.</p></li>
<li><p>Similarly: Backspace, Tab, Esc can be hit with the pinky fingers; but, it’s more convenient to use the thumbkeys provided for this.</p></li>
</ul></li>
</ul>
<h2 id="gallery-of-examples">Gallery of Examples</h2>
<p>Applying the idea of “it’s good to use the thumbs more”/“it’s bad to use the pinky”, I think looking at some examples will help why I think it makes sense to categorise traditional (small) keyboard differently than the keyboards which offer several thumb keys.</p>
<h2 id="traditional-and-non-ergonomic">Traditional and non-Ergonomic</h2>
<p><img src="../../images/small-keyboards/apple.jpg" /></p>
<p>Apple’s keyboard.<br />
This is more/less like a Macbook keyboard.</p>
<p>Note that the Fn key is in the corner, so you’d have to use your pinky finger.</p>
<p>The thumbs pretty much only have the one big spacebar they can press, without moving the hands from home row.</p>
<p><img src="../../images/small-keyboards/pok3r.jpg" /></p>
<p>A Poker keyboard, which I understand to be the original ‘small’ mechanical keyboard. – The Fn key is in the corner, so you’d have to use your pinky finger to hold it.</p>
<p>The thumbs pretty much only have the one big spacebar they can press, without moving the hands from home row.</p>
<p><img src="../../images/small-keyboards/hhkb.jpg" /></p>
<p>A HHKB (“happy hacking keyboard”). – The Fn key is in the corner, so you’d have to use your pinky finger to hold it.</p>
<p>The thumbs pretty much only have the one big spacebar they can press, without moving the hands from home row.</p>
<p>I don’t think the hacker is going be all that happy given how much the keyboard requires using the pinky instead of the thumb.</p>
<p><img src="../../images/small-keyboards/daisy.jpg" /></p>
<p>A Daisy keyboard. – The Fn key is to the right of shift, so you’d have to use your pinky finger to hold it.</p>
<p>The thumbs pretty much only have the one big spacebar they can press, without moving the hands from home row.</p>
<p>– This keyboard lacks a number row. I’d describe “keyboards without a number row” as “<em>fashionably</em> small”. With two hands on the keyboard, you’re not missing much by going without a number row. (Although, a number row is more/less essential for playing FPS games). But, it’s trendy to have fewer keys.</p>
<p><img src="../../images/small-keyboards/vortex-core.jpg" /></p>
<p>The Vortex Core.</p>
<p>Here, the Fn/Pn keys are <em>almost</em> reachable by the thumb. But, I don’t get the impression the intention was for the thumbs to hit these keys.</p>
<p>Here the thumbs do actually get to hit one key <em>each</em>. – It’s not enough to cover all of “space/backspace/enter/etc.”, but it’s an improvement.</p>
<p><img src="../../images/small-keyboards/alice.jpg" /></p>
<p>The Alice.</p>
<p>I think the Alice keyboard layout is pretty bad.</p>
<p>It’s apparently different enough from a traditional keyboard layout that some people struggle typing on it. But, it’s also not an ergonomic keyboard layout.</p>
<p>e.g. the <code>6</code> key is not above the <code>y</code> key. It’s common to see people put the <code>b</code> key on the right hand side of the keyboard(!!!). It’s not symmetrical.</p>
<p>– Anyway.</p>
<p>The keyboard does offer maybe <em>three</em> whole keys shared between the two thumbs.</p>
<p>And (hard to tell from this picture, but) the Fn key is off in the corner. – The intention is to use the pinky finger for it.</p>
<h4 id="ortholinear">Ortholinear</h4>
<p><img src="../../images/small-keyboards/id75.jpg" /></p>
<p>The ID75. This is the same size as the Poker keyboard above.</p>
<p>I don’t know how many keys the Poker has, but this clearly has more.</p>
<p>For the thumbs, there are at least two to three for <em>each</em> thumb.</p>
<p>With that many thumb keys, it’s easy to see how this keyboard could have a good keymap like the example given above.</p>
<p>Here, the user has the alphabetical characters in a pseudo-split arrangement.</p>
<p><img src="../../images/small-keyboards/xd75.jpg" /></p>
<p>Another 5x15 Ortho. Here, the alphabetical characters are kept together. It’s an option.</p>
<p><img src="../../images/small-keyboards/boardsource-ortho4x12.jpg" /></p>
<p>For the thumbs, there are at least two to three for <em>each</em> thumb.</p>
<p>With that many thumb keys, it’s easy to see how this keyboard could have a good keymap like the example given above.</p>
<p><img src="../../images/small-keyboards/planck.jpg" /></p>
<p>The Planck, with a 2U spacebar.</p>
<p>So, it’s at least one or two keys for each thumb. But, the intention is clearly for the thumb to get used.</p>
<p><img src="../../images/small-keyboards/bm40-alt.jpg" /></p>
<p>Following the logic of “use the thumb more than the pinky fingers”, one option is to do the same ‘pseudo-split’ arrangement here.</p>
<ul>
<li><p>The pinky fingers don’t have to stretch to reach an outer column.</p></li>
<li><p>The thumbs get at least two to three keys each.</p></li>
</ul>
<h4 id="split-unrelated-to-traditional-vs-ergonomic">“Split”: Unrelated to “Traditional vs Ergonomic”</h4>
<p>For many, a split keyboard is a big ergonomic improvement over a non-split keyboard.</p>
<p>However, I’d still say that the keyboards fall under either “traditional” or “ergonomic” categories.</p>
<p><img src="../../images/small-keyboards/kineses-edge.jpg" /></p>
<p>This is clearly ‘just’ a traditional keyboard layout, but split.
(It’s only ‘small’ in the sense that there’s no numpad).</p>
<p>There are more thumb keys than a traditional keyboard only in the sense that each thumb now gets to press one key.</p>
<p><img src="../../images/small-keyboards/helix.jpg" /></p>
<p>Whereas with this Helix keyboard, the same remarks about the ortholinear keyboards apply here.</p>
<p>The thumb gets to use at least two to three keys each.</p>
<h4 id="column-staggered">Column-Staggered</h4>
<p>Most of what I dislike about row-staggered is that it’s asymmetrical. An ortholinear grid just makes more sense as a default.</p>
<p>Many ergonomic keyboards opt for a column stagger.</p>
<p><img src="../../images/small-keyboards/reviung41b.jpg" /></p>
<p>The Reviung 41.</p>
<p>Here, the thumbs can reach the same as the Planck with the 2U spacebar: one to two keys each.</p>
<p><img src="../../images/small-keyboards/kyria.jpg" /></p>
<p>The Kyria.</p>
<p>The thumbs can easily reach two or three keys each; but there are several more keys available to the thumb if the hand moves a bit.</p>
<p><img src="../../images/small-keyboards/ferris-sweep-bling.jpg" /></p>
<p>The Ferris Sweep.</p>
<p>I mostly see this keyboard associated with those who advocate for 34-key keyboards.</p>
<p>But, again. The keyboard clearly doesn’t rely on the pinky finger much. The keyboard gives each thumb two keys.</p>
<p><img src="../../images/small-keyboards/klor.jpg" /></p>
<p>The Klor.</p>
<p>I’m omitting the famous Corne/crkbd from these examples. Many keyboards look like variations of the crkbd.</p>
<p>The Klor is the most interesting keyboard I’ve come across in DIY, split column-staggered family of keyboards. (e.g. It splays its pinky column).</p>
<p>But the same observation applies to these: the thumbs get two-three keys each, and with five columns for the fingers, the pinky finger isn’t used so much.</p>
<h4 id="i-cant-understand-why-anyone-would-like-row-stagger">I Can’t Understand Why Anyone Would Like Row Stagger</h4>
<p>I’ve seen that some people prefer the look of the row-stagger keyboard.</p>
<p>I don’t mean those who only know the traditional layout and don’t want to learn ortho. – I mean people who have learned about symmetrical keyboards and still prefer the traditional row-stagger.</p>
<p>I can’t understand why.</p>
<p>I can almost understand someone considering this symmetrical:</p>
<p><img src="../../images/small-keyboards/row-stagger-1.png" /></p>
<p>But I can’t understand anyone who knows what human hands looks like thinking this layout makes sense:</p>
<p><img src="../../images/small-keyboards/row-stagger-2.png" /></p>
<p>Or to better illustrate, if you look at just the homing keys (f, j) and the keys above-inner and below-inner for the left hand side:</p>
<p><img src="../../images/small-keyboards/row-stagger-3.png" /></p>
<p>The distance between ‘jn’ is closer than on an ortholinear board; but the distance between ‘fb’ is <em>way</em> farther.</p>
<h4 id="key-takeaway-from-the-examples">Key Takeaway from the Examples</h4>
<p>Most of the traditional small keyboards really only allowed the thumbs to use one or two keys total, whereas the ergonomic ones allowed at least two thumb keys each.</p>
<p>Most of the traditional small keyboards made strong use of the pinky finger, whereas many of the ergonomic keyboards lacked an extra outer column for the pinky fingers to use.</p>]]></summary>
</entry>

</feed>
