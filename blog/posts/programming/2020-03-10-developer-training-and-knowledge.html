<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Developer Training and Knowledge - Richard Goulter's Blog</title>

        <!-- My (Old) CSS theme -->
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />

        <!--
            jQuery & jQueryUI
        -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script src="https://code.jquery.com/ui/1.11.3/jquery-ui.min.js"></script>
        <link rel="stylesheet" type="text/css" href="https://code.jquery.com/ui/1.11.3/themes/smoothness/jquery-ui.css" />

        <!--
            Pandoc Style CSS
            (for syntax highlighted snippets)
        -->
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />

        <!--
            Bootstrap
        -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

        <style>
            /*
             * Bootstrap defines blockquote as 17px,
             * so it looks stupidly large in my blogposts. */
            blockquote {
                font-size: 14px;
            }
        </style>

        <!--
            Waypoints, and Waypoints-Sticky,
            so we can do this:
            http://imakewebthings.com/waypoints/shortcuts/sticky-elements/
        -->
        <script src="../../js/jquery.waypoints.min.js"></script>
        <script src="../../js/sticky.min.js"></script>

        <!-- My analytics stuff -->
        <script src="../../js/my_analytics.js"></script>
        <script src="../../js/my_analytics_debug.js"></script>

        <!--
            TOCify
        -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js"></script>
        <!--
            Patched TOCify css file.
            (Don't want fixed `.tocify`).
        -->
        <link rel="stylesheet" type="text/css" href="../../css/jquery.tocify.css" />

        <style>
        .navbar {
            margin-bottom: 0px;
        }

        .banner-image {
            width:100%;
        }

        .banner {
            margin-left: 0px;
            margin-right: 0px;
        }

        body {
            background-color: #e2e2e2;
        }

        #page {
            padding-left:0;
            padding-right:0;
            background-color: #ffffff;
        }
        </style>

        <!-- Google Analytics -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-73116015-1', 'auto');
          ga('send', 'pageview');
        </script>
    </head>
    <body>
        <div id="page" class="container">
            <!-- This, with no padding on left/right -->
            <div class="banner">
                <nav class="navbar navbar-default">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>

            <!-- The Hamburger -->
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../">Richard Goulter's Blog</a>
    </div>

    <div class="collapse navbar-collapse" id="navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
            <li><a href="../../">Home</a></li>
            <li><a href="../../yi.html">Yi</a></li>
            <li><a href="../../emacs.html">Emacs</a></li>
            <li><a href="../../archive.html">Archive</a></li>
        </ul>
    </div>
</nav>

            </div>

            <hr style="margin: 0px; border-top: 5px solid black;" />

            <div id="content" class="container">
                <h1>Developer Training and Knowledge</h1>
                <div class="info">
    Posted on March 10, 2020
    
        by Richard Goulter
    <br />
    
    Tags: 
    
</div>

<p>“What are the costs?” ought to be a natural question provided alongside “what are the benefits?”. This doesn’t get asked often enough in the discussions of new tools/technologies.<br />
The costs/benefits implicitly impact discussions since the trade-offs will be different in different situations.<br />
As a developer, I ought to have this in mind when consuming discussions.</p>
<p>To get better as a developer, I ought to increase my experience and skills:<br />
Experience is what I gain from recovering from mistakes.<br />
Skills I have are what I get from learning.<br />
So, online discussions about new tools/technolgies are relevant because they ask: “what skills should programmers have?”, and this is implicitly subject to “how much time/effort should be spent learning?”.</p>
<h3 id="costs-and-benefits">Costs and Benefits</h3>
<p>The universal answer to questions in computing is “it depends”.</p>
<p>Different groups/contexts consider costs and benefits differently.</p>
<p>There are innumerably many factors which can be better or worse between different tools. e.g. speed of development, ease of maintenance, ease of writing, ease of reading, ease of learning, similarity to other tools, compilation/runtime speeds, verbosity, implicit vs explicit, etc.<br />
– These will have different levels if importance to different people.</p>
<p>e.g. Steve Yegge’s <a href="https://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html">Portrait of a n00b</a> discusses that “experts” prefer code to be terse, whereas “n00bs” prefer lots of supporting information around the code itself.<br />
For the n00bs, code has a high cost to read, and so this cost is lowered with comments, metadata, and having less code on the screen. For experts, dense code has a higher signal-to-noise ratio.<br />
In its takeaways, the article suggests that paying the cost of metadata doesn’t necessarily give any benefit; but that e.g. surely the benefit of documentation for public-facing APIs is always worth paying for.<br />
– In <a href="http://archive.is/RalDb">this archive.is snapshot of a Google+ post</a>, Yegge further builds on this idea, with different preferences for ‘liberal’ vs ‘conservative’ programmers. The split is seen as different levels of comfort with the risk of breaking code in production. (“just fix it” vs “high level of confidence in correctness”).</p>
<h5 id="why-learn-and-what-to-learn">Why Learn and What to Learn</h5>
<p>This would be irrelavent if you just stuck with the tools/skills you’ve got and never bother to learn anything new.</p>
<p>The main external reasons to need to learn things are because you need to for school, or because the tools are used where you work.<br />
<em>Maybe</em> you’ll want to study more in the hopes of being more efficient in those roles.</p>
<p>As far as I can tell, though, the main reason to learn outside of that is ‘for fun’.<br />
Geeks argue about all this shit because it’s interesting to.</p>
<p>If you’re not learning some skill because you explicitly have to, or not just because you’re naturally interested in it, then at-best you’re making a bet on getting a higher reward (at some point in the future) than the cost you’re paying to learn.</p>
<p>Though, maybe even then there can be some benefit to that.<br />
e.g. <a href="http://www.paulgraham.com/pypar.html">Python Paradox</a> suggests that it’s lower-risk to try and hire developers who use “comparatively esoteric” programming languages like Python. (This was written in 2004), since the only people who would bother to learn Python are people who find it interesting. (Since you’re not going to get a job writing in Python).</p>
<p>This is also another way of describing <a href="https://mcfunley.com/choose-boring-technology">‘Choose Boring Technology’</a>. (It’s less risky to choose technology with known costs; as a rule of thumb, only use a few ‘new technologies’). The perjoratives “Hype-Driven Development” and “Resume Driven Development” also try and push back against choosing technologies for the benefit without understanding the cost.</p>
<h3 id="forever-learning-and-forever-forgetting">Forever Learning and Forever Forgetting</h3>
<p>Developers tend to take a ‘just in time’ approach to learning for work; taking advantage of ‘monkey-see monkey-do’.<br />
This somewhat changes the interpretation of “forever learning” from “there’s always more to learn, so I’ll be forever learning” to “I’m always working with different software development tools, so I’ll be forever learning”.</p>
<p>Either interpretation of “forever learning” would be fine,<br />
but I’m not sure there’s much adjustment for “forever forgetting”:<br />
In The Atlantic’s <a href="https://www.theatlantic.com/science/archive/2018/01/what-was-this-article-about-again/551603/">Why We Forget Most of the Books We Read</a>, the author mentions a <a href="https://en.wikipedia.org/wiki/Forgetting_curve">“forgetting curve”</a>. The article discusses that tools like the internet provide an ‘external memory’, allow us to get information without having to remember it ourselves. The result is that ‘recall memory’ (“ability to spontaneously call information up in your mind”) is less important than ‘recognition memory’ (remembering where the information is, and how to access it).</p>
<p>This feels like a pretty good model to me.</p>
<p>Maybe this means incremental reading isn’t such a bad idea. (Though it’s certainly not a <em>common</em> idea).</p>
<h5 id="boost-recall-with-spaced-repetition">Boost Recall with Spaced Repetition</h5>
<p>Programmers are familiar the idea of external memory. Search engines lead us to StackOverflow, or GitHub issues.<br />
Often documentation is pretty good, and editors with LSP support can even show this as you type out the code.<br />
Things like compiler errors, editor discoverability, and auto-complete help too.</p>
<p>Recall memory seems a bit more dull.<br />
For the tools/languages which I’m familiar with, there’ll be a lot which I don’t need to lookup. e.g. I can remember how to output text to STDOUT, how to import a package, how to define a function.</p>
<p>I think recall-misses where I need to stop to look things up don’t necessarily interrupt a state of flow.<br />
I think “having to look up documentation for stuff unrelated to the problem domain” is less of a problem than not being able to type. I think effective use of a text editor (like with vi or emacs or kakoune keybindings) is more important than either.<br />
– But, still: Surely it’d be great if I could recall things without spending time time to use a search engine to look for an answer.</p>
<p>To improve recall retention, what you want to recall would either need to be something you frequently use, or something you study.</p>
<p>Anki is ‘Spaced Repetition Software’ (SRS).<br />
It’s a flashcard program, but the intervals between when it tests you on a flashcard increase for each correct recall of that card.<br />
– Most of its users (as far as I can tell) use it for vocabulary studies, or for medical studies. As <a href="https://en.wikipedia.org/wiki/Spaced_repetition">Wikipedia’s page on Spaced Repetition</a> puts it: “spaced repetition is commonly applied in contexts in which a learner must acquire many items and retain them indefinitely in memory”.</p>
<p>This post <a href="http://augmentingcognition.com/ltm.html">“Augmenting Long Term Memory”</a> discusses use of Anki. e.g. to assist in digesting technical papers. (e.g. start with being able to recall surface level facts, then incrementally aim to recall facts which build upon those).<br />
The article also points out some drawbacks. It’s difficult to use Anki to improve recall for things you don’t actually care about. Adding flashcards isn’t (and probably shouldn’t be) low-effort. The article’s rule of thumb is it takes about 7 minutes of study per card per 20 years for a good flashcard (if each review of the card is 8 seconds).<br />
– The article also generally suggests against using Anki to remember APIs in the hope that this would one day be useful. It’s better to first know an API before trying to Ankify things about it. But it’s also a bad idea to keep Anki flashcards that you don’t care about around, e.g. if you aren’t likely to use the API again.</p>
<p>For myself, I’ve used Anki for a year and a half. Studied ~80% of those days. Added around 3900 cards. The vast majority of these cards are for vocabulary.<br />
– I do feel Anki does have a great benefit for the cost put into it. But it’s a bit more effort than “recall for free”.</p>
<h5 id="personal-knowledge-base">Personal Knowledge Base</h5>
<p>I’m beginning to like the idea of using a zettelkasten approach to storing reference.<br />
This seems a more suitable approach between “ankify everything” and “go to the effort of recalling exactly what you came across”.</p>
<p>The important part of zettelkasten notes, as I understand it, is that each note in the system is small, the note hyperlinks to other notes, and the use of tagging helps with random lookup/search of the notes.</p>
<p>In particular, there’s not necessarily a hierarchical structure to the notes. The benefit of this is you don’t have to try to remember where a note was put.</p>
<h3 id="examples">Examples</h3>
<p>Some examples in my mind make a bit more sense with “cost vs benefit”.</p>
<ul>
<li><p>I’m hopeful for elm-lang. It strikes me as (relatively) low-cost to learn to use, and I think this cost is far outweighed by the benefits gained.</p></li>
<li><p>I’m pessimistic about the value of Rust for general purpose software development. In constrast to elm-lang (where elm-lang’s syntax was weird, but the logic was easy to follow): Rust’s syntax is kinda sorta weird, writing something you’ve not done before in Rust can be hard even with some familiarity with the language, and Rust’s USP isn’t a big win in common cases.<br />
Using Rust is surely high-reward in some use cases; but I’m not sure it ever becomes low-cost in most cases.</p></li>
<li>I was fascinated by <a href="https://twitter.com/Jonathan_Blow/status/781597528047230976">the argument in favour of the array-processing programming language K</a> and <a href="https://news.ycombinator.com/item?id=22504106">the HN discussion</a>.
<ul>
<li>What strikes me the most as “using a concise sequence of operators” is to using “FP-ish methods like sum” as those are to “explicit for loop”.
<ul>
<li>The best I can make of it is: you’d have to go and learn what each of the symbols does. There aren’t <em>that</em> many and there’s a big benefit to learning them. And without experience(?) you should’t have the expectation to be able to quickly read K programs.</li>
<li>Which is enough to convince me that the idea of a language like that isn’t completely crazy.</li>
<li>But also that: I don’t think using “FP-ish methods” isn’t too far from developers are used to, or able to read. Whereas seeing <code>q::n 9'a</code> doesn’t really bring <a href="https://kparc.com/edit.k">“syntax coloring”</a> to mind.<br />
(So I could believe taking the time to learn K would be worthwhile, I don’t think anyone should be surprised that not everyone sees the benefits when the costs are so apparent).</li>
</ul></li>
<li>I also found the post’s response to the idea of readability interesting. A symbol operator isn’t necessarily harder to read than a full word. With the word you might think you can guess what it means, but you might be wrong. An operator is going to be precise.
<ul>
<li>There are languages which I’m more familiar with which somewhat take this approach.<br />
e.g. Scala’s <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">List</a> keeps <code>+:</code> (for ‘prepend’) and <code>:+</code> (guess what for?), but deprecates <code>/:</code> and <code>:\</code>.<br />
e.g. Haskell has a few (e.g. see <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/doc-index-All.html">the start and end of base’s index</a>).</li>
<li>Overall, I don’t think it’s absolute that terms are ambiguous or that using only operators would give a more accurate understanding of the program ‘for free’.</li>
</ul></li>
</ul></li>
<li>Category Theory. As I understand it, Category Theory is simple, but not easy. So the cost to studying it isn’t so low. But it’s also kinda hard to see the benefits beyond it being inherently interesting.<br />
It’s neat to see <a href="https://blog.ploeh.dk/2019/12/30/semigroup-resonance-fizzbuzz/">unusual solutions to fizzbuzz like ploeh.dk’s</a>; but the code itself can be understood without category theory. (Well, readable if you can recall what <code>&lt;$&gt;</code> and <code>&lt;&gt;</code> do).
<ul>
<li>FWIW, “simple but not easy” seems like a reasonably fine fit for Anki flashcards.</li>
</ul></li>
<li>Haskell.
<ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a> is really cute. And straightforward.
<ul>
<li>With that I can make simple-ish toy projects and then wish other languages had ADTs and pattern matching and type safety like that.</li>
</ul></li>
<li>e.g. <a href="http://degoes.net/articles/modern-fp">This post using free monads</a> is very cool to read. But I’d also want to go and read about what/how a lens <code>Prism</code> is.</li>
<li>I get the impression that ‘real’ Haskell relies on several more complicated concepts like that. Maybe they’re “simple but not easy” too.
<ul>
<li>e.g. the posts linked from https://www.simplehaskell.org/ are very in-line with what I’m trying to get at.
<ul>
<li>It’s not that using ‘fancy types’ or the academic bleeding edge of what’s possible in Haskell is bad, or impractical. But for many non-Haskell developers, the costs to that kind of style look heavy and it’s not apparent that it’d be better than just writing working code in JavaScript.</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>I think the reason we end up with <a href="https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html">“Command Line Tools can be Faster than your Hadoop Cluster”</a> or <a href="https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim">“Your problem with vim is that you don’t grok vi”</a> is because of a lack of consideration of cost/benefit, which led to mistakenly not taking the time to learn things which would have been better.</p></li>
<li><p><a href="https://pythonspeed.com/articles/dont-need-kubernetes/">pythonspeed’s discussion of kubernetes drawbacks</a> makes it clear that the costs of running kubernetes for a small team outweigh the benefits. I think if the complexity had been communicated alongside the hype, it’s not a technical decision anyone would make.</p></li>
</ul>


<hr />

<div>
    
    
    <a href="../../posts/programming/2020-02-28-early-impression-of-elm-lang.html" style="float:right; text-align: right;">Older post</a>
    
</div>
<br style="clear: both;" />

<hr />

<!-- Load highlight.js for Syntax Highlighting. -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_light.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


            </div>

            <hr style="margin-bottom: 0px; border-top: 2px solid black;" />

            <div id="footer" class="pull-right" style="padding-right: 10px;">
                Site proudly generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </div>
        </div>

        <script>
            // The callbacks we wanna use
            // Phone-home, telling Google Analytics various metrics/dimensions

            // Use custom dimensions & metrics
            var AnalyticDimensionReaderKind = 'dimension1';
            var AnalyticMetricActiveTime      = 'metric1';
            var AnalyticMetricLongestIdleTime = 'metric2';
            var AnalyticMetricReadCount       = 'metric3';

            var gaCallbacks = {
                "scrollPercent": function(ms, perc) {
                    if (perc > 85) {
                        // EVENT: Page read
                        ga('send', {
                            hitType:       'event',
                            eventCategory: 'Scrolling',
                            eventAction:   'atBottom',
                            eventValue:    String(ms)
                        });
                    }
                },
                "read": function(ms, ct, timeToReach) {
                    // Use this to set DIMENSION
                    // timeToReach < 5s ==> Skim (default = Visitor)
                    if (timeToReach < 5 * 1000) {
                        // dimension1 = ReaderKind
                        ga('set', AnalyticDimensionReaderKind, "skimmer");
                    }

                    // timeToReach > 30s ==> Reader
                    if (timeToReach > 30 * 1000) {
                        // dimension1 = ReaderKind
                        ga('set', AnalyticDimensionReaderKind, "reader");
                    }

                    // EVENT: Page read
                    ga('send', {
                        hitType:       'event',
                        eventCategory: 'Reading',
                        eventAction:   'read',
                        eventValue:    String(timeToReach)
                    });

                    // METRIC
                    ga('set', AnalyticMetricReadCount, String(ct));
                },
                "initialIdle": function(ms) {
                    // EVENT: Started Reading
                    ga('send', {
                        hitType:       'event',
                        eventCategory: 'Scrolling',
                        eventAction:   'begun',
                        eventValue:    String(ms)
                    });
                },
                "timeSpent": function(total, active, curIdle, initIdle, longestIdle) {
                    // Update METRIC(S)?
                    ga('set', AnalyticMetricActiveTime, String(active));
                    ga('set', AnalyticMetricLongestIdleTime, String(longestIdle));
                },
                "idle": function(ms) {
                },
                "longestIdle": function(ms) {
                }
            }

            window.onload = function() {
                myAnalyticsInit(gaCallbacks);

                //
                // Initial dimensions & metrics
                //

                ga('set', AnalyticMetricReadCount, String(0));

                // EVENT: Page load
                ga('send', {
                    hitType:       'event',
                    eventCategory: 'pageLoad',
                    eventAction:   'begun',
                    eventValue:    String(ms)
                });

                // DIMENSION: visitor
                ga('set', AnalyticDimensionReaderKind, "visitor");
            }
        </script>
    </body>
</html>
